
<<<PAGE 1>>>



<<<PAGE 2>>>

Quantum Computer Science
An Introduction
In the 1990s it was realized that quantum physics has some
spectacular applications in computer science. This book is a concise
introduction to quantum computation, developing the basic elementsof this new branch of computational theory without assuming anybackground in physics. It begins with a novel introduction to thequantum theory from a computer-science perspective. It illustratesthe quantum-computational approach with several elementaryexamples of quantum speed-up, before moving to the majorapplications: Shor’s factoring algorithm, Grover’s search algorithm,and quantum error correction.
The book is intended primarily for computer scientists who know
nothing about quantum theory but would like to learn the elements ofquantum computation either out of curiosity about this newparadigm, or as a basis for further work in the subject. It will also beof interest to physicists who want to learn the theory of quantumcomputation, and to physicists and philosophers of science interestedin quantum foundational issues. It evolved during six years of teachingthe subject to undergraduates and graduate students in computerscience, mathematics, engineering, and physics, at Cornell University.
N. D
AVID MERMIN is Horace White Professor of Physics Emeritus at
Cornell University. He has received the Lilienfeld Prize of theAmerican Physical Society and the Klopsteg award of the AmericanAssociation of Physics Teachers. He is a member of the U.S. NationalAcademy of Sciences and the American Academy of Arts andSciences. Professor Mermin has written on quantum foundationalissues for several decades, and is known for the clarity and wit of hisscientiﬁc writings. Among his other books are Solid State Physics
(with N. W . Ashcroft, Thomson Learning 1976), Boojums all the Way
Through (Cambridge University Press 1990), and It’s about Time:
Understanding Einstein’s Relativity (Princeton University Press 2005).

<<<PAGE 3>>>

“This is one of the ﬁnest books in the rapidly growing ﬁeld of quan-
tum information. Almost every page contains a unique insight or anovel interpretation. David Mermin has once again demonstrated hislegendary pedagogical skills to produce a classic.”
Lov Grover, Bell Labs
“Mermin’s book will be a standard for instruction and reference for
years to come. He has carefully selected, from the mountain of knowl-edge accumulated in the last 20 years of research in quantum infor-mation theory, a manageable, coherent subset that constitutes a com-plete undergraduate course. While selective, it is in no sense “watered
down”; Mermin moves unﬂinchingly through difﬁcult arguments inthe Shor algorithm, and in quantum error correction theory, providinginvaluable diagrams, clear arguments, and, when necessary, extensiveappendices to get the students successfully through to the end. Thebook is suffused with Mermin’s unique knowledge of the history ofmodern physics, and has some of the most captivating writing to befound in a college textbook.”
David DiVincenzo, IBM T . J. Watson Research Center
“Mermin’s book is a gentle introduction to quantum computation espe-
cially aimed at an audience of computer scientists and mathematicians.It covers the basics of the ﬁeld, explaining the material clearly and con-taining lots of examples. Mermin has always been an entertaining andcomprehensible writer, and continues to be in this book. I expect it tobecome the deﬁnitive introduction to this material for non-physicists.”
Peter Shor, Massachusetts Institute of Technology
“Textbook writers usually strive for a streamlined exposition, smooth-
ing out the infelicities of thought and notation that plague any ﬁeld’searly development. Fortunately, David Mermin is too passionate andacute an observer of the cultural side of science to fall into this bland-ness. Instead of omitting infelicities, he explains and condemns them,at the same time using his experience of having taught the course manytimes to nip nascent misunderstandings in the bud. He celebrates theﬁeld’s mongrel origin in a shotgun wedding between classical com-puter scientists, who thought they knew the laws of information, andquantum physicists, who thought information was not their job. Dif-ferences remain: we hear, for example, why physicists love the Diracnotation and mathematicians hate it. Worked-out examples and exer-cises familiarize students with the necessary algebraic manipulations,while Mermin’s lucid prose and gentle humor cajole them toward asound intuition for what it all means, not an easy task for a subjectsuperﬁcially so counterintuitive.”
Charles Bennett, IBM T . J. Watson Research Center

<<<PAGE 4>>>

Quantum Computer Science
An Introduction
N. David Mermin
Cornell University


<<<PAGE 5>>>



<<<PAGE 6>>>

In memory of my brother, Joel Mermin
You would have enjoyed it.

<<<PAGE 7>>>

CAMBRIDGE UNIVERSITY PRESS
Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore, São Paulo
Cambridge University Press
The Edinburgh Building, Cambridge CB2 8RU , UK
First published in print format
ISBN-13    978-0-521-87658-2ISBN-13 978-0-511-34258-5© N. D. Mermin 2007
2007Information on this title: www.cambridge.org/9780521876582
This publication is in copyright. Subject to statutory exception and to the provision of 
relevant collective licensing agreements, no reproduction of any part may take place 
without the written permission of Cambrid ge University Press.
ISBN-10    0-511-34258-6
ISBN-10    0-521-87658-3
Cambridge University Press has no responsibility for the persistence or accuracy of urls 
for external or third-party internet websites referred to in this publication, and does not 
guarantee that any content on such websites is, or will remain, accurate or a ppropriate.Published in the United States of America by Cambridge University Press, New York
www.cambridge.org
hardbackeBook (NetLibrary)
eBook (NetLibrary)
hardback

<<<PAGE 8>>>

Contents
Preface page xi
A note on references xv
1 Cbits and Qbits 1
1.1 What is a quantum computer? 1
1.2 Cbits and their states 31.3 Reversible operations on Cbits 8
1.4 Manipulating operations on Cbits 11
1.5 Qbits and their states 17
1.6 Reversible operations on Qbits 19
1.7 Circuit diagrams 21
1.8 Measurement gates and the Born rule 231.9 The generalized Born rule 281.10 Measurement gates and state preparation 301.11 Constructing arbitrary 1- and 2-Qbit states 32
1.12 Summary: Qbits versus Cbits 34
2 General features and some simple examples 36
2.1 The general computational process 36
2.2 Deutsch’s problem 412.3 Why additional Qbits needn’t mess things up 462.4 The Bernstein–Vazirani problem 50
2.5 Simon’s problem 54
2.6 Constructing Toffoli gates 58
3 Breaking RSA encryption 63
3.1 Period ﬁnding, factoring, and cryptography 63
3.2 Number-theoretic preliminaries 643.3 66
3.4 Quantum period ﬁnding: preliminary remarks 68
3.6 Eliminating the 2-Qbit gates 76
3.7 Finding the period 79
3.5ThequantumFouriertransform 71RSA encryptio n

<<<PAGE 9>>>

viii CONTENTS
3.8 Calculating the periodic function 83
3.9 The unimportance of small phase errors 843.10 Period ﬁnding and factoring 86
4 Searching with a quantum computer 88
4.1 The nature of the search 88
4.2 The Grover iteration 894.3 How to construct W 94
4.4 Generalization to several special numbers 96
4.5 Searching for one out of four items 98
5 Quantum error correction 99
5.1 The miracle of quantum error correction 99
5.2 A simpliﬁed example 1005.3 The physics of error generation 1095.4 Diagnosing error syndromes 1135.5 The 5-Qbit error-correcting code 1175.6 The 7-Qbit error-correcting code 1215.7 Operations on 7-Qbit codewords 124
5.8 A 7-Qbit encoding circuit 127
5.9 A 5-Qbit encoding circuit 128
6 Protocols that use just a few Qbits 136
6.1 Bell states 136
6.2 Quantum cryptography 1376.3 Bit commitment 1436.4 Quantum dense coding 1466.5 Teleportation 1496.6 The GHZ puzzle 154
Appendices 159
A. Vector spaces: basic properties and Dirac notation 159
B. Structure of the general 1-Qbit unitary transformation 168C. Structure of the general 1-Qbit state 173D. Spooky action at a distance 175E. Consistency of the generalized Born rule 181F . Other aspects of Deutsch’s problem 183G. The probability of success in Simon’s problem 187H. One way to make a cNOT gate 189I. A little elementary group theory 193J. Some simple number theory 195K. Period ﬁnding and continued fractions 197L. Better estimates of success in period ﬁnding 201

<<<PAGE 10>>>

CONTENTS i x
M. Factoring and period ﬁnding 203
N. Shor’s 9-Qbit error-correcting code 207O. A circuit-diagrammatic treatment of the 7-Qbit code 210P . On bit commitment 216
Index 218

<<<PAGE 11>>>



<<<PAGE 12>>>

Preface
It was almost three quarters of a century after the discovery of quan-
tum mechanics, and half a century after the birth of information theoryand the arrival of large-scale digital computation, that people ﬁnallyrealized that quantum physics profoundly alters the character of infor-mation processing and digital computation. For physicists this devel-opment offers an exquisitely different way of using and thinking aboutthe quantum theory. For computer scientists it presents a surprisingdemonstration that the abstract structure of computation cannot bedivorced from the physics governing the instrument that performsthe computation. Quantum mechanics provides new computationalparadigms that had not been imagined prior to the 1980s and whosepower was not fully appreciated until the mid 1990s.
In writing this introduction to quantum computer science I have
kept in mind readers from several disciplines. Primarily I am address-ing computer scientists, electrical engineers, or mathematicians whomay know little or nothing about quantum physics (or any other kindof physics) but who wish to acquire enough facility in the subject to beable to follow the new developments in quantum computation, judge forthemselves how revolutionary they may be, and perhaps choose to par-ticipate in the further development of quantum computer science. Notthe least of the surprising things about quantum computation is thatremarkably little background in quantum mechanics has to be acquiredto understand and work with its applications to information process-ing. Familiarity with a few fundamental facts about ﬁnite-dimensionalvector spaces over the complex numbers (summarized and reviewed inAppendix A) is the only real prerequisite.
One of the secondary readerships I have in mind consists of physi-
cists who, like myself – I am a theorist who has worked in statisticalphysics, solid-state physics, low-temperature physics, and mathemat-ical physics – know very little about computer science, but would liketo learn about this extraordinary new application of their discipline.I stress, however, that my subject is quantum computer science, notquantum computer design. This is a book about quantum computa-tional software – not hardware. The difﬁcult question of how one mightactually build a quantum computer is beyond its scope.

<<<PAGE 13>>>

x i i PREFACE
Another secondary readership is made up of those philosophers and
physicists who – again like myself – are puzzled by so-called founda-tional issues: what the strange quantum formalism implies about thenature of the world that it so accurately describes. By applying quan-tum mechanics in an entirely new way – and especially by applying itto the processing of knowledge – quantum computation gives a newperspective on interpretational questions. While I rarely address suchmatters explicitly, for purely pedagogical reasons my presentation issuffused with a perspective on the quantum theory that is very close tothe venerable but recently much reviled Copenhagen interpretation.Those with a taste for such things may be startled to see how wellquantum computation resonates with the Copenhagen point of view.Indeed, it had been my plan to call this book Copenhagen Computa-
tionuntil the excellent people at Cambridge University Press and my
computer-scientist friends persuaded me that virtually no members ofmy primary readership would then have had any idea what it was about.
Several years ago I mentioned to a very distinguished theoretical physi-
cist that I spent the ﬁrst four lectures of a course in quantum computa-tion giving an introduction to quantum mechanics for mathematicallyliterate people who knew nothing about quantum mechanics, and quitepossibly little if anything about physics. His immediate response wasthat any application of quantum mechanics that can be taught after onlya four-hour introduction to the subject cannot have serious intellectualcontent. After all, he remarked, it takes any physicist many years todevelop a feeling for quantum mechanics.
It’s a good point. Nevertheless computer scientists and mathemati-
cians with no background in physics have been able quickly to learnenough quantum mechanics to understand and make major contri-butions to the theory of quantum computation. There are two mainreasons for this.
First of all, a quantum computer – or, more accurately, the abstract
quantum computer that one hopes someday to be able to embody in ac-tual hardware – is an extremely simple example of a physical system. Itis discrete, not continuous. It is made up out of a ﬁnite number of units,each of which is the simplest possible kind of quantum-mechanical sys-tem, a so-called two-state system, whose behavior, as we shall see, ishighly constrained and easily speciﬁed. Much of the analytical com-plexity of learning quantum mechanics is connected with masteringthe description of continuous (inﬁnite-state) systems. By restrictingattention to collections of two-state systems (or even d-state systems
for ﬁnite d) one can avoid much suffering. Of course one also loses
much wisdom, but hardly any of it – at least at this stage of the art – isrelevant to the basic theory of quantum computation.
Second, and just as important, the most difﬁcult part of learning
quantum mechanics is to get a good feeling for how the formalism

<<<PAGE 14>>>

P RE F A C E xiii
can be applied to actual phenomena. This almost invariably involves
formulating oversimpliﬁed abstract models of real physical systems, towhich the quantum formalism can then be applied. The best physicistshave an extraordinary intuition for what features of the phenomenaare essential and must be represented in a model, and what featuresare inessential and can be ignored. It takes years to develop such intu-ition. Some never do. The theory of quantum computation, however,is entirely concerned with an abstract model – the easy part of theproblem.
To understand how to build a quantum computer, or even to study
what physical systems are promising candidates for realizing such adevice, you must indeed have many years of experience in quantummechanics and its applications under your belt. But if you only want toknow what such a device is capable in principle of doing once you have it,then there is no reason to get involved in the really difﬁcult physics of thesubject. Exactly the same thing holds for ordinary classical computers.One can be a masterful practitioner of computer science without havingthe foggiest notion of what a transistor is, not to mention how it works.
So while you should be warned that the subset of quantum mechanics
you will acquire from this book is extremely focused and quite limitedin its scope, you can also rest assured that it is neither oversimpliﬁed norincomplete, when applied to the special task for which it is intended.
I might note that a third impediment to developing a good intuition
for quantum physics is that in some ways the behavior implied byquantum mechanics is highly counterintuitive, if not downright weird.Glimpses of such strange behavior sometimes show up at the levelof quantum computation. Indeed, for me one of the major appeals ofquantum computation is that it affords a new conceptual arena fortrying to come to a better understanding of quantum weirdness. Whenopportunities arise I will call attention to some of this strange behavior,rather than (as I easily could) letting it pass by unremarked upon andunnoticed.
The book evolved as notes for a course of 28 one-hour lectures on quan-
tum computation that I gave six times between 2000 and 2006 to a di-verse group of Cornell University undergraduates, graduate students,and faculty, in computer science, electrical engineering, mathematics,physics, and applied physics. With so broad an audience, little com-mon knowledge could be assumed. My lecture notes, as well as my ownunderstanding of the subject, repeatedly beneﬁted from commentsand questions in and after class, coming from a number of differentperspectives. What made sense to one of my constituencies was oftenpuzzling, absurd, or irritatingly simple-minded to others. This ﬁnalform of my notes bears little resemblance to my earliest versions, hav-ing been improved by insightful remarks, suggestions, and complaintsabout everything from notation to number theory.

<<<PAGE 15>>>

x i v PREFACE
In addition to the 200 or so students who passed through P481-P681-
CS483, I owe thanks to many others. Albert J. Sievers, then Directorof Cornell’s Laboratory of Atomic and Solid State Physics, startedme thinking hard about quantum computation by asking me to puttogether a two-week set of introductory lectures for members of ourlaboratory, in the Fall of 1999. So many people showed up from all overthe university that I decided it might be worth expanding this sur-vey into a full course. I’m grateful to two Physics Department chairs,Peter Lepage and Saul Teukolsky, for letting me continue teachingthat course for six straight years, and to the Computer Science De-partment chair, Charlie van Loan, for support, encouragement, anda steady stream of wonderful students. John Preskill, though he maynot know it, taught me much of the subject from his superb onlineCaltech lecture notes. Charles Bennett ﬁrst told me about quantuminformation processing, back when the term might not even have beencoined, and he has always been available as a source of wisdom and clar-iﬁcation. Gilles Brassard has on many occasions supplied me with helpfrom the computer-science side. Chris Fuchs has been an indispens-able quantum-foundational critic and consultant. Bob Constable mademe, initially against my will, a certiﬁed Cornell Information Scientistand introduced me to many members of that excellent community.But most of all, I owe thanks to David DiVincenzo, who collaboratedwith me on the 1999 two-week LASSP Autumn School and has actedrepeatedly over the following years as a sanity check on my ideas, anindispensable source of references and historical information, a patientteacher, and an encouraging friend.

<<<PAGE 16>>>

A note on references
Quantum Computer Science is a pedagogical introduction to the basic
structure and procedures of the subject – a quantum-computationalprimer. It is not a historical survey of the development of the ﬁeld.Many of these procedures are named after the people who ﬁrst putthem forth, but although I use their names, I do not cite the originalpapers unless they add something to my own exposition. This is be-cause, not surprisingly, work done since the earliest papers has led toclearer expositions of those ideas. I learned the subject myself almostexclusively from secondary, tertiary, or even higher-order sources, andthen reformulated it repeatedly in the course of teaching it for six years.
On the few occasions when I do cite a paper it is either because
it completes an exposition that I have only sketched, or because thework has not yet become identiﬁed in the ﬁeld with the name(s) of theauthor(s) and I wanted to make clear that it was not original with me.
Readers interested in hunting down earlier work in the ﬁeld can
begin (and in most cases conclude) their search at the quantum-physicssubdivision of the Cornell (formerly Los Alamos) E-print Archive,http://arxiv.org/archive/quant-ph , where most of the
important papers in the ﬁeld have been and are still being posted.

<<<PAGE 17>>>



<<<PAGE 18>>>

Chapter 1
Cbits and Qbits
1.1 What is a quantum computer?
It is tempting to say that a quantum computer is one whose operation
is governed by the laws of quantum mechanics. But since the laws ofquantum mechanics govern the behavior of all physical phenomena,this temptation must be resisted. Your laptop operates under the lawsof quantum mechanics, but it is not a quantum computer. A quantumcomputer is one whose operation exploits certain very special transfor-mations of its internal state, whose description is the primary subject ofthis book. The laws of quantum mechanics allow these peculiar trans-formations to take place under very carefully controlled conditions.
In a quantum computer the physical systems that encode the indi-
vidual logical bits must have no physical interactions whatever that arenot under the complete control of the program. All other interactions,however irrelevant they might be in an ordinary computer – whichwe shall call classical – introduce potentially catastrophic disruptions
into the operation of a quantum computer. Such damaging encoun-ters can include interactions with the external environment, such asair molecules bouncing off the physical systems that represent bits, orthe absorption of minute amounts of ambient radiant thermal energy.There can even be disruptive interactions between the computation-ally relevant features of the physical systems that represent bits andother features of those same systems that are associated with computa-tionally irrelevant aspects of their internal structure. Such destructiveinteractions, between what matters for the computation and what doesnot, result in decoherence , which is fatal to a quantum computation.
To avoid decoherence individual bits cannot in general be encoded
in physical systems of macroscopic size, because such systems (exceptunder very special circumstances) cannot be isolated from their ownirrelevant internal properties. Such isolation can be achieved if the bitsare encoded in a small number of states of a system of atomic size, whereextra internal features do not matter, either because they do not exist, orbecause they require unavailably high energies to come into play. Suchatomic-scale systems must also be decoupled from their surroundingsexcept for the completely controlled interactions that are associatedwith the computational process itself.
1

<<<PAGE 19>>>

2 CBITS AND QBITS
Two things keep the situation from being hopeless. First, because
the separation between the discrete energy levels of a system on theatomic scale can be enormously larger than the separation between thelevels of a large system, the dynamical isolation of an atomic systemis easier to achieve. It can take a substantial kick to knock an atomout of its state of lowest energy. The second reason for hope is thediscovery that errors induced by extraneous interactions can actuallybe corrected if they occur at a sufﬁciently low rate. While error cor-rection is routine for bits represented by classical systems, quantumerror correction is constrained by the formidable requirement that itbe done without knowing either the original or the corrupted state ofthe physical systems that represent the bits. Remarkably, this turns outto be possible.
Although the situation is therefore not hopeless, the practical difﬁ-
culties in the way of achieving useful quantum computation are enor-mous. Only a rash person would declare that there will be no usefulquantum computers by the year 2050, but only a rash person wouldpredict that there will be. Never mind. Whether or not it will everbecome a practical technology, there is a beauty to the theory of quan-tum computation that gives it a powerful appeal as a lovely branch ofmathematics, and as a strange generalization of the paradigm of clas-sical computer science, which had completely escaped the attention ofcomputer scientists until the 1980s. The new paradigm demonstratesthat the theory of computation can depend profoundly on the physicsof the devices that carry it out. Quantum computation is also a valuablesource of examples that illustrate and illuminate, in novel ways, themysterious phenomena that quantum behavior can give rise to.
For computer scientists the most striking thing about quantum com-
putation is that a quantum computer can be vastly more efﬁcient thananything ever imagined in the classical theory of computational com-plexity, for certain computational tasks of considerable practical inter-est. The time it takes the quantum computer to accomplish such tasksscales up much more slowly with the size of the input than it does inany classical computer. Much of this book is devoted to examining themost celebrated examples of this speed-up.
This exposition of quantum computation begins with an introduc-
tion to quantum mechanics, specially tailored for this particular ap-plication. The quantum-mechanics lessons are designed to give you,as efﬁciently as possible, the conceptual tools needed to delve intoquantum computation. This is done by restating the rules of quantummechanics, not as the remarkable revision of classical Newtonian me-chanics required to account for the behavior of matter at the atomicand subatomic levels, but as a curious generalization of rules describ-ing an ordinary classical digital computer. By focusing exclusively onhow quantum mechanics enlarges the possibilities for the physical ma-nipulation of digital information, it is possible to characterize how

<<<PAGE 20>>>

1.2 CBITS AND THEIR STATES 3
the quantum theory works in an elementary and quite concise way,
which is nevertheless rigorous and complete for this special area ofapplication.
While I assume no prior familiarity with quantum physics (or any
other kind of physics), I do assume familiarity with elementary linearalgebra and, in particular, with the theory of ﬁnite-dimensional vectorspaces over the complex numbers. Appendix A summarizes the relevantlinear algebra. It is worth examining even if you are well acquaintedwith the mathematics of such vector spaces, since it also provides acompact summary of the mathematically unconventional language –Dirac notation – in which linear algebra is couched in all treatments of
quantum computation. Dirac notation is also developed, more infor-mally, throughout the rest of this chapter.
1.2 Cbits and their states
We begin with an offbeat formulation of what an ordinary classicalcomputer does. I frame the elementary remarks that follow in a lan-guage which may look artiﬁcial and cumbersome, but is designed toaccommodate the richer variety of things that a computer can do if ittakes full advantage of the possibilities made available by the quantum-
mechanical behavior of its constituent parts. By introducing and apply-
ing the unfamiliar nomenclature and notation of quantum mechanicsin a familiar classical context, I hope to make a little less strange itssubsequent extension to the broader quantum setting.
A classical computer operates on strings of zeros and ones, such
as 110010111011000, converting them into other such strings. Each
position in such a string is called a bit, and it contains either a 0 or a
1. To represent such collections of bits the computer must contain acorresponding collection of physical systems, each of which can existin two unambiguously distinguishable physical states, associated withthe value (0 or 1) of the abstract bit that the physical system represents.Such a physical system could be, for example, a switch that could beopen (0) or shut (1), or a magnet whose magnetization could be orientedin two different directions, “up” (0) or “down” (1).
It is a common practice in quantum computer science to use the
same term “bit” to describe the two-state classical system that rep-resents the value of the abstract bit. But this use of a single term tocharacterize both the abstract bit (0 or 1) and the physical system whosetwo states represent the two values is a potential source of confusion.To avoid such confusion, I shall use the term Cbit (“C” for “classi-
cal”) to describe the two-state classical physical system and Qbit to
describe its quantum generalization. This terminology is inspired byPaul Dirac’s early use of c-number and q-number to describe classical
quantities and their quantum-mechanical generalizations. “Cbit” and

<<<PAGE 21>>>

4 CBITS AND QBITS
“Qbit” are preferable to “c-bit” and “q-bit” because the terms them-
selves often appear in hyphenated constructions.
Unfortunately the preposterous spelling qubit currently holds sway
for the quantum system. The term qubit was invented and ﬁrst used
in print by the otherwise admirable Benjamin Schumacher.1A brief
history of the term can be found in the acknowledgments at the end of
his paper. Although “qubit” honors the English (German, Italian, ...)
rule that qshould be followed by u, it ignores the equally powerful
requirement that qushould be followed by a vowel. My guess is that
“qubit” has gained acceptance because it visually resembles an obsoleteEnglish unit of distance, the homonymic cubit . To see its ungainliness
with fresh eyes, it sufﬁces to imagine that Dirac had written qunumber
instead of q-number , or that one erased transparencies and cleaned one’s
ears with Qutips .
Because clear distinctions among bits, Cbits, and Qbits are crucial
in the introduction to quantum computation that follows, I shall usethis currently unfashionable terminology. If you are already addictedto the term qubit , please regard Qbit as a convenient abbreviation.
To prepare for the extension from Cbits to Qbits, I introduce what
may well strike you as a degree of notational overkill in the discussionof Cbits that follows. We shall represent the state of each Cbit as a kindof box, depicted by the symbol |/angbracketright, into which we place the value, 0
or 1, represented by that state. Thus the two distinguishable states ofa Cbit are represented by the symbols |0/angbracketrightand|1/angbracketright. It is the common
practice to call the symbol |0/angbracketrightor|1/angbracketrightitself the state of the Cbit, thereby
using the same term to refer to both the physical condition of theCbit and the abstract symbol that represents that physical condition.There is nothing unusual in this. For example one commonly uses theterm “position” to refer to the symbol xthat represents the physical
position of an object. I call this common, if little noted, practice to yourattention only because in the quantum case “state” refers only to the
symbol, there being nointernal property of the Qbit that the symbol
represents. The subtle relation between Qbits and their state symbolwill emerge later in this chapter.
Along the same lines, we shall characterize the states of the ﬁve Cbits
representing 11001, for example, by the symbol
|1/angbracketright|1/angbracketright|0/angbracketright|0/angbracketright|1/angbracketright, (1.1)
and refer to this object as the state of all ﬁve Cbits. Thus a pair of Cbits
can have (or “be in”) any of the four possible states
|0/angbracketright|0/angbracketright,|0/angbracketright|1/angbracketright,|1/angbracketright|0/angbracketright,|1/angbracketright|1/angbracketright, (1.2)
1 Benjamin Schumacher, “Quantum coding,” Physical Review A51,
2738–2747 (1995).

<<<PAGE 22>>>

1.2 CBITS AND THEIR STATES 5
three Cbits can be in any of the eight possible states
|0/angbracketright|0/angbracketright|0/angbracketright,|0/angbracketright|0/angbracketright|1/angbracketright,|0/angbracketright|1/angbracketright|0/angbracketright,|0/angbracketright|1/angbracketright|1/angbracketright,|1/angbracketright|0/angbracketright|0/angbracketright,
|1/angbracketright|0/angbracketright|1/angbracketright,|1/angbracketright|1/angbracketright|0/angbracketright,|1/angbracketright|1/angbracketright|1/angbracketright, (1.3)
and so on.
As (1.4) already makes evident, when there are many Cbits such
products are often much easier to read if one encloses the whole stringof zeros and ones in a single bigger box of the form |/angbracketright rather than
having a separate box for each Cbit:
|000/angbracketright,|001/angbracketright,|010/angbracketright,|011/angbracketright,|100/angbracketright,|101/angbracketright,|110/angbracketright,|
111/angbracketright. (1.4)
We shall freely move between these two equivalent ways of expressing
the state of several Cbits that represent a string of bits, boxing the wholestring or boxing each individual bit. Whether the form (1.3) or (1.4) isto be preferred depends on the context.
There is also a third form, which is useful when we regard the zeros
and ones as constituting the binary expansion of an integer. We canthen replace the representations of the 3-Cbit states in (1.4) by theeven shorter forms
|0/angbracketright,|1/angbracketright,|2/angbracketright,|3/angbracketright,|4/angbracketright,|5/angbracketright,|6/angbracketright,|7/angbracketright. (1.5)
Note that, unlike the forms (1.3) and (1.4), the form (1.5) is ambiguous,
unless we are told that these symbols express states of three Cbits. Ifwe are not told, then there is no way of telling, for example, whether|3/angbracketrightrepresents the 2-Cbit state |11/angbracketright, the 3-Cbit state |011/angbracketright, or the 4-Cbit
state|0011/angbracketright, etc. This ambiguity can be removed, when necessary, by
adding a subscript making the number of Cbits explicit:
|0/angbracketright
3,|1/angbracketright3,|2/angbracketright3,|3/angbracketright3,|4/angbracketright3,|5/angbracketright3,|6/angbracketright3,|7/angbracketright3. (1.6)
Be warned, however, that, when there is no need to emphasize how
many Cbits |x/angbracketrightrepresents, it can be useful to use such subscripts for
other purposes. If, for example, Alice and Bob each possess a singleCbit it can be convenient to describe the state of Alice’s Cbit (if it hasthe value 1) by |1/angbracketright
a, Bob’s (if it has the value 0) by |0/angbracketrightb, and the joint
state of the two by |1/angbracketrighta|0/angbracketrightbor|10/angbracketrightab.
Dirac introduced the |/angbracketrightnotation (known as Dirac notation) in the
early days of the quantum theory, as a useful way to write and manipu-late vectors. For silly reasons he called such vectors kets, a terminology
that has survived to this day. In Dirac notation you can put into the box|/angbracketrightanything that serves to specify what the vector is. If, for example, we
were talking about displacement vectors in ordinary three-dimensionalspace, we could have a vector
|5 horizontal centimeters northeast /angbracketright. (1.7)

<<<PAGE 23>>>

6 CBITS AND QBITS
In using Dirac notation to express the state of a Cbit, or a collection
of Cbits, I’m suggesting that there might be some utility in thinkingof the states as vectors. Is there? Well, in the case of Cbits, not verymuch, but maybe a little. We now explore this way of thinking aboutCbit states, because when we come to the generalization to Qbits, itbecomes absolutely essential to consider them to be vectors – so muchso that the term state is often taken to be synonymous with vector (or,
more precisely, “vector that represents the state”).
We shall brieﬂy explore what one can do with Cbits when one takes
the two states |0/angbracketrightand|1/angbracketrightof a single Cbit to be represented by two
orthogonal unit vectors in a two-dimensional space. While this is little
more than a curious and unnecessarily elaborate way of describingCbits, it is fundamental and unavoidable in dealing with Qbits. Playingunfamiliar and somewhat silly games with Cbits will enable you tobecome acquainted with much of the quantum-mechanical formalismin a familiar setting.
If you prefer your vectors to be expressed in terms of components,
note that we can represent the two orthogonal states of a single Cbit,|0/angbracketrightand|1/angbracketright, as column vectors
|0/angbracketright=/parenleftbigg1
0/parenrightbigg
, |1/angbracketright=/parenleftbigg0
1/parenrightbigg
. (1.8)
In the case of two Cbits the vector space is four-dimensional, with
an orthonormal basis
|00/angbracketright,|01/angbracketright,|10/angbracketright,|11/angbracketright. (1.9)
The alternative notation for this basis,
|0/angbracketright|0/angbracketright,|0/angbracketright|1/angbracketright,|1/angbracketright|0/angbracketright,|1/angbracketright|1/angbracketright, (1.10)
is deliberately designed to suggest multiplication, since it is, in fact,
a short-hand notation for the tensor product of the two single-Cbit
2-vectors, written in more formal mathematical notation as
|0/angbracketright⊗| 0/angbracketright
,|0/angbracketright⊗| 1/angbracketright,|1/angbracketright⊗| 0/angbracketright,|1/angbracketright⊗| 1/angbracketright. (1.11)
In terms of components, the tensor product a⊗bof an M-component
vector awith components aµand an N-component vector bwith com-
ponents bνis the ( MN )-component vector with components indexed
by all the MN possible pairs of indices ( µ,ν), whose ( µ,ν)th com-
ponent is just the product aµbν. A broader view can be found in the
extended review of vector-space concepts in Appendix A. I shall freelymove back and forth between the various ways (1.9)–(1.11) of writingthe tensor product and their generalizations to multi-Cbit states, usingin each case a form that makes the content clearest.
Once one agrees to regard the two 1-Cbit states as orthogonal unit
vectors, the tensor product is indeed the natural way to represent

<<<PAGE 24>>>

1.2 CBITS AND THEIR STATES 7
multi-Cbit states, since it leads to the obvious multi-Cbit generaliza-
tion of the representation (1.8) of 1-Cbit states as column vectors. If weexpress the states |0/angbracketrightand|1/angbracketrightof each single Cbit as column vectors, then
we can get the column vector describing a multi-Cbit state by repeat-edly applying the rule for the components of the tensor product of two
vectors. The result is illustrated here for a three-fold tensor product:
/parenleftbiggx
0
x1/parenrightbigg
⊗/parenleftbiggy0
y1/parenrightbigg
⊗/parenleftbiggz0
z1/parenrightbigg
=⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝x
0y0z0
x0y0z1
x0y1z0
x0y1z1
x1y0z0
x1y0z1
x1y1z0
x1y1z1⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠. (1.12)
On applying this, for example, to the case |5/angbracketright
3,w eh a v e
|5/angbracketright3=|101/angbracketright=| 1/angbracketright|0/angbracketright|1/angbracketright=/parenleftbigg0
1/parenrightbigg
⊗/parenleftbigg1
0/parenrightbigg
⊗/parenleftbigg0
1/parenrightbigg
=⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝0
0000100⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠.(1.13)
If we label the vertical components of the 8-vector on the right
0, 1,... ,7, from the top down, then the single nonzero component is
the 1 in positio n 5 – precisely the position speciﬁed by the state vector
in its form on the left of (1.13). This is indeed the obvious multi-Cbitgeneralization of the column-vector form (1.8) for 1-Cbit states.
This is quite general: the tensor-product structure of multi-Cbit
states is just what one needs in order for the 2
n-dimensional column
vector representing the state |m/angbracketrightnto have all its entries zero except for
a single 1 in the mth position down from the top.
One can turn this development upside down, taking as one’s starting
point the simple rule that an integer xin the range 0 ≤x<Nis
represented by one of Northonormal vectors in an N-dimensional
space. One can then pick a basis so that 0 is represented by an N-
component column vector |0/angbracketrightthat has 0 in every position except for a
1 in the top position, and xis to be represented by an N-component
column vector |x/angbracketrightthat has 0 in every position except for a 1 in the
position xdown from the top. It then follows from the nature of the
tensor product that if N=2nand xhas the binary expansion x=/summationtextn−1
j=0xj2j, then the column vector |x/angbracketrightnis the tensor product of the n
2-component column vectors |xj/angbracketright:
|x/angbracketrightn=| xn−1/angbracketright⊗| xn−2/angbracketright⊗···⊗| x1/angbracketright⊗| x0/angbracketright. (1.14)

<<<PAGE 25>>>

8 CBITS AND QBITS
In dealing with n-Cbit states of the form (1.14) we shall identify each
of the n1-Cbit states, out of which they are composed, by giving the
power of 2 associated with the individual bit that the Cbit represents.Thus the 1-Cbit state on the extreme right of (1.14) represents Cbit 0,the state immediately to its left represents Cbit 1, and so on.
This relation between tensor products of vectors and positional
notation for integers is not conﬁned to the binary system. Suppose,for example, one represents a decimal digit x=0,1,... , 9a sa1 0 -
component column vector v
(x)with all components 0 except for a
1,xpositions down from the top. If the n-digit decimal number
X=/summationtextn−1
j=0xj10jis represented by the tensor product V=v(xn−1)⊗
v(xn−2)⊗···⊗ v(1)⊗v(0), then Vwill be a 10n-component column vec-
tor with all components 0 except for a 1, xpositions down from the
top.
Although the representation of Cbit states by column vectors clearly
shows why tensor products give a natural description of multi-Cbitstates, for almost all other purposes it is better and much simpler toforget about column vectors and components, and deal directly withthe state vectors in their abstract forms (1.3)–(1.6).
1.3 Reversible operations on Cbits
Quantum computers do an important part of their magic through re-
versible operations, which transform the initial state of the Qbits into
its ﬁnal form using only processes whose action can be inverted. Thereis only a single irreversible component to the operation of a quantum
computer, called measurement , which is the only way to extract useful
information from the Qbits after their state has acquired its ﬁnal form.Although measurement is a nontrivial and crucial part of any quantumcomputation, in a classical computer the extraction of information fromthe state of the Cbits is so conceptually straightforward that it is notviewed as an inherent part of the computational process, though it is,of course, a nontrivial concern for those who design digital displaysor printers. Because the only computationally relevant operations ona classical computer that can be extended to operations on a quantumcomputer are reversible, only operations on Cbits that are reversiblewill be of interest to us here.
In a reversible operation every ﬁnal state arises from a unique initial
state. An example of an irreversible operation is ERASE, which forcesa Cbit into the state |0/angbracketrightregardless of whether its initial state is |0/angbracketrightor
|1/angbracketright. ERASE is irreversible in the sense that, given only the ﬁnal state
and the fact that it was the output of the operation ERASE, there is noway to recover the initial state.
The only nontrivial reversible operation we can apply to a single Cbit
is the NOT operation, denoted by the symbol
X, which interchanges

<<<PAGE 26>>>

1.3 REVERSIBLE OPERATIONS ON CBITS 9
the two states |0/angbracketrightand|1/angbracketright:
X:|x/angbracketright→| ˜x/angbracketright;˜1=0,˜0=1. (1.15)
This is sometimes referred to as ﬂipping the Cbit. NOT is reversible
because it has an inverse: applying Xa second time brings the state of
the Cbit back to its original form:
X2=1, (1.16)
where 1is the unit (identity) operator. If we represent the two or-
thogonal states of the Cbit by the column vectors (1.8), then we canexpress NOT by a linear operator
Xon the two-dimensional vector
space, whose action on the column vectors is given by the matrix
X=/parenleftbigg01
10/parenrightbigg
. (1.17)
So the two reversible things you can do to a single Cbit – leaving it
alone and ﬂipping it – correspond to the two linear operators Xand1,
1=/parenleftbigg10
01/parenrightbigg
, (1.18)
on its two-dimensional vector space.
A pedantic digression: since multiplication by the scalar 1 and ac-
tion by the unit operator 1achieve the same result, I shall sometimes
follow the possibly irritating practice of physicists and not distinguishnotationally between them. I shall take similar liberties with the scalar0, the zero vector 0, and the zero operator
0.
Possibilities for reversible operations get richer when we go from a
single Cbit to a pair of Cbits. The most general reversible operation ontwo Cbits is any permutation of their four possible states. There are 4!= 24 such operations. Perhaps the simplest nontrivial example is theswap (or exchange ) operator
Sij, which simply interchanges the states
of Cbits iand j:
S10|xy/angbracketright=| yx/angbracketright. (1.19)
Since the swap operator S10interchanges |01/angbracketright=| 1/angbracketright2and|10/angbracketright=| 2/angbracketright2,
while leaving |00/angbracketright=| 0/angbracketright2and|11/angbracketright=| 3/angbracketright2ﬁxed, its matrix in the basis
|0/angbracketright2,|1/angbracketright2,|2/angbracketright2,|3/angbracketright2is
S10=S01=⎛
⎜⎜⎝1000
001001000001⎞
⎟⎟⎠. (1.20)
The 2-Cbit operator whose extension to Qbits plays by far the
most important role in quantum computation is the controlled-NOT
or cNOT operator
Cij. If the state of the ith Cbit (the control Cbit )i s
|0/angbracketright,Cijleaves the state of the jth Cbit (the target Cbit ) unchanged, but,

<<<PAGE 27>>>

1 0 CBITS AND QBITS
if the state of the control Cbit is |1/angbracketright,Cijapplies the NOT operator X
to the state of the target Cbit. In either case the state of the control Cbit
is left unchanged.
We can summarize this compactly by writing
C10|x/angbracketright|y/angbracketright=| x/angbracketright|y⊕x/angbracketright, C01|x/angbracketright|y/angbracketright=| x⊕y/angbracketright|y/angbracketright, (1.21)
where ⊕denotes addition modulo 2:
y⊕0=y, y⊕1=˜y=1−y. (1.22)
The modulo-2 sum x⊕yis also called the “exclusive OR” (or XOR)
ofxand y.
You can construct SWAP out of three cNOT operations:
Sij=CijCjiCij. (1.23)
This can easily be veriﬁed by repeated applications of (1.21), noting
that x⊕x=0. We note some other ways of showing it below.
To construct the matrix for the cNOT operation in the four-
dimensional 2-Cbit space, note that if the control Cbit is on the leftthen cNOT leaves |00/angbracketright=| 0/angbracketright
2and|01/angbracketright=| 1/angbracketright2ﬁxed and exchanges
|10/angbracketright=| 2/angbracketright2and|11/angbracketright=| 3/angbracketright2. Therefore the 4 ⊗4 matrix representing
C10is just
C10=⎛
⎜⎜⎝1000
0100
00010010⎞
⎟⎟⎠. (1.24)
If the control Cbit is on the right, then the states |01/angbracketright=| 1/angbracketright
2and
|11/angbracketright=| 3/angbracketright2are interchanged, and |00/angbracketright=| 0/angbracketright2and|10/angbracketright=| 2/angbracketright2are ﬁxed,
so the matrix representing C01is
C01=⎛
⎜⎜⎝1000
000100100100⎞
⎟⎟⎠. (1.25)
The construction (1.23) of
Sout of cNOT operators also follows
from (1.20), (1.24), and (1.25), using matrix multiplication. As a prac-tical matter, it is almost always more efﬁcient to establish operatoridentities by dealing with them directly as operators, avoiding matrixrepresentations.
A very common kind of 2-Cbit operator consists of the tensor prod-
uct⊗of two 1-Cbit operators:
(
a⊗b)|xy/angbracketright=(a⊗b)|x/angbracketright⊗| y/angbracketright= a|x/angbracketright⊗b|y/angbracketright, (1.26)
from which it follows that
(a⊗b)(c⊗d)=(ac)⊗(bd). (1.27)

<<<PAGE 28>>>

1.4 MANIPULATING OPERATIONS ON CBITS 1 1
This tensor-product notation for operators can become quite un-
gainly when one is dealing with a large number of Cbits and wants towrite a 2-Cbit operator that affects only a particular pair of Cbits. If,for example, the 2-Cbit operator in (1.26) acts only on the second andfourth Cbits from the right in a 6-Cbit state, then the operator on the6-Cbit state has to be written as
1⊗1⊗a⊗1⊗b⊗1. (1.28)
To avoid such typographical monstrosities, we simplify (1.28) to
1⊗1⊗a⊗1⊗b⊗1=a3b1=b1a3, (1.29)
where the subscript indicates which Cbit the 1-Cbit operator acts on,
and it is understood that those Cbit states whose subscripts do notappear remain unmodiﬁed – i.e. they are acted on by the unit operator.As noted above, we label each 1-Cbit state by the power of 2 it wouldrepresent if the nCbits were representing an integer: the state on the
extreme right is labeled 0, the one to its left, 1, etc. Since the orderin which
aand bare written is clearly immaterial if their subscripts
specify different 1-Cbit states, the order in which one writes them in(1.29) doesn’t matter: 1-Cbit operators that act on different 1-Cbitstates commute.
Sometimes we deal with 1-Cbit operators that already have sub-
scripts in their names; under such conditions it is more conve-nient to indicate which Cbit state the operator acts on by a super-script, enclosed in parentheses to avoid confusion with an exponent:thus
X(2)represents the 1-Cbit operator that ﬂips the third Cbit
state from the right, but X2represents the square of the ﬂip oper-
ator (i.e. the unit operator) without reference to which Cbit state itacts on.
To prepare for some of the manipulations we will be doing with
operations on Qbits, we now examine a few examples of working withoperators on Cbits.
1.4 Manipulating operations on Cbits
It is useful to introduce a 1-Cbit operator nthat is simply the projection
operator onto the state |1/angbracketright:
n|x/angbracketright= x|x/angbracketright,x=0o r1. (1.30)
Because |0/angbracketrightand|1/angbracketrightare eigenvectors of nwith eigenvalues 0 and 1, nis
called the 1-Cbit number operator . We also deﬁne the complementary
operator,
˜n=1−n, (1.31)

<<<PAGE 29>>>

1 2 CBITS AND QBITS
which projects onto the state |0/angbracketright,s o|0/angbracketrightand|1/angbracketrightare eigenvectors of ˜nwith
eigenvalues 1 and 0. These operators have the matrix representations
n=/parenleftbigg00
01/parenrightbigg
, ˜n=/parenleftbigg10
00/parenrightbigg
. (1.32)
It follows directly from their deﬁnitions that
n2=n, ˜n2=˜n, n˜n=˜nn=0, n+˜n=1.(1.33)
We also have
nX=X˜n, ˜nX=Xn, (1.34)
since ﬂipping the state of a Cbit and then acting on it with n(˜n)i st h e
same as acting on the state with ˜n(n) and then ﬂipping it. All the simple
relations in (1.33) and (1.34) also follow, as they must, from the matrixrepresentations (1.17) and (1.32) for
X,n, and ˜n.
Although nhas no interpretation as a physical operation on Cbits –
replacing the state of a Cbit by the zero vector corresponds to no physi-cal operation – it can be useful in deriving relations between operationsthat do have physical meaning. Since, for example, the SWAP operator
Sijacts as the identity if the states of the Cbits iand jare the same, and
ﬂips the numbers represented by both Cbits if their states are different,it can be written as
Sij=ninj+˜ni˜nj+(XiXj)(ni˜nj+˜ninj). (1.35)
At the risk of belaboring the obvious, I note that (1.35) acts as the
swap operator because if both Cbits are in the state |1/angbracketright(so swapping
their states does nothing) then only the ﬁrst term in the sum acts (i.e.each of the other three terms gives 0) and multiplies the state by 1;if both Cbits are in the state |0/angbracketright, only the second term acts and again
multiplies the state by 1; if Cbit iis in the state |1/angbracketrightand Cbit jis in the
state|0/angbracketright, only the third term acts and the effect of ﬂipping both Cbits
is to swap their states; and if Cbit iis in the state |0/angbracketrightand Cbit jis in
the state |1/angbracketright, only the fourth term acts and the effect of the two
Xsi s
again to swap their states.
To help you become more at home with this notation, you are urged
to prove from (1.35) that S2
ij=1, using only the relations in (1.33) and
(1.34), the fact that X2=1, and the fact that 1-Cbit operators acting
on different Cbits commute.
The construction (1.23) of SWAP out of cNOT operators can also
be demonstrated using a more algebraic approach. Note ﬁrst that Cij
can be expressed in terms of ns and Xsb y
Cij=˜ni+Xjni, (1.36)
since if the state of Cbit iis|0/angbracketrightonly the ﬁrst term acts, which leaves the
states of both Cbits unchanged, but if the state of Cbit iis|1/angbracketrightonly the
second term acts, which leaves the state of Cbit iunchanged, while Xj

<<<PAGE 30>>>

1.4 MANIPULATING OPERATIONS ON CBITS 1 3
ﬂips Cbit j. If you substitute expressions of the form (1.36) for each
of the three terms in (1.23), then you can show by purely algebraicmanipulations that four of the eight terms into which the productsexpand vanish and the remaining four can be rearranged to give theswap operator (1.35).
An operator that has no direct role to play in classical computa-
tion, but which is as important as the NOT operator
Xin quantum
computation, is the operator Zdeﬁned by
Z=˜n−n=/parenleftbigg10
0−1/parenrightbigg
. (1.37)
It follows from (1.34) (or from the matrix representations (1.17) and
(1.37)) that Xanticommutes with Z:
ZX=− XZ. (1.38)
Since ˜n+n=1, we can use (1.37) to express the 1-Cbit projection
operators ˜nandnin terms of 1andZ:
n=1
2(1−Z), ˜n=1
2(1+Z). (1.39)
Using this we can rewrite the cNOT operator (1.36) in terms of X
andZoperators:
Cij=1
2/parenleftbig
1+Zi/parenrightbig
+1
2Xj/parenleftbig
1−Zi/parenrightbig
=1
2/parenleftbig
1+Xj/parenrightbig
+1
2Zi/parenleftbig
1−Xj/parenrightbig
. (1.40)
The second form follows from the ﬁrst because Xjand Zicommute
when i/negationslash=j. Note that, if we were to interchange XandZin the second
line of (1.40), we would get back the expression directly above it exceptfor the interchange of iand j. So interchanging the
XandZoperators
has the effect of switching which Cbit is the control and which isthe target, changing
Cijinto Cji. An operator that can produce just
this effect is the Hadamard transformation (also sometimes called the
Walsh–Hadamard transformation ),
H=1√
2(X+Z)=1√
2/parenleftbigg11
1−1/parenrightbigg
. (1.41)
This is another operator of fundamental importance in quantum
computation.2
2 Physicists should note here an unfortunate clash between the notations of
quantum computer science and physics. Quantum physicists invariably use
Hto denote the Hamiltonian function (in classical mechanics) or
Hamiltonian operator (in quantum mechanics). Fortunately Hamiltonianoperators, although of crucial importance in the design of quantumcomputers, play a very limited role in the general theory of quantumcomputation, being completely overshadowed by the unitarytransformations that they generate. So physicists can go along with thecomputer-science notation without getting into serious trouble.

<<<PAGE 31>>>

1 4 CBITS AND QBITS
Since X2=Z2=1and XZ=− ZX, one easily shows from the
deﬁnition (1.41) of Hin terms of XandZthat
H2=1 (1.42)
and that
HXH=Z, HZH=X. (1.43)
This shows how Hcan be used to interchange the Xand Zoperators
inCji: it follows from (1.43), together with (1.40) and (1.42), that
Cji=/parenleftbig
HiHj/parenrightbig
Cij/parenleftbig
HiHj/parenrightbig
. (1.44)
We shall see that this simple relation can be put to some quite
remarkable uses in a quantum computer. While one can achievethis interchange on a classical computer using the SWAP operation,
Cji=SijCijSij, the crucial difference between Sijand HiHjis that
the latter is a product of two 1-Cbit operators, while the former is not.
Of course, the action of Hon the state of a Cbit that follows from
(1.41),
H|0/angbracketright=1√
2(|0/angbracketright+| 1/angbracketright), H|1/angbracketright=1√
2(|0/angbracketright−| 1/angbracketright), (1.45)
describes no meaningful transformation of Cbits. Nevertheless, when
combined with other operations, as on the right side of (1.44), theHadamard operations result in the perfectly sensible operation givenon the left side. In a quantum computer the action of
Hon 1-Qbit
states turns out to be not only meaningful but also easily implemented,and the possibility of interchanging control and target Qbits using only1-Qbit operators in the manner shown in (1.44) turns out to have somestriking consequences.
The use of Hadamards to interchange the control and target Qbits of
a cNOT operation is sufﬁciently important in quantum computationto merit a second derivation of (1.44), which further illustrates theway in which one uses the operator formalism. In strict analogy to thedeﬁnition of cNOT (see (1.21) and the preceding paragraph) we candeﬁne a controlled- Zoperation,
CZ
ij, which leaves the state of the target
Cbit junchanged if the state of the control Cbit iis|0/angbracketright, and operates
on the target Cbit with Zif the state of the control Cbit is |1/angbracketright.A sa
result CZ
10|xy/angbracketrightacts as the identity on |xy/angbracketrightunless both xand yare 1, in
which case it simply takes |11/angbracketrightinto−|11/angbracketright. This behavior is completely
symmetric in the two Cbits, so
CZ
ij=CZ
ji. (1.46)
It is a straightforward consequence of (1.42) and (1.43) that sand-
wiching the target Cbit of a cNOT between Hadamards converts

<<<PAGE 32>>>

1.4 MANIPULATING OPERATIONS ON CBITS 1 5
it to a CZ:
HjCijHj=CZ
ij, HiCjiHi=CZ
ji. (1.47)
In view of (1.46), we then have
HjCijHj=HiCjiHi, (1.48)
which is equivalent to (1.44), since H2=1.
As a ﬁnal exercise in treating operations on Cbits as linear operations
on vectors, we construct an alternative form for the swap operator. If
we use (1.39) to reexpress each nand˜nappearing in the swap operator
(1.35) in terms of Z, we ﬁnd that
Sij=1
2(1+ZiZj)+1
2(XiXj)(1−ZiZj). (1.49)
If we deﬁne
Y=iXZ=/parenleftbigg0−i
i 0/parenrightbigg
(i=√
−1), (1.50)
we get the more compact form
Sij=1
2(1+XiXj+YiYj+ZiZj). (1.51)
For three quarters of a century physicists have enjoyed grouping the
matrix representations of the three operators X,Y,and Zinto a “3-
vector”−→σwhose “components” are 2 ⊗2 matrices:
σx=/parenleftbigg01
10/parenrightbigg
,σy=/parenleftbigg0−i
i 0/parenrightbigg
,σz=/parenleftbigg10
0−1/parenrightbigg
.
(1.52)
The swap operator then becomes3
Sij=1
2/parenleftbig
1+−→σ(i)·−→σ(j)/parenrightbig
, (1.53)
where “ ·” represents the ordinary three-dimensional scalar product:
−→σ(i)·−→σ(j)=σ(i)
xσ(j)
x+σ(i)
yσ(j)
y+σ(i)
zσ(j)
z. (1.54)
The three components of−→σhave many properties that are un-
changed under cyclic permutations of x,y,and z. All three are
Hermitian.4All square to unity,
σ2
x=σ2
y=σ2
z=1. (1.55)
3 Physicists might enjoy the simplicity of this “computational” derivation of
the form of the exchange operator, compared with the conventionalquantum-mechanical derivation, which invokes the full apparatus ofangular-momentum theory.
4 The elements of a Hermitian matrix Asatisfy A
ji=A∗
ij, where∗denotes
complex conjugation. A fuller statement in a broader context can be found inAppendix A.

<<<PAGE 33>>>

1 6 CBITS AND QBITS
They all anticommute in pairs and the product of any two of them is
simply related to the third:
σxσy=−σyσx=iσz,
σyσz=−σzσy=iσx, (1.56)
σzσx=−σxσz=iσy.
The three relations (1.56) differ only by cyclic permutations of x,y,
and z.
All the relations in (1.55) and (1.56) can be summarized in a single
compact and useful identity. Let−→aand−→bbe two 3-vectors with
components ax,ay,azand bx,by,bzthat are ordinary real numbers.
(They can also be complex numbers, but in most useful applicationsthey are real.) Then one easily conﬁrms that all the relations in (1.55)and (1.56) imply and are implied by the single identity
(−→a·−→σ)(−→b·−→σ)=(−→a·−→b)
1+i(−→a×−→b)·−→σ, (1.57)
where−→a×−→bdenotes the vector product (or “cross product”) of−→a
and−→b,
(−→a×−→b)x=aybz−azby,
(−→a×−→b)y=azbx−axbz, (1.58)
(−→a×−→b)z=axby−aybx.
Together with the unit matrix 1, the matrices σx,σy, andσzform
a basis for the four-dimensional algebra of two-dimensional matricesof complex numbers: any such matrix is a unique linear combination ofthese four with complex coefﬁcients. Because the four are all Hermitian,any two-dimensional Hermitian matrix Aof complex numbers must
be a reallinear combination of the four, and therefore of the form
A=a
01+−→a·−→σ, (1.59)
where a0and the components of the 3-vector−→aare all real numbers.
The matrices σx,σy, andσzwere introduced in the early days of
quantum mechanics by Wolfgang Pauli, to describe the angular mo-mentum associated with the spin of an electron. They have many otheruseful purposes, being simply related to the quaternions invented byHamilton to deal efﬁciently with the composition of three-dimensionalrotations.
5It is pleasing to ﬁnd them here, buried in the interior of the
operator that simply swaps two classical bits. We shall have extensiveoccasion to use Pauli’s 1-Qbit operators when we come to the subject of
5 Hamilton’s quaternions i,j,kare represented by iσx,iσy,iσz.The
beautiful and useful connection between Pauli matrices andthree-dimensional rotations discovered by Hamilton is developed inAppendix B.

<<<PAGE 34>>>

1.5 QBITS AND THEIR STATES 1 7
quantum error correction. Some of their properties, developed further
in Appendix B, prove to be quite useful in treating Qbits, to which wenow turn.
1.5 Qbits and their states
The state of a Cbit is a pretty miserable specimen of a two-dimensionalvector. The only vectors with any classical meaning in the whole two-dimensional vector space are the two orthonormal vectors |0/angbracketrightand|1/angbracketright,
since those are the only two states a Cbit can have. Happily, nature hasprovided us with physical systems, Qbits, described by states that donot suffer from this limitation. The state |ψ/angbracketrightassociated with a Qbit
can be any unit vector in the two-dimensional vector space spanned by|0/angbracketrightand|1/angbracketrightover the complex numbers. The general state of a Qbit is
|ψ/angbracketright=α
0|0/angbracketright+α1|1/angbracketright=/parenleftbiggα0
α1/parenrightbigg
, (1.60)
where α0andα1are two complex numbers constrained only by the
requirement that |ψ/angbracketright, like|0/angbracketrightand|1/angbracketright, should be a unit vector in the
complex vector space – i.e. only by the normalization condition
|α0|2+|α1|2=1. (1.61)
The state |ψ/angbracketrightis said to be a superposition of the states |0/angbracketrightand|1/angbracketrightwith
amplitudes α0andα1.I fo n eo f α0andα1is 0 and the other i s 1 – i.e.
the special case in which the state of the Qbit is one of the two classicalstates|0/angbracketrightor|1/angbracketright– it can be convenient to retain the language appropriate
to Cbits, speaking of the Qbit “having the value” 0 or 1. More correctly,however, one is entitled to say only that the state of the Qbit is |0/angbracketrightor
|1/angbracketright. Qbits, in contrast to Cbits, cannot be said to “have values.” They
have – or, more correctly, are described by , or, better still, are associated
with – states. We shall often sacriﬁce correctness for ease of expression.
Some reasons for this apparently pedantic terminological hair splittingwill emerge below.
Just as the general state of a single Qbit is any normalized superpo-
sition (1.60) of the two possible classical states, the general state |/Psi1/angbracketright
that nature allows us to associate with two Qbits is any normalizedsuperposition of the four orthogonal classical states,
|/Psi1/angbracketright=α
00|00/angbracketright+α01|01/angbracketright+α10|10/angbracketright+α11|11/angbracketright=⎛
⎜⎝α00
α01
α10
α11⎞
⎟⎠,(1.62)
with the complex amplitudes being constrained only by the normal-
ization condition
|α00|2+|α01|2+|α10|2+|α11|2=1. (1.63)

<<<PAGE 35>>>

1 8 CBITS AND QBITS
This generalizes in the obvious way to nQbits, whose general state can
be any superposition of the 2ndifferent classical states, with amplitudes
whose squared magnitudes sum to unity:
|/Psi1/angbracketright=/summationdisplay
0≤x<2nαx|x/angbracketrightn, (1.64)
/summationdisplay
0≤x<2n|αx|2=1. (1.65)
In the context of quantum computation, the set of 2nclassical states –
all the possible tensor products of nindividual Qbit states |0/angbracketrightand|1/angbracketright–
is called the computational basis. For most purposes classical basis is a
more appropriate term. I shall use the two interchangeably. The statesthat characterize nCbits – the classical-basis states – are an extremely
limited subset of the states of nQbits, which can be any (normalized)
superposition with complex coefﬁcients of these classical-basis states.
If we have two Qbits, one in the state |ψ/angbracketright=α
0|0/angbracketright+α1|1/angbracketrightand the
other in the state |φ/angbracketright=β0|0/angbracketright+β1|1/angbracketright, then the state |/Psi1/angbracketrightof the pair,
in a straightforward generalization of the rule for multi-Cbit states, istaken to be the tensor product of the individual states,
|/Psi1/angbracketright=|ψ/angbracketright⊗|φ/angbracketright=/parenleftbig
α
0|0/angbracketright+α1|1/angbracketright/parenrightbig
⊗/parenleftbig
β0|0/angbracketright+β1|1/angbracketright/parenrightbig
=α0β0|00/angbracketright+α0β1|01/angbracketright+α1β0|10/angbracketright+α1β1|11/angbracketright
=⎛
⎜⎝α0β0
α0β1
α1β0
α1β1⎞
⎟⎠. (1.66)
Note that a general 2-Qbit state (1.62) is of the special form (1.66) if
and only if α00α11=α01α10.Since the four amplitudes in (1.62) are
constrained only by the normalization condition (1.63), this relationneed not hold, and the general 2-Qbit state, unlike the general stateof two Cbits, is nota product (1.66) of two 1-Qbit states. The same is
true for states of nQbits. Unlike Cbits, whose general state can only
be one of the 2
nproducts of |0/angbracketrights and|1/angbracketrights, a general state of nQbits
is a superposition of these 2nproduct states and cannot, in general,
be expressed as a product of any set of 1-Qbit states. Individual Qbitsmaking up a multi-Qbit system, in contrast to individual Cbits, cannotalways be characterized as having individual states of their own.
6
Such nonproduct states of two or more Qbits are called entangled
states. The term is a translation of Schr ¨odinger’s verschr¨ ankt, which I
6 More precisely, they do not always have what are called pure states of their
own. It is often convenient to give a statistical description of an individualQbit (or a group of Qbits) in terms of what is called a density matrix ormixed
state. If one wishes to emphasize that one is not talking about a mixed state,
one uses the term “pure state.” In this book the term “state” always means“pure state.”

<<<PAGE 36>>>

1.6 REVERSIBLE OPERATIONS ON QBITS 1 9
am told is rendered more accurately as “entwined” or “enfolded.” But
Schr ¨odinger himself used the English word “entangled,” and may even
have used it before coining the German term. When the state of severalQbits is entangled, they can sometimes behave in some very strangeways. An example of such peculiar behavior is discussed in AppendixD. Aside from its intrinsic interest, the appendix provides some furtherexercise in the analytical manipulation of Qbits.
1.6 Reversible operations on Qbits
The only nontrivial reversible operation a classical computer can per-form on a single Cbit is the NOT operation
X. Nature has been far
more versatile in what it allows us to do to a Qbit. The reversibleoperations that a quantum computer can perform upon a single Qbitare represented by the action on the state of the Qbit of any linear
transformation that takes unit vectors into unit vectors. Such transfor-mations
uare called unitary and satisfy the condition7
uu†=u†u=1. (1.67)
Since any unitary transformation has a unitary inverse, such actions of a
quantum computer on a Qbit are reversible. The reason why reversibil-ity is crucial for the effective functioning of a quantum computer willemerge in Chapter 2.
The most general reversible n-Cbit operation in a classical com-
puter is a permutation of the (2
n)! different classical-basis states. The
most general reversible operation that a quantum computer can per-form upon nQbits is represented by the action on their state of any
linear transformation that takes unit vectors into unit vectors – i.e. any2
n-dimensional unitary transformation U, satisfying
UU†=U†U=1. (1.68)
Any reversible operation on nCbits – i.e. any permutation Pof the
2nCbit states – can be associated with a unitary operation UonnQbits.
One deﬁnes the action of Uon the classical-basis states of the Qbit to
be identical to the operation of Pon the corresponding classical states
of the Cbit. Since the classical basis isa basis, Ucan be extended to
arbitrary n-Qbit states by requiring it to be linear. Since the action
ofUon the classical-basis states is to permute them, its effect on any
superposition of such states/summationtextαx|x/angbracketrightnis to permute the amplitudes
αx. Such a permutation preserves the value of/summationtext|αx|2,s o Utakes
unit vectors into unit vectors. Being norm-preserving and linear, Uis
indeed unitary.
7 These and other facts about linear operators on vector spaces over the
complex numbers are also reviewed and summarized in Appendix A.

<<<PAGE 37>>>

2 0 CBITS AND QBITS
Many important unitary operations on Qbits that we shall be exam-
ining below are deﬁned in this way, as permutations of the classical-basisstates, which are implicitly understood to be extended by linearity toall Qbit states. In particular, the transformations NOT , SWAP , andcNOT on Cbits are immediately deﬁned in this way for Qbits as well.But the available unitary transformations on Qbits are, of course, muchmore general than straightforward extensions of classical operations.We have already encountered two such examples, the operator
Zand
the Hadamard transformation H. Both of these take the classical-basis
states of a Qbit into another orthonormal basis, so their linear exten-sions to all Qbit states are necessarily unitary.
In designing quantum algorithms, the class of allowed unitary trans-
formations is almost always restricted to ones that can be built entirelyout of products of unitary transformations that act on only one Qbitat a time, called 1-Qbit gates , or that act on just a pair of Qbits, called
2-Qbit gates . This restriction is imposed because the technical problems
of making higher-order quantum gates are even more formidable thanthe (already difﬁcult) problems of constructing reliable 1- and 2-Qbitgates.
It turns out that this is not a fundamental limitation, since arbitrary
unitary transformations can be approximated to an arbitrary degreeof precision by sufﬁciently many 1- and 2-Qbit gates. We shall notprove this general result,
8because all of the quantum algorithms to
be developed here will be explicitly built up entirely out of 1- and2-Qbit gates. One very important illustration of the sufﬁciency of 1-and 2-Qbit gates will emerge in Chapter 2. For a reversible classicalcomputer, it can be shown that at least one 3-Cbit gate is needed tobuild up general logical operations. But, in a quantum computer, weshall ﬁnd, remarkably – and importantly for the feasibility of practicalquantum computation – that the quantum extension of this 3-Cbit gatecan be constructed out of a small number of 1- and 2-Qbit gates.
While unitarity is generally taken to be the hallmark of the transfor-
mations nature allows us to perform on quantum states, what is reallyremarkable about the transformations of Qbit states is their linearity
(which is, of course, one aspect of their unitarity). It is easy to dreamup simple classical models for a Qbit, particularly if one restricts itsstates to real linear combinations of the two computational basis states.It is not hard to invent classical models for NOT and Hadamard 1-Qbit gates that act linearly on all the 1-Qbit states of the model Qbit.But I know of no classical model that can extend a cNOT on thefour computational basis states of two Cbits to an operation that acts
8 The argument is given by David P . DiVincenzo, “Two-bit gates are universal
for quantum computation,” Physical Review A51, 1015–1022 (1995),
http://arxiv.org/abs/quant-ph/9407022 .

<<<PAGE 38>>>

1.7 CIRCUIT DIAGRAMS 2 1
y uy u
Fig 1.1 A circuit diagram representing the action on a single Qbit of
the 1-Qbit gate u. Initially the Qbit is described by the input state |ψ/angbracketright
on the left. The thin line (wire) represents the subsequent history ofthe Qbit. After emerging from the box representing
u, the Qbit is
described on the right by the ﬁnal state u|ψ/angbracketright.
Ψ U ΨU
Fig 1.2 A circuit diagram representing the action on nQbits of the
n-Qbit gate U. Initially the Qbits ares described by the input state |/Psi1/angbracketright
on the left. The thick line (bar) represents the subsequent history ofthe Qbits. After emerging from the box representing
U, the Qbits are
described on the right by the ﬁnal state U|/Psi1/angbracketright.
linearly on all the states of two model Qbits. It is a remarkable and
highly nontrivial fact about the physical world that nature does allowus, with much ingenuity and hard work, to fabricate unitary cNOTgates for a pair of genuine quantum Qbits.
1.7 Circuit diagrams
It is the practice in quantum computer science to represent the actionof a sequence of gates acting on nQbits by a circuit diagram. The initial
state of the Qbits appears on the left, the ﬁnal state on the right, and thegates themselves in the central part of the ﬁgure. Figure 1.1 shows thesimplest possible such diagram: a Qbit initially in the state |ψ/angbracketrightis acted
on by a 1-Qbit gate
u, with the result that the Qbit is assigned the new
state u|ψ/angbracketright. Figure 1.2 shows the analogous diagram for an n-Qbit gate
Uand an n-Qbit initial state |/Psi1/angbracketright. The line that goes into and out of the
box representing the unitary transformation – which becomes usefulwhen one starts chaining together a sequence of gates – is sometimescalled a wire in the case of a single Qbit, and the thicker line (which
represents nwires) associated with an n-Qbit gate is sometimes called
abar.
Figure 1.3 reveals a peculiar feature of these circuit diagrams that it is
important to be aware of. The diagrams are read from left to right (as onereads ordinary prose in European languages). Part (a) portrays a circuitthat acts ﬁrst with
Vand then with Uon the initial state |/Psi1/angbracketright. The result
is the state UV|/Psi1/angbracketright, because it is the convention, in writing equations
for linear operators on vector spaces, that the operation appears to the

<<<PAGE 39>>>

2 2 CBITS AND QBITS
Ψ UV Ψ
UV UV =UV
(b)(a)Fig 1.3 (a) A circuit
diagram representing theaction on nQbits of two
n-Qbit gates. Initially the
Qbits are described by theinput state |/Psi1/angbracketrighton the left.
They are acted upon ﬁrstby the gate
Vand then by
the gate U, emerging on
the right in the ﬁnal state
UV|/Psi1/angbracketright. Note that the
order in which the Qbits
encounter unitary gates inthe ﬁgure is opposite to the
order in which thecorresponding symbols arewritten in the symbol forthe ﬁnal state on the right.
(b) This emphasizes theunfortunate conventionthat, because gates on theleft act before gates on the
right in a circuit diagram, acircuit showing
Von the
left and Uon the right
represents the operationconventionally denoted by
UV.leftof the state on which it acts. Thus the sequence of symbols |/Psi1/angbracketright,
V, and Uon the left of the circuit diagram in (a) is reversed from the
sequence in which they appear in the mathematical representation of
the state that is produced on the right. Part (b) shows the consequences
of this for the part of the circuit diagram containing just the gates: a
diagram in which a gate V(on the left) is followed by a gate Uon the
right describes the unitary transformation UV.
One should be wary of the possibility for confusion arising from
the fact that operators (and states) in circuit diagrams always appearin the diagrams in the opposite sequence from the order in whichthey appear on the page in the corresponding equations. While sev-eral of the most important diagrams we shall encounter are left–rightsymmetric, many are not, so one should be on guard against gettingthings backwards when translating equations into circuit diagrams andvice versa.
In lecturing on quantum computation I tried for several years to
reverse the computer-science convention, putting the initial state onthe right of the circuit diagram and letting the gates on the right actﬁrst. This has the great advantage of making the diagram look likethe equation it represents. It has, however, a major disadvantage, evensetting aside the fact that it ﬂies in the face of well established conven-tion. It requires one to write on the blackboard in the wrong direction,from right to left, whenever one wishes to produce a circuit diagram.Guessing how far to the right one should start is hard to do if the di-agram is a lengthy one, and for this reason I gave up after a few yearsand reverted to the conventional form. A better alternative would befor physicists to start writing their equations with the states on the left(represented by bra vectors rather than ket vectors
9) and with linear
operators appearing to the right of the states on which they act. Butthis would require abandoning a tradition that goes back three quartersof a century. So we are stuck with a clash of cultures, and must simplykeep in mind that confusion can arise if one forgets the elementary factrepresented in Figure 1.3(b).
There is little utility to circuit diagrams of the simple form in
Figures 1.1–1.3, but they are important as building blocks out of which
9 See Appendix A for the distinction between bras and kets.

<<<PAGE 40>>>

1.8 MEASUREMENT GATES AND THE BORN RULE 2 3
larger circuit diagrams are constructed. As the number of operations
increases, the diagrams enable one to see at a glance the action of asequence of 1- and 2-Qbit unitary gates on a collection of many Qbitsin a way that is far more transparent and much more easily remem-bered than the corresponding formulae. Indeed, many calculations thatinvolve rather lengthy equations can be simply accomplished by ma-nipulating circuit diagrams, as we shall see.
When the state vectors entering or leaving a wire or bar in a circuit
diagram are computational-basis states like |x/angbracketright, one sometimes omits
the symbol |/angbracketrightand simply writes x.
1.8 Measurement gates and the Born rule
To give the state of a single Cbit you need only one bit of information:
whether the state of the Cbit is |0/angbracketrightor|1/angbracketright. But to specify the state
(1.60) of a single Qbit to an arbitrarily high degree of precision, youneed arbitrarily many bits of information, since you must specify twocomplex numbers αandβsubject only to the normalization constraint
(1.61). Because Qbits not only have a much richer set of states than
Cbits, but also can be acted on by a correspondingly richer set of
transformations, it might appear obvious that a quantum computerwould be vastly more powerful than a classical computer. But there is a
major catch!
The catch is this: if you have nCbits, each representing either 0 or
1, you can ﬁnd out the state of each just by looking. There is nothingproblematic about learning the state of a Cbit, and hence learning theresult of any calculation you may have built up out of operations on thoseCbits. Furthermore – and this is taken for granted in any discussion ofa classical computer – the state of Cbits is not altered by the processof reading them. The act of acquiring the information from Cbits isnot disruptive. You can read the Cbits at any stage of a computationwithout messing up subsequent stages.
In stark contrast, if you have nQbits in a superposition (1.64) of
computational basis states, there is nothing whatever you can do to themto extract from those Qbits the vast amount of information contained inthe amplitudes α
x. You cannot read out the values of those amplitudes,
and therefore you cannot ﬁnd out what the state is. The state of nQbits
is not associated with any ascertainable property of those Qbits, as it isfor Cbits.
There is only one way to extract information from nQbits in a
given state. It is called making a measurement .
10Making a measurement
10 Physicists will note – others need pay no attention to this remark – that
what follows is more accurately characterized as “making a (von Neumann)measurement in the computational (classical) basis.” There are other ways

<<<PAGE 41>>>

2 4 CBITS AND QBITS
consists of performing a certain test on each Qbit, the outcome of which
is either 0 or 1. The particular collection of zeros and ones produced bythe test is not in general determined by the state |/Psi1/angbracketrightof the Qbits; the
state determines only the probability of the possible outcomes, according
to the following rule: the probability of getting a particular result – say01100, if you have ﬁve Qbits – is given by the squared magnitude of theamplitude of the state |01100/angbracketrightin the expansion of the state |/Psi1/angbracketrightof the
Qbits in the 2
5computational basis states. More generally, if the state
ofnQbits is
|/Psi1/angbracketrightn=/summationdisplay
0≤x<2nαx|x/angbracketrightn, (1.69)
then the probability that the zeros and ones resulting from measure-
ments of all the Qbits will give the binary expansion of the integer xis
p(x)=|αx|2. (1.70)
This basic rule for how information can be extracted from a quan-
tum state was ﬁrst enunciated by Max Born, and is known as the Born
rule. It provides the link between amplitudes and the numbers you can
actually read out when you test – i.e. measure – the Qbits. The squaredmagnitudes of the amplitudes give the probabilities of outcomes ofmeasurements. Normalization conditions like (1.65) are just the re-quirements that the probabilities for all of the 2
nmutually exclusive
outcomes add up to 1.
The process of measurement is carried out by a piece of hardware
with a digital display, known as an n-Qbit measurement gate . Such an
n-Qbit measurement gate is depicted schematically in Figure 1.4. In
contrast to unitary gates, which have a unique output state for eachinput state, the state of the Qbits emerging from a measurement gate isonly statistically determined by the state of the input Qbits. In further
contrast to unitary gates, the action of a measurement gate cannot beundone: given the ﬁnal state |x/angbracketright, there is no way of reconstructing the
initial state |/Psi1/angbracketright. Measurement is irreversible. Nor is the action of a
measurement gate in any sense linear.
To the extent that it suggests that some preexisting property is being
revealed, “measurement” is a dangerously misleading term, but it is
to make such a measurement, but they can all be reduced to measurements
in the computational basis if an appropriate unitary transformation is
applied to the n-Qbit state of the computer just before carrying out the
measurement. In this book the term “measurement” always meansmeasurement in the computational basis. Measurements in other bases willalways be treated as measurements in the computational basis preceded bysuitable unitary transformations. There are also more general forms ofmeasurement than von Neumann measurements, going under theunpleasant acronym POVM (for “positive operator-valued measure”). We
shall make no explicit use of POVMs.

<<<PAGE 42>>>

1.8 MEASUREMENT GATES AND THE BORN RULE 2 5
Ψ n Mn n x n xx p2ax =x
=Σa
Fig 1.4 A circuit diagram representing an n-Qbit measurement gate.
The Qbits are initially described by the n-Qbit state
|/Psi1/angbracketrightn=/summationdisplay
0≤x<2nαx|x/angbracketrightn,
on the left. After the measurement gate Mnhas acted, with probability
p=|αx|2it indicates an integer x,0≤x<2n,and the Qbits are
subsequently described by the state |xn/angbracketrighton the right.
hallowed by three quarters of a century of use by quantum physicists,
and impossible to avoid in treatments of quantum computation. Oneshould avoid being misled by such spurious connotations of “measure-ment,” though it confused many physicists in the early days of quantummechanics and may well continue to confuse some to this day. In quan-tum computation “measurement” means nothing more or less thanapplying and reading the display of an appropriate measurement gate,whose action is fully speciﬁed by the Born rule, as described above,and expanded upon below. While measurement in quantum mechan-ics is not at all like measuring somebody’s weight, it does have someresemblance to measuring Alice’s IQ , which, one can argue, reveals nopreexisting numerical property of Alice, but only what happens whenshe is subjected to an IQ test.
The simplest statement of the Born rule is for a single Qbit. If the
state of the Qbit is the superposition (1.60) of the states |0/angbracketrightand|1/angbracketright
with amplitudes α
0andα1then the result of the measurement is 0 with
probability |α0|2and 1 with probability |α1|2. This measurement is
carried out by a 1-Qbit measurement gate, as illustrated in Figure 1.5.We shall see below that n-Qbit measurement gates can be realized by
applying 1-Qbit measurement gates to each of the nQbits. The process
of measurement can thus be reduced to applying multiple copies of asingle elementary piece of hardware: the 1-Qbit measurement gate.
In addition to displaying an n-bit integer with probabilities deter-
mined by the amplitudes, there is a second very important aspect of theaction of measurement gates: if nQbits, initially described by a state
|/Psi1/angbracketright, are sent through an n-Qbit measurement gate, and the display of
the measurement gate indicates the integer x, then one must associate
with the Qbits emerging from that measurement gate the classical-basisstate|x/angbracketright
n, as shown in Figures 1.4 and 1.5. This means that all traces
of the amplitudes αxcharacterizing the input state have vanished from
the output state. The only role they have played in the measurement isto determine the probability of a particular output.

<<<PAGE 43>>>

2 6 CBITS AND QBITS
x
y M 0a 1a1+ =0 x p = ax2Fig 1.5 A special case of
Figure 1.4: a 1-Qbitmeasurement gate. Thereading xof the gate is
either 0 or 1.
If the state of the input Qbits is one of the classical-basis states |x/angbracketrightn,
then according to the Born rule the probability that the measurementgate will read xand the output state will remain |x/angbracketright
nis 1. But for
superpositions (1.69) with more than a single nonzero amplitude αx, the
output state is not determined. Being a single one of the classical basisstates |x/angbracketright
n, the output state no longer carries any information about
the amplitudes characterizing the initial state, other than certifying thatthe particular amplitude α
xwas not zero, and, in all likelihood, was not
exceedingly small.
So once you send nQbits through an n-Qbit measurement gate,
you remove the possibility of extracting any further information abouttheir original state |/Psi1/angbracketright. After such a measurement of ﬁve Qbits, if the
result is 01100, then the post-measurement state associated with theQbits is no longer |/Psi1/angbracketright,b u t|01100/angbracketright. The original state |/Psi1/angbracketright, with all
the rich information potentially available in its amplitudes, is irretriev-ably lost. Qbits emerging from a measurement gate that indicates theoutcome xare characterized by the state |x/angbracketright, regardless of what their
pre-measurement state may have been.
This change of state attendant upon a measurement is often re-
ferred to as a reduction orcollapse of the state. One says that the pre-
measurement state reduces orcollapses to the post-measurement state, as
a consequence of the measurement. This should not be taken to imply(though, alas, it often is) that the Qbits themselves suffer a catastrophic“reduction” or “collapse.” It is important to keep in mind, in this con-text, that the state of nQbits is nothing more than an abstract symbol,
used, via the Born rule, to calculate probabilities of measurement out-comes. As has already been noted, there is no internal property of theQbits that corresponds to their state.
You might well wonder how one can learn anything at all of com-
putational interest under these wretched conditions. The artistry ofquantum computation consists of producing, through a cunningly con-structed unitary transformation, a superposition in which most of theamplitudes α
xare zero or extremely close to zero, with useful infor-
mation being carried by anyof the values of xthat have an appreciable
probability of being indicated by the measurement. It is thus importantto be seeking information that, once possessed, can easily be conﬁrmed,perhaps with an ordinary (classical) computer (e.g. the factors of a largenumber), so that one is not misled by rare and irrelevant low-probabilityoutcomes. How this is actually accomplished in various cases of interestwill be one of our major preoccupations.
It is important to note and immediately reject a possible misun-
derstanding of the Born rule. One might be tempted to infer from

<<<PAGE 44>>>

1.8 MEASUREMENT GATES AND THE BORN RULE 2 7
the rule that for a Qbit to be in a superposition, such as the state
|ψ/angbracketright=α0|0/angbracketright+α1|1/angbracketright, means nothing more than that the “actual state”
of the Qbit is either |0/angbracketrightwith probability |α0|2or|1/angbracketrightwith probability
|α1|2. Such an assertion goes beyond the rule, of course, which merely
asserts that if one subjects a Qbit in the state |ψ/angbracketrightto an appropriate
test – a measurement – then the outcome of the test will be 0 or 1
with those probabilities and the post-measurement state of the Qbitcan correspondingly be taken to be |0/angbracketrightor|1/angbracketright. This does not imply that
prior to the test the Qbit already carried the value revealed by the testand was already described by the corresponding classical-basis state,since, among other possibilities, the action of the test itself might wellplay a role in bringing forth the outcome.
In fact, it is easy to produce examples that demonstrate that the Qbit,
prior to the test, could not have been in either of the states |0/angbracketrightand|1/angbracketright.
We can see this with the help of the Hadamard transformation (1.41).We have deﬁned the action of the 1-Qbit operators
H,X, and Zonly
on the computational-basis states |0/angbracketrightand|1/angbracketright, but, as noted above, we
can extend their action to arbitrary linear combinations of these statesby requiring the extensions to be linear operators. Since the states |0/angbracketright
and|1/angbracketrightform a basis, this determines the action of
H,X, and Zon any
1-Qbit state.
Because it is linear and norm-preserving, His unitary, and is there-
fore the kind of operation a quantum computer can apply to the stateof a Qbit: a 1-Qbit gate. The result of the operation of a Hadamardgate is to change the state |φ/angbracketrightof a Qbit to
H|φ/angbracketright.Suppose, now, that we
apply Hto a Qbit that is initially in the state
|φ/angbracketright=1√
2(|0/angbracketright+| 1/angbracketright). (1.71)
It follows from (1.45) that the result is just
H|φ/angbracketright=| 0/angbracketright. (1.72)
So according to the Born rule, if we measure a Qbit described by the
state H|φ/angbracketright, the result will be 0 with probability 1.
But suppose that a Qbit in the state |φ/angbracketrightwere indeed either in the state
|0/angbracketrightwith probability1
2or in the state |1/angbracketrightwith probability1
2. In either
case, according to (1.45), the subsequent action of Hwould produce
a state – either (1 /√
2)(|0/angbracketright+| 1/angbracketright)o r( 1 /√
2)(|0/angbracketright−| 1/angbracketright) – that under
measurement yielded 0 or 1 with equal probability. This contradictsthe fact just extracted directly from (1.72) that the result of making ameasurement on a Qbit in the state
H|φ/angbracketrightis invariably 0.
So a Qbit in a quantum superposition of |0/angbracketrightand|1/angbracketrightcannot be viewed
as being either in the state |0/angbracketrightor in the state |1/angbracketrightwith certain probabilities.
Such a state represents something quite different. Although the Qbitreveals only a 0 or a 1 when you query it with a measurement gate,

<<<PAGE 45>>>

2 8 CBITS AND QBITS
prior to the query its state is not in general either |0/angbracketrightor|1/angbracketright, but a
superposition of the form (1.60). Such a superposition is as naturaland irreducible a description of a Qbit as |0/angbracketrightand|1/angbracketrightare. This point is
expanded on in Appendix C.
If the states of nQbits are restricted to computational-basis states
then the process of measurement is just like the classical process of
“learning the value” of xwithout altering the state. Thus a quantum
computer can be made to simulate a reversible classical computer byallowing only computational-basis states as input, and using only uni-tary gates that take computational-basis states into computational-basisstates.
The Born rule, relating the amplitudes α
xin the expansion (1.64)
of a general n-Qbit state |/Psi1/angbracketrightto the probabilities of measuring x,
is often stated in terms of inner products or projection operators.11
The probability of a measurement giving the result x(0≤x<2n)
is
p/Psi1(x)=|αx|2=| /angbracketleft x|/Psi1/angbracketright|2. (1.73)
It can also be usefully expressed in terms of projection operators:
p/Psi1(x)=/angbracketleft x|/Psi1/angbracketright/angbracketleft/Psi1|x/angbracketright=/angbracketleft x|P/Psi1|x/angbracketright (1.74)
or
p/Psi1(x)=/angbracketleft/Psi1|x/angbracketright/angbracketleftx|/Psi1/angbracketright=/angbracketleft/Psi1|Px|/Psi1/angbracketright, (1.75)
where P/Psi1=|/Psi1/angbracketright/angbracketleft/Psi1|is the projection operator on the state |/Psi1/angbracketright, and
Px=| x/angbracketright/angbracketleftx|is the projection operator on the state |x/angbracketright.
1.9 The generalized Born rule
There is a stronger version of the Born rule, which plays an important
role in quantum computation, even though, surprisingly, it is rarelyexplicitly mentioned in most standard quantum-mechanics texts. Weshall call it the generalized Born rule. This stronger form applies when
one measures only a single one of n+1 Qbits, by sending it through a
standard 1-Qbit measurement gate.
To formulate the generalized Born rule, note that any state of all
n+1 Qbits can be represented in the form
|/Psi1/angbracketright
n+1=α0|0/angbracketright|/Phi10/angbracketrightn+α1|1/angbracketright|/Phi11/angbracketrightn, |α0|2+|α1|2=1,(1.76)
11 The Dirac notation for inner products and projection operators is
described in Appendix A.

<<<PAGE 46>>>

1.9 THE GENERALIZED BORN RULE 2 9
Mx
Ψ
Φxx2=0
1 +10a
aΦ
Φ10p =x
aFig 1.6 The action of a
1-Qbit measurement gateon a single one of n+1
Qbits, according to thegeneralized Born rule. Theinitial state (on the left) is a
general ( n+1)-Qbit state,
expressed in the form|/Psi1/angbracketright
n+1=a0|0/angbracketright|/Phi10/angbracketrightn+
a1|1/angbracketright|/Phi11/angbracketrightn. Only the single
Qbit on the left of thisexpression is subjected to ameasurement gate.where |/Phi10/angbracketrightnand|/Phi11/angbracketrightnare normalized (but not necessarily orthogonal).
This follows directly from the general form,
|/Psi1/angbracketrightn+1=2n+1−1/summationdisplay
x=0γ(x)|x/angbracketrightn+1,2n+1−1/summationdisplay
x=0|γ(x)|2=1. (1.77)
The states |/Phi10/angbracketrightnand|/Phi11/angbracketrightnare given by
|/Phi10/angbracketrightn=(1/α0)2n−1/summationdisplay
x=0γ(x)|x/angbracketrightn,|/Phi11/angbracketrightn=(1/α1)2n−1/summationdisplay
x=0γ(2n+x)|x/angbracketrightn,
(1.78)
where
α2
0=2n−1/summationdisplay
x=0|γ(x)|2,α2
1=2n−1/summationdisplay
x=0|γ(2n+x)|2. (1.79)
(Theα0andα1in (1.78) and (1.79) are real numbers, but can be mul-
tiplied by arbitrary phase factors if |/Phi10/angbracketrightnand|/Phi11/angbracketrightnare multiplied by
the inverse phase factors.)
The generalized Born rule asserts that if one measures only the single
Qbit whose state symbol is explicitly separated out from the others inthe ( n+1)-Qbit state (1.76), then the 1-Qbit measurement gate will
indicate x(0 or 1) with probability |α
x|2, after which the ( n+1)-Qbit
state can be taken to be the product state |x/angbracketright|/Phi1x/angbracketrightn. (The rule holds for
the measurement of any single Qbit – there is nothing special about theQbit whose state symbol appears on the left in the ( n+1)-Qbit state
symbol.) This action of a 1-Qbit measurement gate on an ( n+1)-Qbit
state is depicted schematically in Figure 1.6.
If the Qbit on which the 1-Qbit gate acts is initially unentangled with
the remaining nQbits, then the action of the gate on the measured Qbit
is just that speciﬁed by the ordinary Born rule, and the unmeasuredQbits play no role at all, remaining in their original state throughout theprocess. This is evident from the above statement of the generalizedBorn rule, specialized to the case in which the two states |/Phi1
0/angbracketrightnand
|/Phi11/angbracketrightnare identical. It is illustrated in Figure 1.7.
If one applies the generalized Born rule ntimes to successive
1-Qbit measurements of each of nQbits, initially in the general
n-Qbit state (1.69), one can show by a straightforward argument, given
in Appendix E, that the ﬁnal state of the nQbits is xwith probability
|αx|2, where xis the n-bit integer whose bits are given by the readings

<<<PAGE 47>>>

3 0 CBITS AND QBITS
x
Φ Φyx2M 0011+ a p= a= a xFig 1.7 A simpliﬁcation of
Figure 1.6 when|/Phi1
0/angbracketright=|/Phi11/angbracketright=|/Phi1/angbracketright. In this
case the initial state on theleft is just the product state|/Psi1/angbracketright
n=|ψ/angbracketright|/Phi1/angbracketright=/parenleftbig
a0|0/angbracketright+ a1|1/angbracketright/parenrightbig
|/Phi1/angbracketright,and
the ﬁnal state of theunmeasured Qbitscontinues to be |/Phi1/angbracketright
regardless of the value of x
indicated by the 1-Qbitmeasurement gate. Theunmeasured Qbits areunentangled with themeasured Qbit anddescribed by the state |/Phi1/angbracketright
throughout the process.The 1-Qbit measurementgate acts on the measuredQbit exactly as it does inFigure 1.5 when no otherQbits are present, and thegeneralized Born rule ofFigure 1.6 reduces to theordinary Born rule.on the n1-Qbit measurement gates. This is nothing but the ordinary
Born rule, with the n1-Qbit measurement gates playing the role of
the single n-Qbit measurement gate. There is thus, as remarked upon
above, only a single primitive piece of measurement hardware: the 1-Qbit measurement gate. The construction of an n-Qbit measurement
gate out of n1-Qbit measurement gates is depicted in Figure 1.8.
An even more general version of the Born rule follows from the
generalized Born rule itself. The general state of m+nQbits can be
written as
|/Psi1/angbracketright
m+n=2m/summationdisplay
x=0αx|x/angbracketrightm|/Phi1x/angbracketrightn, (1.80)
where/summationtext
x|αx|2=1 and the states |/Phi1x/angbracketrightnare normalized, but not nec-
essarily orthogonal. By applying the generalized Born rule mtimes to
mQbits in an ( m+n)-Qbit state, one establishes the rule that if just
the mQbits on the left of (1.80) are measured, then with probability
|αx|2the result will be x, and after the measurement the state of all
m+nQbits will be the product state
|x/angbracketrightm|/Phi1x/angbracketrightn (1.81)
in which the mmeasured Qbits are in the state |x/angbracketrightmand the nunmea-
sured ones are in the state |/Phi1x/angbracketrightn.
1.10 Measurement gates and state preparation
In addition to providing an output at the end of a computation, mea-
surement gates also play a crucial role (which is not often emphasized)at the beginning. Since there is no way to determine the state of a givencollection of Qbits – indeed, in general such a collection might be entan-gled with other Qbits and therefore not even have a state of its own – howcan one produce a set of Qbits in a deﬁnite state for the gates of a quan-tum computer to transform into another computationally useful state?
The answer is by measurement. If one takes nQbits off the shelf,
and subjects them to an n-Qbit measurement gate that registers x,
then the Qbits emerging from that gate are assigned the classical-basisstate|x/angbracketright
n. If one then applies the 1-Qbit operation Xto each Qbit that
registered a 1 in the measurement, doing nothing to the Qbits that

<<<PAGE 48>>>

1.10 MEASUREMENT GATES AND STATE PREPARATION 3 1
x
MM
MMM
=
x1xx3x
02Fig 1.8 Constructing a
4-Qbit measurement gateout of four 1-Qbitmeasurement gates. Theinteger xhas the binary
expansion x
3x2x1x0.
registered 0, the resulting set of Qbits will be described by the state
|0/angbracketrightn. It is this state that most quantum-computational algorithms take
as their input. Such a use of a measurement gate to produce a Qbitdescribed by the state |0/angbracketrightis shown in Figure 1.9.
Measurement gates therefore play tworoles in a quantum com-
putation. They get the Qbits ready for the subsequent action of thecomputer, and they extract from the Qbits a digital output after thecomputer has acted. The initial action of the measurement gates iscalled state preparation , since the Qbits emerging from the process can
be characterized by a deﬁnite state. The association of unitary oper-
ators with the gates that subsequently act on the Qbits permits oneto update that initial state assignment into the corresponding unitarytransformation of the initial state, thereby making it possible to calcu-late, using the Born rule, the probabilities of the outcomes of the ﬁnalmeasurement gates.
This role of measurement gates in state preparation follows from
the Born rule if the Qbits that are to be prepared already have a state oftheir own, even though that state might not be known to the user of thequantum computer. It also follows from the generalized Born rule if theQbits already share an entangled state – again, not necessarily known tothe user – with additional (unmeasured) Qbits. But one cannot deducefrom the Born rules that measurement gates serve to prepare statesfor Qbits “off the shelf,” whose past history nobody knows anythingabout. In such cases the use of measurement gates to assign a state tothe Qbits is a reasonable and plausible extension of the Born rules. Itis consistent with them, but goes beyond them.
For particular physical realizations of Qbits, there may be other ways
to produce the standard initial state |0/angbracketright
n. Suppose, for example, that
each Qbit is an atom, the state |0/angbracketrightis the lowest-energy state (the ground
state) of the atom, and the state |1/angbracketrightis the atomic state of next-lowest

<<<PAGE 49>>>

3 2 CBITS AND QBITS
x
0 ?M XxFig 1.9 Using a 1-Qbit
measurement gate toprepare an off-the-shelfQbit so that its associatedstate is |0/angbracketright. The input on
the left is a Qbit in anunknown condition – i.e.nothing is known of its pasthistory. After themeasurement gate isapplied, the NOT gate
Xis
or is not applied,depending on whether the
measurement gate
indicates 1 or 0. The Qbitthat emerges (on the right)is described by the state |0/angbracketright.energy (the ﬁrst excited state ). Then one can produce the state |0/angbracketrightnby
cooling nsuch atoms to an appropriately low temperature (determined
by the energy difference between the two states – the smaller thatenergy, the lower the temperature must be).
From the conceptual point of view, state preparation by the use of
measurement gates is the simplest way. An acceptable physical can-didate for a Qbit must be a system for which measurement gates arereadily available. Otherwise there would be no way of extracting infor-mation from the computation, however well the unitary gates did theirjob. So the hardware for state preparation by measurement is alreadythere. Whether one chooses to use it or other (e.g. cryogenic) methodsto initialize the Qbits to the state |0/angbracketright
nis a practical matter that need
not concern us here. It is enough to know that it can always be donewith measurement gates.
1.11 Constructing arbitrary 1- and 2-Qbit states
The art of quantum computation is to construct circuits out of 1-and 2-Qbit gates that produce ﬁnal states capable of revealing usefulinformation, when measured. The expectation is that 1-Qbit gateswill be comparatively easy to construct. Two-Qbit gates that are notmere tensor products of 1-Qbit gates are likely to be substantially moredifﬁcult to make. Attention has focused strongly on the cNOT gate,and gates that can be constructed from it in combination with 1-Qbitunitaries. All of the circuits we shall be examining can, in fact, bereduced to combinations of 1-Qbit gates and 2-Qbit cNOT gates. Giventhe difﬁculty in making cNOT gates, it is generally considered desirableto keep their number as small as possible. As an illustration of suchconstructions, we now examine how to assign arbitrary states to one ortwo Qbits, starting with the standard 1-Qbit state |0/angbracketrightor the standard
2-Qbit state |00/angbracketright. (Both of these standard states can be produced with
the help of measurement gates, as described in Section 1.10.)
The situation for 1-Qbit states is quite simple. Let |ψ/angbracketrightbe any 1-Qbit
state, and let |φ/angbracketrightbe the orthogonal state (unique to within an overall
phase), satisfying /angbracketleftφ|ψ/angbracketright=0. Since |0/angbracketrightand|1/angbracketrightare linearly indepen-
dent, there is a unique linear transformation taking them into |ψ/angbracketrightand
|φ/angbracketright. But, since |ψ/angbracketrightand|φ/angbracketrightare an orthonormal pair (as are |0/angbracketrightand
|1/angbracketright), this linear transformation is easily veriﬁed to preserve the norm

<<<PAGE 50>>>

1.11 CONSTRUCTING ARBITRARY 1- AND 2-QBIT STATES 3 3
of arbitrary states, so it is a unitary transformation u. Thus, for any |ψ/angbracketright
there is a 1-Qbit unitary gate uthat takes |0/angbracketrightinto|ψ/angbracketright:
|ψ/angbracketright= u|0/angbracketright. (1.82)
Things are more complicated for 2-Qbit states. An unentangled 2-
Qbit state, being the product of two 1-Qbit states, can be constructedout of|00/angbracketrightby the application of 1-Qbit unitaries to each of the two Qbits.
But a general 2-Qbit state is entangled, and its production requiresa 2-Qbit gate that is not just a tensor product of 1-Qbit unitaries.Interestingly, a single cNOT gate, combined with 1-Qbit unitaries, isenough to do the trick.
To see this, note that the general 2-Qbit state,
|/Psi1/angbracketright=α
00|00/angbracketright+α01|01/angbracketright+α10|10/angbracketright+α11|11/angbracketright, (1.83)
is of the form
|/Psi1/angbracketright=| 0/angbracketright⊗|ψ/angbracketright+| 1/angbracketright⊗|φ/angbracketright, (1.84)
where |ψ/angbracketright=α00|0/angbracketright+α01|1/angbracketrightand|φ/angbracketright=α10|0/angbracketright+α11|1/angbracketright. Apply u⊗1
to|/Psi1/angbracketright, where uis a linear transformation, whose action on the com-
putational basis is of the form
u|0/angbracketright= a|0/angbracketright+ b|1/angbracketright, u|1/angbracketright=− b∗|0/angbracketright+ a∗|1/angbracketright;|a|2+|b|2=1.
(1.85)
The transformation uis unitary because it preserves the orthogonality
and normalization of the basis |0/angbracketright,|1/angbracketright.
We have
/parenleftbig
u⊗1/parenrightbig
|/Psi1/angbracketright=/parenleftbig
a|0/angbracketright+ b|1/angbracketright/parenrightbig
⊗|ψ/angbracketright+/parenleftbig
−b∗|0/angbracketright+ a∗|1/angbracketright/parenrightbig
⊗|φ/angbracketright
=|0/angbracketright⊗|ψ/prime/angbracketright+| 1/angbracketright⊗|φ/prime/angbracketright, (1.86)
where
|ψ/prime/angbracketright= a|ψ/angbracketright− b∗|φ/angbracketright, |φ/prime/angbracketright= b|ψ/angbracketright+ a∗|φ/angbracketright. (1.87)
We would like to choose the complex numbers aand bto make |φ/prime/angbracketright
and|ψ/prime/angbracketrightorthogonal. The inner product /angbracketleftφ/prime|ψ/prime/angbracketrightis
/angbracketleftφ/prime|ψ/prime/angbracketright= a2/angbracketleftφ|ψ/angbracketright− b∗2/angbracketleftψ|φ/angbracketright+ ab∗/parenleftbig
/angbracketleftψ|ψ/angbracketright−/angbracketleftφ|φ/angbracketright/parenrightbig
.(1.88)
If/angbracketleftφ|ψ/angbracketright/negationslash=0, then setting /angbracketleftφ/prime|ψ/prime/angbracketrightto 0 gives a quadratic equation for
a/b∗, which has two complex solutions. If ain (1.85) is any nonzero
complex number then either solution determines b, which, with a,
gives a 1-Qbit unitary ufor which
/parenleftbig
u⊗1/parenrightbig
|/Psi1/angbracketright=| 0/angbracketright⊗|ψ/prime/angbracketright+| 1/angbracketright⊗|φ/prime/angbracketright (1.89)
where |ψ/prime/angbracketrightand|φ/prime/angbracketrightare orthogonal. If /angbracketleftφ|ψ/angbracketright=0 then (1.84) is already
of this form with u=1.

<<<PAGE 51>>>

3 4 CBITS AND QBITS
We can pick positive real numbers λandµso that |ψ/prime/prime/angbracketright=|ψ/prime/angbracketright/λand
|φ/prime/prime/angbracketright=|φ/prime/angbracketright/µare unit vectors, making |ψ/prime/prime/angbracketrightand|φ/prime/prime/angbracketrightan orthonormal
pair. They are therefore related to |0/angbracketrightand|1/angbracketrightby a unitary transforma-
tion v:
|ψ/prime/prime/angbracketright= v|0/angbracketright, |φ/prime/prime/angbracketright= v|1/angbracketright. (1.90)
Equation (1.89) then gives12
|/Psi1/angbracketright=/parenleftbig
u†⊗v/parenrightbig/parenleftbig
λ|0/angbracketright⊗| 0/angbracketright+µ|1/angbracketright⊗| 1/angbracketright/parenrightbig
. (1.91)
We can write this as
|/Psi1/angbracketright=/parenleftbig
u†⊗v/parenrightbig
C10/parenleftbig
λ|0/angbracketright+µ|1/angbracketright/parenrightbig
⊗|0/angbracketright. (1.92)
Since|/Psi1/angbracketrightis a unit vector and unitary transformations preserve unit
vectors, it follows from (1.91) that λ|0/angbracketright+µ|1/angbracketrightis a unit vector. It can
therefore be obtained from |0/angbracketrightby a unitary transformation w.S o
|/Psi1/angbracketright=/parenleftbig
u†⊗v/parenrightbig
C10/parenleftbig
w⊗1/parenrightbig/parenleftbig
|0/angbracketright⊗| 0/angbracketright/parenrightbig
=u†
1v0C10w1|00/angbracketright.(1.93)
We have thus established that a general 1-Qbit state |/Psi1/angbracketrightcan be
constructed out of three 1-Qbit unitaries and a single cNOT gate, acting
on the standard state |00/angbracketright.This is an early example of the usefulness
of cNOT gates.
1.12 Summary: Qbits versus Cbits
Table 1.1 gives a concise comparison of the elementary properties ofCbits and Qbits. The table uses the term “Bit,” with an upper-caseB, to mean “Qbit or Cbit,” which should be distinguished from “bit,”with a lower-case b, which means “0 or 1.” Alice (in the ﬁfth line of thetable) is anybody who knows the relevant history of the Qbits – theirinitial state preparation and the unitary gates that have subsequentlyacted on them.
12 This form for a general vector in a space of 2 ×2 dimensions is a special
case of a more general result for d×ddimensions known as the polar (or
Schmidt) decomposition theorem .

<<<PAGE 52>>>

1.12 SUMMARY: QBITS VERSUS CBITS 3 5
Table 1.1. A summary of the features of Qbits, contrasted to the analogous features of Cbits
Cbits Qbits
States of nBits |x/angbracketrightn,0≤x<2n/summationtextαx|x/angbracketrightn,/summationtext|αx|2=1
Subsets of nBits Always have states Generally have no states
Reversible operations on states Permutations Unitary transformations
Can state be learned from Bits? Yes No
T o learn state of Bits Examine them Go ask Alice
T o get information from Bits Just look at them Measure them
Information acquired xx with probability |αx|2
State after information acquired Same: still |x/angbracketright Different: now |x/angbracketright

<<<PAGE 53>>>

Chapter 2
General features and some
simple examples
2.1 The general computational process
A suitably programmed quantum computer should act on a number x
to produce another number f(x) for some speciﬁed function f. Appro-
priately interpreted, with an accuracy that increases with increasing k,
we can treat such numbers as non-negative integers less than 2k. Each
integer is represented in the quantum computer by the correspondingcomputational-basis state of kQbits.
If we specify the numbers xasn-bit integers and the numbers f(x)
asm-bit integers, then we shall need at least n+mQbits: a set of
n-Qbits, called the input register , to represent x, and another set of m-
Qbits, called the output register , to represent f(x). Qbits being a scarce
commodity, you might wonder why we need separate registers for inputand output. One important reason is that if f(x) assigns the same
value to different values of x, as many interesting functions do, then
the computation cannot be inverted if its only effect is to transform thecontents of a single register from xtof(x). Having separate registers for
input and output is standard practice in the classical theory of reversiblecomputation. Since quantum computers must operate reversibly toperform their magic (except for measurement gates), they are generallydesigned to operate with both input and output registers. We shall ﬁndthat this dual-register architecture can also be usefully exploited by aquantum computer in some strikingly nonclassical ways.
The computational process will generally require many Qbits be-
sides the n+min the input and output registers, but we shall ignore
these additional Qbits for now, viewing a computation of fas doing
nothing more than applying a unitary transformation,
Uf, to the n+m
Qbits of the input and output registers. We take up the fundamentalquestion of why the additional Qbits can be ignored in Section 2.3,only noting for now that it is the reversibility of the computation thatmakes this possible.
We deﬁne the transformation
Ufby specifying it as a reversible
transformation taking computational-basis states into computational-basis states. As noted in Section 1.6, the linear extension of such aclassically meaningful transformation to arbitrary complex superpo-sitions of computational-basis states is necessarily unitary. The stan-dard quantum-computational protocol, which we shall use repeatedly,
36

<<<PAGE 54>>>

2.1 THE GENERAL COMPUTATIONAL PROCESS 3 7
deﬁnes the action of Ufon the computational-basis states |x/angbracketrightn|y/angbracketrightmof
the n+mQbits making up the input and output registers as follows:
Uf/parenleftbig
|x/angbracketrightn|y/angbracketrightm/parenrightbig
=| x/angbracketrightn|y⊕f(x)/angbracketrightm, (2.1)
where ⊕indicates modulo-2 bitwise addition (without carrying) or,
if you prefer, the bitwise exclusive OR. If xand yare m-bit integers
whose jth bits are xjand yj, then x⊕yis the m-bit integer whose jth
bit is xj⊕yj. Thus 1101 ⊕0111=1010. This is a straightforward
generalization of the single-bit ⊕deﬁned in Section 1.3.
If the initial value represented by the output register is y=0 then
we have
Uf/parenleftbig
|x/angbracketrightn|0/angbracketrightm/parenrightbig
=| x/angbracketrightn|f(x)/angbracketrightm (2.2)
and we do indeed end up with f(x) in the output register. Regardless
of the initial value of y, the input register remains in its initial state
|x/angbracketrightn.
The transformation (2.1) is clearly invertible. Indeed, Ufis its own
inverse:
UfUf/parenleftbig
|x/angbracketright|y/angbracketright/parenrightbig
=Uf/parenleftbig
|x/angbracketright|y⊕f(x)/angbracketright/parenrightbig
=| x/angbracketright|y⊕f(x)⊕f(x)/angbracketright=| x/angbracketright|y/angbracketright, (2.3)
since z⊕z=0 for any z. (From this point on I shall use subscripts that
specify the numbers of Qbits only when it is important to emphasizewhat those numbers are.)
The form (2.2) inspires the most important trick of the quantum-
computational repertoire. If we apply to each Qbit in the 2-Qbit state|0/angbracketright|0/angbracketrightthe 1-Qbit Hadamard transformation
H(Equation (1.45)), then
we get
/parenleftbig
H⊗H/parenrightbig/parenleftbig
|0/angbracketright⊗| 0/angbracketright/parenrightbig
=H1H0|0/angbracketright|0/angbracketright=/parenleftbig
H|0/angbracketright/parenrightbig/parenleftbig
H|0/angbracketright/parenrightbig
=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
=1
2/parenleftbig
|0/angbracketright|0/angbracketright+| 0/angbracketright|1/angbracketright+| 1/angbracketright|0/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
=1
2/parenleftbig
|0/angbracketright2+|1/angbracketright2+|2/angbracketright2+|3/angbracketright2/parenrightbig
. (2.4)
This clearly generalizes to the n-fold tensor product of nHadamards,
applied to the n-Qbit state |0/angbracketrightn:
H⊗n|0/angbracketrightn=1
2n/2/summationdisplay
0≤x<2n|x/angbracketrightn, (2.5)
where
H⊗n=H⊗H⊗···⊗ H,ntimes. (2.6)
So if the initial state of the input register is |0/angbracketrightnand we apply an n-fold
Hadamard transformation to that register, its state becomes an equally

<<<PAGE 55>>>

3 8 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
weighted superposition of all possible n-Qbit inputs. If we then apply
Ufto that superposition, with 0 initially in the output register, then
by linearity we get from (2.5) and (2.2)
Uf/parenleftbig
H⊗n⊗1m/parenrightbig/parenleftbig
|0/angbracketrightn|0/angbracketrightm/parenrightbig
=1
2n/2/summationdisplay
0≤x<2nUf/parenleftbig
|x/angbracketrightn|0/angbracketrightm/parenrightbig
=1
2n/2/summationdisplay
0≤x<2n|x/angbracketrightn|f(x)/angbracketrightm.(2.7)
This contains an important part of the magic that underlies quantum
computation. If before letting Ufact, we merely apply a Hadamard
transformation to every Qbit of the input register, initially in the stan-dard state |0/angbracketright
n, the result of the computation is described by a state
whose structure cannot be explicitly speciﬁed without knowing theresult of all 2
nevaluations of the function f. So if we have a mere
hundred Qbits in the input register, initially all in the state |0/angbracketright100(and
mmore in the ouput register), if a hundred Hadamard gates act on the
input register before the application of Uf, then the form of the ﬁnal
state contains the results of 2100≈1030evaluations of the function f.
A billion billion trillion evaluations! This apparent miracle is calledquantum parallelism.
But a major part of the miracle is only apparent. One cannot say
that the result of the calculation is2
nevaluations of f, though some
practitioners of quantum computation are rather careless about makingsuch a claim. All one can say is that those evaluations characterize theform of the state that describes the output of the computation. One
knows what the state isonly if one already knows the numerical values
of all those 2
nevaluations of f. Before drawing extravagant practical,
or even only metaphysical, conclusions from quantum parallelism, itis essential to remember that when you have a collection of Qbits in adeﬁnite but unknown state, there is no way to ﬁnd out what that state is.
If there were a way to learn the state of such a set of Qbits, then every-
one could join in the rhapsodic chorus. (Typical verses: “Where wereall those calculations done? In parallel universes!” “The possibility ofquantum computation has established the existence of the multiverse.”“Quantum computation achieves its power by dividing the computa-tional task among huge numbers of parallel worlds.”) But there is noway to learn the state. The only way to extract any information fromQbits is to subject them to a measurement.
When we send all n+mQbits through measurement gates, the
Born rule tells us that if the state of the registers has the form (2.7),then with equal probability the result of measuring the Qbits in theinput register will be any one of the values of xless than 2
n, while
the result of measuring the Qbits in the ouput register will be thevalue of ffor that particular value of x. So by measuring the Qbits
we can learn a single value of fas well as learning a single (random)

<<<PAGE 56>>>

2.1 THE GENERAL COMPUTATIONAL PROCESS 3 9
x0at which fhas that value. After the measurement the state of the
registers reduces to |x0/angbracketright|f(x0)/angbracketrightand we are no longer able to learn
anything about the values of ffor any other values of x. So although
we can learn something from the output of the “parallel computation,”it is nothing more than what we would have learned had we simply run
the computation starting with a classical state |x/angbracketrightin the input register,
with the value of xchosen randomly. That, of course, could have been
done with an ordinary classical computer.
To be sure, a hint of a miracle remains – hardly more than the smile
of the Cheshire cat – in the fact that in the quantum case the randomselection of the x, for which f(x) can be learned, is made only after
the computation has been carried out. (To assert that the selectionwas made before the computation was done is to make the same error
as asserting that a Qbit described by a superposition of the states |0/angbracketright
and|1/angbracketrightis actually in one or the other of them, as discussed in Section
1.8.) This is a characteristic instance of what journalists like to call“quantum weirdness,” in that (a) it is indeed vexing to contemplatethe fact that the choice of the value of xfor which fcan be learned
is made only after – quite possibly long after – the computation hasbeen ﬁnished, but (b) since that choice is inherently random – beyondanyone’s power to control in any way whatever – it does not matter forany practical purpose whether the selection was made astonishinglyafter or boringly before the calculation was executed.
If, of course, there were an easy way to make copies of the output
state prior to making the measurement, without running the wholecomputation over again, then one could, with high probability, learnthe values of ffor several different (random) values of x. But such
copying is prohibited by an elementary result called the “no-cloningtheorem,” which states that there is no such duplication procedure:there is no unitary transformation that can take the state |ψ/angbracketright
n|0/angbracketrightninto
the state |ψ/angbracketrightn|ψ/angbracketrightnfor arbitrary |ψ/angbracketrightn.
The no-cloning theorem is an immediate consequence of linearity.
If
U/parenleftbig
|ψ/angbracketright|0/angbracketright)=|ψ/angbracketright|ψ/angbracketrightand U/parenleftbig
|φ/angbracketright|0/angbracketright)=|φ/angbracketright|φ/angbracketright, (2.8)
then it follows from linearity that
U/parenleftbig
a|ψ/angbracketright+ b|φ/angbracketright/parenrightbig
|0/angbracketright= aU|ψ/angbracketright|0/angbracketright+ bU|φ/angbracketright|0/angbracketright= a|ψ/angbracketright|ψ/angbracketright+ b|φ/angbracketright|φ/angbracketright.
(2.9)
But if Ucloned arbitrary inputs, we would have
U/parenleftbig
a|ψ/angbracketright+ b|φ/angbracketright/parenrightbig
|0/angbracketright=/parenleftbig
a|ψ/angbracketright+ b|φ/angbracketright/parenrightbig/parenleftbig
a|ψ/angbracketright+ b|φ/angbracketright/parenrightbig
=a2|ψ/angbracketright|ψ/angbracketright+ b2|φ/angbracketright|φ/angbracketright+ ab|ψ/angbracketright|φ/angbracketright+ ab|φ/angbracketright|ψ/angbracketright,
(2.10)

<<<PAGE 57>>>

4 0 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
which differs from (2.9) unless one of aand bis zero. Surprisingly,
this very simple theorem was not proved until half a century after thediscovery of quantum mechanics, presumably because it took that longfor it to occur to somebody that it was an interesting proposition toformulate.
Of course, the ability to clone to a reasonable degree of approxima-
tion would be quite useful. But this is also impossible. Suppose that
U
approximately cloned both |φ/angbracketrightand|ψ/angbracketright:
U/parenleftbig
|ψ/angbracketright|0/angbracketright)≈|ψ/angbracketright|ψ/angbracketrightand U/parenleftbig
|φ/angbracketright|0/angbracketright)≈|φ/angbracketright|φ/angbracketright. (2.11)
Then since unitary transformations preserve inner products, since the
inner product of a tensor product of states is the (ordinary) product oftheir inner products, and since /angbracketleft0|0/angbracketright=1, it follows from (2.11) that
/angbracketleftφ|ψ/angbracketright≈/angbracketleftφ|ψ/angbracketright
2. (2.12)
But this requires /angbracketleftφ|ψ/angbracketrightto be either close to 1 or close to 0. Hence a
unitary transformation can come close to cloning both of two states|ψ/angbracketrightand|φ/angbracketrightonly if the states are very nearly the same, or very close to
being orthogonal. In all other cases at least one of the two states will bebadly copied.
If this were the full story, nobody but a few philosophers would be
interested in quantum computation. The National Security Agencyof the United States of America is interested because there are moreclever things one can do. Typically these involve applying additionalunitary gates to one or both of the input and output registers beforeand/or after applying
Uf, sometimes intermingled with intermediate
measurement gates acting on subsets of the Qbits. All these additionalgates are cunningly chosen so that when one ﬁnally does measure allthe Qbits, one extracts useful information about relations between the
values of ffor several different values of x, which a classical computer
could get only by making several independent evaluations. The priceone inevitably pays for this relational information is the loss of thepossibility of learning the actual value f(x) for any individual x. This
tradeoff of one kind of information for another is typical of quantumcomputation, and typical of quantum physics in general, where it iscalled the uncertainty principle . The principle was ﬁrst enunciated by
Werner Heisenberg in the context of mechanical information – theposition of a particle versus its momentum.
So it is wrong and deeply misleading to say that in the process that
assigns the state (2.7) to the Qbits, the quantum computer has evaluatedthe function f(x) for all xin the range 0 ≤x<2
n. Such assertions are
based on the mistaken view that the quantum state encodes a propertyinherent in the Qbits. The state encodes only the possibilities availablefor the extraction of information from those Qbits. You should keepthis in mind as we examine some of the speciﬁc ways in which this

<<<PAGE 58>>>

2.2 DEUTSCH’S PROBLEM 4 1
nevertheless permits a quantum computer to perform tricks that no
classical computer can accomplish.
2.2 Deutsch’s problem
Deutsch’s problem is the simplest example of a quantum tradeoff thatsacriﬁces particular information to acquire relational information. Acrude version of it appeared in a 1985 paper by David Deutsch that,together with a 1982 paper by Richard Feynman, launched the wholeﬁeld. In that early version the trick could be executed successfully onlyhalf the time. It took a while for people to realize that the trick couldbe accomplished every single time. Here is how it works.
Let both input and output registers each contain only one Qbit, so
we are exploring functions fthat take a single bit into a single bit.
There are two rather different ways to think about such functions.
(1) The ﬁrst way is to note that there are just four such functions, as
shown in Table 2.1. Suppose that we are given a black box that calcu-lates one of these four functions in the usual quantum-computationalformat, by performing the unitary transformation
Uf/parenleftbig
|x/angbracketright|y/angbracketright/parenrightbig
=| x/angbracketright|y⊕f(x)/angbracketright, (2.13)
where the state on the left is that of the 1-Qbit input register ( i), and
the state on the right is that of the 1-Qbit output register ( o). Using
the forms in Table 2.1 and the explicit structure (2.13) of Uf, you can
easily conﬁrm that
Uf0=1, Uf1=Cio, Uf2=CioXo, Uf3=Xo,(2.14)
where 1is the (2-Qbit) unit operator, Ciois the controlled-NOT with
the input Qbit as control and the output as target, and Xoacts as NOT
on the output register. These possibilities are illustrated in the circuit
diagram of Figure 2.1.
Suppose that we are given a black box that executes Uffor one of
the four functions, but are not told which of the four operations (2.14)the box carries out. We can, of course, ﬁnd out by letting the black box
Table 2.1. The four distinct functions
fj(x) that take one bit into one bit
x=0 x=1
f0 00
f1 01
f2 10
f3 11

<<<PAGE 59>>>

4 2 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
x x
f(x) y y
f(0)f(1)
00
01
10
11=
=== X
XX
XU
U
UU
U
fffffFig 2.1 Aw a yt o
construct, with elementarygates, each of the blackboxes
Ufthat realize the
four possible functions f
that appear in Deutsch’sproblem. In case 00 fis
identically 0 and it isevident from the generalform at the top of the ﬁgurethat
Ufacts as the identity.
In case 01 f(x)=x,s oUf
acts as cNOT , with the
input register as thecontrol Qbit. In case 10 f
interchanges 0 and 1, so
Ufapplies NOT to the
target Qbit if and only ifthe computational-basisstate of the control Qbit is|0/angbracketright. This is equivalent to
combining a cNOT with anunconditional NOT on thetarget Qbit. In case 11 fis
identically 1, and the effectof
Ufis just to apply NOT
to the output register,whatever the state of theinput register. Note thediagrammatic convention
for controlled operations:
the control Qbit isrepresented by the wirewith the black dot on it; thetarget Qbit is connected tothe control by a verticalline ending in a box
containing the controlled
operation. An alternativerepresentation for cNOTappears in Figure 2.7.act twice – ﬁrst on |0/angbracketright|0/angbracketrightand then on |1/angbracketright|0/angbracketright. But suppose that we can
only let the box act once. What can we learn about f?
In a classical computer, where we are effectively restricted to letting
the black box act on Qbits in one of the four computational-basis states,we can learn either the value of f(0) (if we let
Ufact on either |0/angbracketright|0/angbracketrightor
|0/angbracketright|1/angbracketright) or the value of f(1) (if we let Ufact on either |1/angbracketright|0/angbracketrightor|1/angbracketright|1/angbracketright).
If we choose to learn the value of f(0), then we can restrict fto being
either f0orf1(if f(0)=0) or to being either f2orf3(if f(0)=1).
If we choose to learn the value of f(1), then we can restrict fto being
either f0orf2(iff(1)=0) or to being either f1orf3(iff(1)=1).
Suppose, however, that we want to learn whether fis constant
(f(0)=f(1), satisﬁed by f0and f3) or not constant ( f(0)/negationslash=f(1),
satisﬁed by f1and f2). We then have no choice with a classical computer
but to evaluate both f(0) and f(1) and compare them. In this way we
determine whether or not fis constant, but we have to extract complete
information about ft od os o .W eh a v et or u n Uftwice.
Remarkably, it turns out that with a quantum computer we do not
have to run Uftwice to determine whether or not fis constant. We
can do this in a single run. Interestingly, when we do this we learnnothing whatever about the individual values of f(0) and f(1), but
we are nevertheless able to answer the question about their relativevalues: whether or not they are the same. Thus we get less informationthan we get in answering the question with a classical computer, butby renouncing the possibility of acquiring that part of the informationwhich is irrelevant to the question we wish to answer, we can get theanswer with only a single application of the black box.

<<<PAGE 60>>>

2.2 DEUTSCH’S PROBLEM 4 3
(2) There is a second way to look at Deutsch’s problem, which gives
it nontrivial mathematical content. One can think of xas specifying a
choice of two different inputs to an elaborate subroutine that requiresmany additional Qbits, and one can think of f(x) as characterizing
a two-valued property of the output of that subroutine. For example
f(x) might be the value of the millionth bit in the binary expansion of√
2+xso that f(0) is the millionth bit in the expansion of√
2 while
f(1) is the millionth bit of√
3. In this case the input register feeds
data into the subroutine and the subroutine reports back to the outputregister.
In the course of the calculation the input and output registers will in
general become entangled with the additional Qbits used by the sub-routine. If the entanglement persists to the end of the calculation, theinput and output registers will have no ﬁnal states of their own, and itwill be impossible to describe the computational process as the simpleunitary transformation (2.1). We shall see in Section 2.3, however, thatit is possible to set things up so that at the end of the computation theadditional Qbits required for the subroutine are no longer entangledwith the input and output registers, so that the additional Qbits can in-deed be ignored. The simple linear transformation (2.1) then correctlycharacterizes the net effect of the computation on those two registers.
Under interpretation (1) of Deutsch’s problem, answering the ques-
tion of whether fis or is not constant amounts to learning something
about the nature of the black box that executes
Ufwithout actually
opening it up and looking inside. Under interpretation (2) it becomesthe nontrivial question of whether the millionth bits of√
2 and√
3
agree or disagree. Under either interpretation, to answer the questionwith a classical computer we can do no better than to run the black boxtwice, with both 0 and 1 as inputs, and compare the two outputs.
In the quantum case we could try the standard trick, preparing the
input register in the superposition (1 /√
2)/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
. After a single
application of Ufthe ﬁnal state of the 1-Qbit input and output registers
would then be
Uf/parenleftbig
H⊗1/parenrightbig/parenleftbig
|0/angbracketright|0/angbracketright/parenrightbig
=1√
2|0/angbracketright|f(0)/angbracketright+1√
2|1/angbracketright|f(1)/angbracketright, (2.15)
as described in (2.7). If we then measured the input and ouput registers
we could learn, under case (2), the millionth bit of either√
2o r√
3,
as well as learning which we had learned. The choice of which we didlearn would be random. This procedure offers no improvement on theclassical situation.
It was ﬁrst noticed that, without making any further use of
Uf, there
are additional unitary transformations one can apply to the state (2.15)before carrying out the measurement that enable you half the timeto state with assurance whether or not f(0)=f(1). (This imperfect
solution to Deutsch’s problem has some interesting features, which we

<<<PAGE 61>>>

4 4 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
explore further in Appendix F .) Some time later, it was realized that
you can always answer the question if you apply appropriate unitary
transformations before as well as after the single application of Uf. Here
is how the trick is done.
To get the output (2.15) we took the input to Ufto be the state
/parenleftbig
H⊗1/parenrightbig/parenleftbig
|0/angbracketright|0/angbracketright/parenrightbig
. (2.16)
Instead of doing this, we again start with both input and output registers
in the state |0/angbracketright, but then we apply the NOT operation Xto both
registers, followed by an application of the Hadamard transform to
both. Since X|0/angbracketright=| 1/angbracketrightandH|1/angbracketright=(1/√
2)(|0/angbracketright−| 1/angbracketright), the input to Uf
is now described by the state
/parenleftbig
H⊗H/parenrightbig/parenleftbig
X⊗X/parenrightbig/parenleftbig
|0/angbracketright|0/angbracketright/parenrightbig
=/parenleftbig
H⊗H/parenrightbig/parenleftbig
|1/angbracketright|1/angbracketright/parenrightbig
=/parenleftBig
1√
2|0/angbracketright−1√
2|1/angbracketright/parenrightBig/parenleftBig
1√
2|0/angbracketright−1√
2|1/angbracketright/parenrightBig
=1
2/parenleftbig
|0/angbracketright|0/angbracketright−| 1/angbracketright|0/angbracketright−| 0/angbracketright|1/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
.
(2.17)
If we take the state (2.17) as input to Uf, then by linearity the resulting
state is
1
2/parenleftbig
Uf(|0/angbracketright|0/angbracketright)−Uf(|1/angbracketright|0/angbracketright)−Uf(|0/angbracketright|1/angbracketright)+Uf(|1/angbracketright|1/angbracketright)/parenrightbig
. (2.18)
It follows from the explicit form (2.13) of the action of Ufon the
computational-basis states that this is simply
1
2/parenleftbig
|0/angbracketright|f(0)/angbracketright−| 1/angbracketright|f(1)/angbracketright−| 0/angbracketright|˜f(0)/angbracketright+| 1/angbracketright|˜f(1)/angbracketright/parenrightbig
, (2.19)
where, as earlier, ˜x=1⊕xso that ˜1=0 and ˜0=1, and ˜f(x)=
1⊕f(x). So if f(0)=f(1) the ouput state (2.19) is
1
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig/parenleftbig
|f(0)/angbracketright−| ˜f(0)/angbracketright/parenrightbig
,f(0)=f(1), (2.20)
but if f(0)/negationslash=f(1) then f(1)=˜f(0), ˜f(1)=f(0),and the output
state (2.19) becomes
1
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig/parenleftbig
|f(0)/angbracketright−| ˜f(0)/angbracketright/parenrightbig
,f(0)/negationslash=f(1). (2.21)
If, ﬁnally, we apply a Hadamard transformation to the input register,
these become
|1/angbracketright1√
2/parenleftbig
|f(0)/angbracketright−| ˜f(0)/angbracketright/parenrightbig
,f(0)=f(1), (2.22)
|0/angbracketright1√
2/parenleftbig
|f(0)/angbracketright−| ˜f(0)/angbracketright/parenrightbig
, f(0)/negationslash=f(1). (2.23)

<<<PAGE 62>>>

2.2 DEUTSCH’S PROBLEM 4 5
On putting together all the operations in a form we can compare
with the more straightforward computation (2.15), we have
/parenleftbig
H⊗1/parenrightbig
Uf/parenleftbig
H⊗H/parenrightbig/parenleftbig
X⊗X/parenrightbig/parenleftbig
|0/angbracketright|0/angbracketright/parenrightbig
=⎧
⎨
⎩|1/angbracketright1√
2/parenleftBig
|f(0)/angbracketright−| ˜f(0)/angbracketright/parenrightBig
,f(0)=f(1),
|0/angbracketright1√
2/parenleftBig
|f(0)/angbracketright−| ˜f(0)/angbracketright/parenrightBig
,f(0)/negationslash=f(1).(2.24)
Thus the state of the input register has ended up as |1/angbracketrightor|0/angbracketrightde-
pending on whether or not f(0)=f(1), so by measuring the input
register we can indeed answer the question of whether f(0) and f(1)
are or are not the same!
Notice that in either case the output register is left in the state
(1/√
2)(|f(0)/angbracketright−| ˜f(0)/angbracketright). Because the two terms in the superposition
have amplitudes with exactly the same magnitude, if one measures theoutput register the result is equally likely to be f(0) or ˜f(0), and one
learns absolutely nothing about the actual value of f(0). The output
register contains no useful information at all.
Another way to put it is that the ﬁnal state of the output register
is±(1/√
2)/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
depending on whether f(0)=0o r f(0)=1.
Since a change in the overall sign of a state (or, more generally, thepresence of an overall complex factor of modulus 1) has no effect onthe statistical distribution of measurement outcomes, there is no wayto distinguish between these two cases.
Thus the price one has paid to learn whether f(0) and f(1) are or
are not the same is the loss of any information whatever about the actualvalue of either of them. One has still eliminated only two of the four
possible forms for the function f. What the quantum computer gives
us is the ability to make this particular discrimination with just a singleinvocation of the black box. No classical computer can do this.
There is a rather neat circuit-theoretic way of seeing why this trick
enables one to learn whether or not f(0)=f(1) in just one application
of
Uf, without going through any of the above algebraic manipulations.
This quite different way of looking at Deutsch’s problem is illustratedin Figures 2.1–2.3. The basic idea is that for each of the four possiblechoices for the function f, the 2-Qbit unitary transformation
Ufbe-
haves in exactly the same way as the equivalent circuit constructed outof a NOT and/or a cNOT gate pictured in Figure 2.1. Consequentlyapplying Hadamard gates to each Qbit, both before and after the ap-plication of
Uf, must produce exactly the same result as it would if
the Hadamards were applied to the equivalent circuits in Figure 2.1.Using the elementary identities in Figure 2.2, one easily demonstratesthat those results are as shown in Figure 2.3. But Figure 2.3 shows ex-plicitly that when
Ufis so sandwiched between Hadamards, the input
register ends up in the state |0/angbracketrightiff(0)=f(1) and in the state |1/angbracketrightif
f(0)/negationslash=f(1).

<<<PAGE 63>>>

4 6 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
= (a)
=
=
=(d)
(e)
(f)= (c)= (b)
XXXZ X
X
Z
ZZHH
HH
HH
HZH
H
HH
HFig 2.2 Some elementary
circuit identities. (a)
H2=1.(b)HXH =Z. (c)
A consequence of (a) and(b). (d) A consequence of(a) and (c). (e) The actionof the controlled- Zgate
does not depend on whichQbit is control and which istarget, since it acts as theidentity on each of thestates|00/angbracketright,|01/angbracketright, and|10/angbracketright
and multiplies the state|11/angbracketrightby−1. (f) This follows
from (d), (a), and (e).
When one thinks of applying this to learn whether the millionth bits
of√
2 and√
3 are the same or different, as in the second interpretation
of Deutsch’s problem, it is quite startling that one can do this with nomore effort (except for a simple modiﬁcation of the initial and ﬁnalstates) than one uses to calculate the millionth bit of either√
2o r√
3.
In this case, however, there is an irritating catch, which we note at theend of Section 2.3.
2.3 Why additional Qbits needn’t mess things up
Now that we have a speciﬁc example of a quantum computation to keepin mind, we can address an important and very general issue mentionedin Section 2.1. The computational process generally requires the useof many Qbits besides the n+min the input and output registers. In
the second interpretation of Deutsch’s problem, it may need a greatmany more. The action of the computer is then described by a uni-tary transformation
W fthat acts on the space associated with allthe
Qbits: those in the input and output registers, together with the r
additional Qbits used in calculating the function f. Only under very
special circumstances will this global unitary transformation W fon
alln+m+rQbits induce a transformation on the input and output
registers that can be be described by a unitary transformation Ufthat
acts only on those two registers, as in (2.1). In general the input andoutput registers will become entangled with the states of the additional
rQbits, and cannot even be assigned a state.

<<<PAGE 64>>>

2.3 WHY ADDITIONAL QBITS NEEDN’T MESS THINGS UP 4 7
x x
f(x) y y
H
H HH
H
H HH
H
H HH
H
H HH=
===f(1)
00
01
0 1
1 1f(0)Uf
X
X
Z
ZU
UUUf
f
f
fFig 2.3 We can get the
action of Uf, when it is
preceded and followed byHadamards on both Qbits,by applying the appropriate
identities of Figure 2.2 to
the diagrams of Figure 2.1.Case 00 is unchangedbecause of Figure 2.2(a). Incase 01 the target andcontrol Qbits of the cNOTare interchanged because of
Figure 2.2(f). The form incase 10 follows from thecorresponding form inFigure 2.1 because ofFigures 2.2(f) and 2.2(b).The form in case 11 followsfrom Figures 2.2(a) and2.2(b). If the initial state ofthe output register (lowerwire) is |1/angbracketrightand the initial
state of the input register(upper wire) is either of thetwo computational-basisstates, then the initial stateof the input register will beunchanged in cases 00 and11, and ﬂipped in cases 01and 10, so by measuringthe input register after theaction of/parenleftbig
H⊗H/parenrightbig
Uf/parenleftbig
H⊗H/parenrightbig
one
can determine whether ornot f(0)=f(1).But if the action of the computer on all n+m+rQbits has a very
special form, then the input and output registers can indeed end upwith a state, related to their initial states through the desired unitarytransformation
Uf. Let the additional rQbits start off in some standard
initial state |ψ/angbracketrightr, so that the initial state of input register, output register,
and additional Qbits is
|/Psi1/angbracketrightn+m+r=| x/angbracketrightn|y/angbracketrightm|ψ/angbracketrightr. (2.25)
Although the radditional Qbits may well become entangled with those
in the input and output registers in the course of the calculation – theywill have to if they are to serve any useful purpose – we require thatwhen the calculation is ﬁnished the ﬁnal state of the computer must beof the form
W f|/Psi1/angbracketrightn+m+r=| x/angbracketrightn|y⊕f(x)/angbracketrightm|φ/angbracketrightr, (2.26)
where the additional rQbits not only are unentangled with the input
and output registers, but also have a state |φ/angbracketrightrthat is independent of
the initial state of the input and output registers.
Because W fis linear on the whole ( n+m+r)-Qbit subspace, and
because |ψ/angbracketrightrand|φ/angbracketrightrare independent of the initial computational-
basis state of the input and output registers, it follows that if theinput and output registers are initially assigned any superpositionof computational-basis states, then
W fleaves them with a deﬁnite
ﬁnal state, which is related to their initial state by precisely the unitarytransformation
Ufof (2.1).

<<<PAGE 65>>>

4 8 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
xnUfxn
ym+f (x)my
Fig 2.4 A schematic representation of the standard unitary
transformation Uffor evaluating a function ftaking a number
0≤x<2ninto a number 0 ≤f(x)<2m. The heavy horizontal lines
(bars) represent multiple-Qbit inputs. In order for the computation tobe reversible even when fis not one-to-one, two multi-Qbit registers
must be used.
Wfxnr
ym+f(x)mxnrf y
y
Fig 2.5 A more realistic picture of the computation represented in
Figure 2.4. Many additional Qbits may be needed to carry out thecalculation. These are represented by an r-Qbit bar in addition to the
n- and m-Qbit bars representing the input and output registers.
The computation is actually executed by a unitary transformation
W fthat acts on the larger space of all n+m+rQbits. The
representation of Figure 2.4 is correct only if the action of this largerunitary transformation
W fon the input and output registers
alone can be represented by a unitary transformation Uf. This
will be the case if the action of W fon the residual rQbits is to take
them from an initial pure state |ψ/angbracketrightrto a ﬁnal pure state |φ/angbracketrightrthat
is independent of the initial contents of the input and outputregisters.
Therefore we can indeed use (2.1), ignoring complications associated
with the additional rQbits needed to compute the function f, if both
the initial and the ﬁnal states of the additional Qbits are independentof the initial states of the input and output registers. Independence ofthe initial states can be arranged by initializing the additional rQbits
to some standard state, for example |/Psi1/angbracketright
r=|0/angbracketrightr. A standard ﬁnal state
|φ/angbracketrightrof the rQbits, which is, in fact, identical to their initial state |ψ/angbracketrightr,
can be produced by taking appropriate advantage of the fact that unitarytransformations are reversible .
We do the trick in three stages.
(1)Begin the computation by applying a unitary transformation
Vthat
acts only on the n-Qbit input register and the radditional Qbits,

<<<PAGE 66>>>

2.3 WHY ADDITIONAL QBITS NEEDN’T MESS THINGS UP 4 9
f(x)mf(x)mxnyr
xnrVfy
Vf
ymCm y+f(x)myxn + r − m†Fig 2.6 A more detailed
view of the structure of theunitary transformation
W f
of Figure 2.5. Algebraically,
W f=V†
fCmVf. First a
unitary transformation Vf
acts only on the n-Qbit
input register and r
additional Qbits, acting asthe identity on the outputregister. Thistransformation takes then+rQbits into a state in
which an m-Qbit subset
represents the result of thecalculation, f(x). Second,
mcontrolled-NOT
transformations (describedin more detail in Figure2.7) act only on the mQbits
representing f(x) and the
mQbits of the output
register, leaving the formermunchanged but changing
the number represented bythe output register from y
toy⊕f(x). Finally, the
inverse
V†
fofVfis applied
to the n+rQbits on the
top two bars, to restorethem to their
(unentangled) initial states.doing nothing to the output register. Because there is no action on
the output register, the n+rQbits on which Vacts continue to
have a state of their own. If the initial state of the input register is|x/angbracketright
nthe unitary transformation Vis designed, using standard tricks
of reversible classical computation (about which we shall have moreto say in Section 2.6) to construct f(x) in an appropriate m-Qbit
subset of the n+rQbits, given xin the input register.
(2)Next change the yinitially in the output register to y⊕f(x),
as (2.1) or (2.26) speciﬁes, without altering the state of the n+r
other Qbits. This can be done with mcNOT gates that combine
to make up a unitary transformation
Cm. The mcontrol Qbits are
those among the n+rthat represent the result of the computation
f(x); the mtarget Qbits are the ones in the corresponding positions
of the output register.
(3)Since the state of the n+rQbits is not altered by the application
ofCm, we can ﬁnally apply to them the inverse transformation V†
to restore them to their original state. We have thus produced therequired unitary transformation
Win (2.26), with the ﬁnal state
|φ/angbracketrightrof the radditional Qbits being identical to their initial state
|ψ/angbracketrightr. This whole construction is illustrated by the circuit diagrams
of Figures 2.4–2.7.
The need for this, or some equivalent procedure, negates some of the
hype one sometimes encounters in discussions of Deutsch’s problem.It is sometimes said that by using a quantum computer one can learnwhether or not f(x)=f(y) in no more time than it takes to perform a
single evaluation of f. This is true only under the ﬁrst, arithmetically
uninteresting, interpretation of Deutsch’s problem. If, however, one isthinking of fas a function of mathematical interest evaluated by an
elaborate subroutine, then to evaluate ffor a single value of xthere is
no need to undo the effect of the unitary transform
Von the additional
registers. But for the trick that determines whether or not f(x)=f(y)
it is absolutely essential to apply V†to undo the effect of V. This doubles
the time of the computation.
This misrepresentation of the situation is not entirely dishonor-
able, however, since in almost all other examples the speed-up is byconsiderably more than a factor of two, and the necessary doubling ofcomputational time is an insigniﬁcant price to pay. We turn immediatelyto an elementary example.

<<<PAGE 67>>>

5 0 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
y yx x= = C5C5
+ x
Fig 2.7 A more detailed picture of the Cmunitary transformation in
Figure 2.6, for the case m= 5. Each of the input and output bars
contains ﬁve Qbits, represented by sets of ﬁve thin lines (wires). Fivedifferent 2-Qbit controlled-NOT gates link the ﬁve upper wiresrepresenting f(x) to the ﬁve lower wires representing the
corresponding positions in the output register. The action of a singlesuch cNOT gate is shown in the lower part of the ﬁgure. Note thealternative convention for a cNOT gate: the black dot on the wirerepresenting the control Qbit is connected by a vertical line to an opencircle on the wire representing the target Qbit. The other convention(used above in Figures 2.1–2.3) replaces the open circle by a squarebox containing the NOT operator
Xthat may act on the target Qbit.
The advantages of the circle representation are that it suggests thesymbol ⊕that represents the XOR operation, and that it is easier to
draw quickly on a blackboard. The advantages of using
Xare that it
makes the algebraic relations more evident when NOT operations X,
Zoperations, or controlled- Zoperations also appear, and that it
follows the form used for all other controlled unitaries.
2.4 The Bernstein–Vazirani problem
Like many of the examples discovered before Shor’s factoring algo-
rithm, this has a somewhat artiﬁcial character. Its signiﬁcance lies notin the intrinsic arithmetical interest of the problem, but in the fact thatit can be solved dramatically and unambiguously faster on a quantumcomputer.
Let abe an unknown non-negative integer less than 2
n. Let f(x)
take any other such integer xinto the modulo-2 sum of the products of
corresponding bits of aand x, which we denote by a·x(in recognition
of the fact that it is a kind of bitwise modulo-2 inner product):
a·x=a0x0⊕a1x1⊕a2x2···. (2.27)

<<<PAGE 68>>>

2.4 THE BERNSTEIN–VAZIRANI PROBLEM 5 1
Suppose that we have a subroutine that evaluates f(x)=a·x.H o w
many times do we have to call that subroutine to determine the valueof the integer a? Here and in all subsequent examples, we shall assume
that any Qbits acted on by such subroutines, except for the Qbits ofthe input and output registers, are returned to their initial state at the
end of the computation, as discussed in Section 2.3.
The mth bit of aisa·2
m, since the binary expansion of 2mhas 1 in
position mand 0 in all the other positions. So with a classical computer
we can learn the nbits of aby applying fto the nvalues x=2m,0≤
m<n.This, or any other classical method one can think of, requires n
different invocations of the subroutine. But with a quantum computerasingle invocation is enough to determine acompletely, regardless of
how big nis!
I ﬁrst describe the conventional way of seeing how this can be done,
and then describe a much simpler way to understand the process. Theconventional way exploits a trick (implicitly exploited in our solution toDeutsch’s problem) that is useful in dealing with functions like fthat
act on nQbits with output to a single Qbit. If the 1-Qbit output register
is initially prepared in the state
HX|0/angbracketright= H|1/angbracketright=(1/√
2)/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
then, since Ufapplied to the computational basis state |x/angbracketrightn|y/angbracketright1ﬂips
the value yof the output register if and only if f(x)=1, we have
Uf|x/angbracketrightn1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
=(−1)f(x)|x/angbracketrightn1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
. (2.28)
So by taking the state of the 1-Qbit output register to be (1 /√
2)/parenleftbig
|0/angbracketright−
|1/angbracketright/parenrightbig
, we convert a bit ﬂip to an overall change of sign. This becomes
useful because of a second trick, which exploits a generalization of theaction (2.5) of
H⊗non|0/angbracketrightn.
The action of Hon a single Qbit can be compactly summarized as
H|x/angbracketright1=1√
2/parenleftbig
|0/angbracketright+(−1)x|1/angbracketright/parenrightbig
=1√
21/summationdisplay
y=0(−1)xy|y/angbracketright. (2.29)
If we apply H⊗nto an n-Qbit computational-basis state |x/angbracketrightnwe can
therefore express the result as
H⊗n|x/angbracketrightn=1
2n/21/summationdisplay
yn−1=0···1/summationdisplay
y0=0(−1)/summationtextn−1
j=0xjyj|yn−1/angbracketright···| y0/angbracketright
=1
2n/22n−1/summationdisplay
y=0(−1)x·y|y/angbracketrightn, (2.30)
where the product x·yis the one deﬁned in (2.27). (Because −1i s
raised to the power/summationtextxjyj, all that matters about the sum is its value
modulo 2.)
So if we start with the n-Qbit input register in the standard initial
state H⊗n|0/angbracketright, put the 1-Qbit output register into the state H|1/angbracketright, apply

<<<PAGE 69>>>

5 2 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
 f(x) y4
3
2
1
0a  = 1
a  = 0
a  = 0
a  = 1a  = 1
34
0124x
3x
2x
1x
0xx
xxx
x
XXX y+Fig 2.8 An illustration of a
circuit that implements theunitary subroutine
Uf
taking n-Qbit input and
1-Qbit output registers,initially in the state|x/angbracketright
n|y/angbracketright1, into
|x/angbracketrightn|y⊕f(x)/angbracketright1, where
f(x)=a·x=/summationtextn−1
j=0ajxj
(mod 2). The Bernstein–
Vazirani problem asks us todetermine all the bits of a
with a single invocation ofthe subroutine. In the
illustration n=5 and
a=25=11001. For
j=0,..., n−1, each of
the cNOT gates adds 1(mod 2) to the outputregister if and only if
a
jxj=1. In addition to
their normal labeling withthe 1-Qbit states theyrepresent, the wires of theinput register are labeledwith the bits of a, to make
it clear which (thoseassociated with a
j=1) act
as control bits for a cNOTtargeted on the outputregister.Uf, and then again apply H⊗nto the input register, we get
/parenleftbig
H⊗n⊗1/parenrightbig
Uf/parenleftbig
H⊗n⊗H/parenrightbig
|0/angbracketrightn|1/angbracketright1
=/parenleftbig
H⊗n⊗1/parenrightbig
Uf/parenleftBigg
1
2n/22n−1/summationdisplay
x=0|x/angbracketright/parenrightBigg
1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright)
=1
2n/2/parenleftBigg
H⊗n2n−1/summationdisplay
x=0(−1)f(x)|x/angbracketright/parenrightBigg
1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright)
=1
2n2n−1/summationdisplay
x=02n−1/summationdisplay
y=0(−1)f(x)+x·y|y/angbracketright1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright). (2.31)
We do the sum over xﬁrst. If the function f(x)i s a·xthen this
sum produces the factor
2n−1/summationdisplay
x=0(−1)(a·x)(−1)(y·x)=n/productdisplay
j=11/summationdisplay
xj=0(−1)(aj+yj)xj. (2.32)
At least one term in the product vanishes unless every bit yjofyis
equal to the corresponding bit ajofa– i.e. unless y=a. Therefore
the entire computational process (2.31) reduces to
H⊗(n+1)UfH⊗(n+1)|0/angbracketrightn|1/angbracketright1=|a/angbracketrightn|1/angbracketright1, (2.33)
where I have applied a ﬁnal Hto the 1-Qbit output register to make the
ﬁnal expression look a little neater and more symmetric. (I have alsorestored subscripts to the state symbols for the n-Qbit input register
and 1-Qbit output register.)
So by putting the input and output registers into the appropriate
initial states, after a single invocation of the subroutine followed by anapplication of
H⊗nto the input register, the state of the input register
becomes |a/angbracketright. As promised, all nbits of the number acan now be
determined by measuring the input register, even though we have called
the subroutine only once!
There is a second, complementary way to look at the Bernstein–
Vazirani problem that bypasses all of the preceding analysis, makingit evident why (2.33) holds, by examining a few circuit diagrams. The

<<<PAGE 70>>>

2.4 THE BERNSTEIN–VAZIRANI PROBLEM 5 3
0
0
0
0
10
a = 1
a = 0
a = 0
a = 1a = 1
234
01
XXXH
H
HH
HHH
HHH
HHFig 2.9 The solution to
the Bernstein–Vaziraniproblem is to start with theinput register in the state|0/angbracketright
nand the output register
in the state |1/angbracketright1and apply
Hadamard transforms to all
n+1 registers before
applying Uf. Another
n+1 Hadamards are
applied after Ufhas acted.
The cNOT gatesreproduce the action of
Uf, as shown in Figure 2.8.
The conventional analysisdeduces the ﬁnal state bycalculating the effect of theHadamards on the initialstate of the Qbits and onthe state subsequentlyproduced by the action of
Uf. A much easier way to
understand what is goingon is to examine the effectof the Hadamards on thecollection of cNOT gatesequivalent to
Uf. This is
shown in Figure 2.10.idea is to note, just as we did for the black box of Deutsch’s problem
in (2.14), that the actions of the black boxes that implement Uffor
the different available choices of fare identical to the actions of some
simple circuits.
When f(x)=a·x, the action of Ufon the computational basis
is to ﬂip the 1-Qbit output register once, whenever a bit of xand the
corresponding bit of aare both 1. When the state of the input register
is|x/angbracketrightnthis action can be performed by a collection of cNOT gates all
targeted on the output register. There is one cNOT for each nonzerobit of a, controlled by the Qbit representing the corresponding bit of
x. The combined effect of these cNOT gates on every computational-
basis state is precisely that of
Uf. Therefore the effect of any other
transformations preceding and/or following Ufcan be understood by
examining their effect on this equivalent collection of cNOT gates, eventhough
Ufmay actually be implemented in a completely different way.
The encoding of ain the disposition of the equivalent cNOT gates
is illustrated in Figure 2.8. The application (2.33) of Hto every Qbit in
the input and output registers both before and after the application of
Uf, pictured in Figure 2.9, converts every cNOT gate in the equivalent
representation of Uffrom Cijto/parenleftbig
HiHj/parenrightbig
Cij/parenleftbig
HiHj/parenrightbig
=Cji, as pictured
in Figure 2.10 (see also Equation (1.44).) After this reversal of targetand control Qbits, the output register controls every one of the cNOTgates, and since the state of the output register is |1/angbracketright, every one of the
NOT operators acts. That action ﬂips just those Qbits of the inputregister for which the corresponding bit of ais 1. Since the input
register starts in the state |0/angbracketright
n, this changes the state of each Qbit of
the input register to |1/angbracketright, if and only if it corresponds to a nonzero bit
ofa. As a result, the state of the input register changes from |0/angbracketrightnto
|a/angbracketrightn, just as (2.33) asserts.
Note how different these two explanations are. The ﬁrst applies Uf
to the quantum superposition of all possible inputs, and then appliesoperations that lead to perfect destructive interference of all states inthe superposition except for the one in which the input register is in thestate|a/angbracketright. The second suggests a speciﬁc mechanism for representing
the subroutine that executes
Ufand then shows that sandwiching such a

<<<PAGE 71>>>

5 4 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
==
X
X
X
X X XXX H
HHH
H
HHHHHH
HHHHHFig 2.10 Sandwiching a
cNOT gate betweenHadamards that act on thecontrol and target Qbitshas the effect ofinterchanging control andtarget, as shown at the topof the ﬁgure. (SeeEquation (1.44) or Figure2.2.) Consequently theaction of all the Hadamardsin Figure 2.9 on the cNOTgates between them issimply to interchange thecontrol and target Qbits, asshown in the lower part ofthe ﬁgure. In establishingthis one uses the fact that
H2=1, so that the Hgates
on wires that are notcontrol or target Qbitscombine to give
1, and
pairs of Hadamards can beintroduced between every
Xon the lowest wire,
converting HXXXH into
(HXH )(HXH )(HXH ).
After the action of theHadamards the cNOTgates are controlled by theoutput register, so if theoutput register is in thestate|1/angbracketrightthen all the
Xact
on their input-registertargets. If the initial state ofthe input register is |0/angbracketright
n
then the effect of each Xis
to change to |1/angbracketrightthe state of
each Qbit associated with abit of athat is 1. This
converts the state of theinput register to |a/angbracketright
n.mechanism between Hadamards automatically imprints aon the input
register.
Interestingly, quantum mechanics appears in the second method
only because it allows the reversal of the control and target Qbits ofa cNOT operation solely by means of 1-Qbit (Hadamard) gates. Onecan also reverse control and target bits of a cNOT classically, but thisrequires the use of 2-Qbit SWAP gates, rather than 1-Qbit Hadamards.You can conﬁrm for yourself that this circuit-theoretic solution to theBernstein–Vazirani problem no longer works if one tries to replace allthe Hadamard gates by any arrangement of SWAP gates.
2.5 Simon’s problem
Simon’s problem, like the Bernstein–Vazirani problem, has an n-bit
nonzero number abuilt into the action of a subroutine Uf, and the aim
is to learn the value of awith as few invocations of the subroutine as
possible. In the Bernstein–Vazirani problem a classical computer mustcall the subroutine ntimes to determine the value of a, while a quantum
computer need call the subroutine only once. The number of calls growslinearly with nin the classical case, while being independent of nin
the quantum case. In Simon’s problem the speed-up with a quantumcomputer is substantially more dramatic. With a classical computer thenumber of times one must call the subroutine grows exponentially inn, but with a quantum computer it grows only linearly.
This spectacular speed-up involves a probabilistic element charac-
teristic of many quantum computations. The characterization of howthe number of calls of the subroutine scales with the number of bits in a
applies not to calculating adirectly, but to learning it with probability
very close to 1.

<<<PAGE 72>>>

2.5 SIMON’S PROBLEM 5 5
The subroutine Ufin Simon’s problem evaluates a function fon
nbits that is two to one – i.e. it is a function from nton−1 bits. It is
constructed so that f(x)=f(y) if and only if the n-bit integers xand
yare related by x=y⊕aor, equivalently and more symmetrically,
x⊕y=a, where ⊕again denotes bitwise modulo-2 addition. One
can think of this as a period-ﬁnding problem. One is told that fis
periodic under bitwise modulo-2 addition,
f(x⊕a)=f(x) (2.34)
for all x, and the problem is to ﬁnd the period a. Simon’s problem is
thus a precursor of Shor’s much subtler and spectacularly more usefulperiod-ﬁnding algorithm – the heart of his factoring procedure – whereone ﬁnds the unknown period aof a function that is periodic under
ordinary addition: f(x+a)=f(x).
To ﬁnd the value of ain (2.34) with a classical computer all you can
do is feed the subroutine different x
1,x2,x3,..., listing the resulting
values of funtil you stumble on an xjthat yields one of the previously
computed values f(xi). You then know that a=xj⊕xi. At any stage
of the process prior to success, if you have picked mdifferent values
ofx, then all you know is that a/negationslash=xi⊕xjfor all pairs of previously
selected values of x. You have therefore eliminated at most1
2m(m−1)
values of a. (You would have eliminated fewer values of aif you were
careless enough to pick an xequal to xi⊕xj⊕xkfor three values
ofxalready selected.) Since there are 2n−1 possibilities for a, your
chances of success will not be appreciable while1
2m(m−1) remains
small compared with 2n. You are unlikely to succeed until mbecomes
of the order of 2n/2, so the number of times the subroutine has to be
run to give an appreciable probability of determining agrows with the
number of bits nas 2n/2– i.e. exponentially. If ahas 100 bits a classical
computer would have to run the subroutine about 250≈1015times
to have a signiﬁcant chance of determining a. At ten million calls per
second it would take about three years.
In contrast, a quantum computer can determine awith high prob-
ability (say less than one chance in a million of failing) by running thesubroutine not very much more than ntimes – e.g. with about 120
invocations of the subroutine if ahas 100 bits. This remarkable feat
can be accomplished with the following strategy.
We return to the standard procedure and apply the unitary transfor-
mation
Ufonly after the state of the input register has been transformed
into the uniformly weighted superposition (2.5) of all possible inputsby the application of
H⊗n, so that the effect of Ufis to assign to the
input and output registers the entangled state
1
2n/22n−1/summationdisplay
x=0|x/angbracketright|f(x)/angbracketright. (2.35)

<<<PAGE 73>>>

5 6 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
If we now subject only the output register to a measurement, then the
measurement gate is equally likely to indicate each of the 2n−1different
values of f. Since each value of fappears in two terms in (2.35) that
have the same amplitudes, the generalized Born rule tells us that theinput register will be left in the state
1√
2/parenleftbig
|x0/angbracketright+| x0⊕a/angbracketright/parenrightbig
(2.36)
for that value of x0for which f(x0) agrees with the random value of f
given by the measurement.
At ﬁrst glance this looks like great progress. We have produced a
superposition of just two computational-basis states, associated withtwo n-bit integers, that differ (in the sense of ⊕)b y a. If we knew those
two integers their bitwise modulo 2 sum would be a. But unfortunately,
as already noted, when a register is in a given quantum state there is ingeneral no way to learn what that state is. To be sure, if we could clonethe state, then by measuring a mere ten copies of it in the computationalbasis we could with a probability of about 0.998 learn both x
0and x0⊕a
and therefore aitself. But unfortunately, as we have also noted earlier,
one cannot clone an unknown quantum state. Nor does it help to runthe algorithm many times, since we are overwhelmingly likely to getstates of the form (2.36) for different random values of x
0. By subjecting
(2.36) to a direct measurement all we can learn is either x0– a random
number, or x0⊕a– another random number. The number athat we
would like to know appears only in the relation between two random
numbers, only one of which we can learn.
Nevertheless, as in Deutsch’s problem, if we renounce the possibility
of learning either number (which alone is of no interest at all), thenby applying some further operations before measuring we can extractsome useful partial information about their relationship – in this casetheir modulo-2 sum a. With the input register in the state (2.36), we
apply the n-fold Hadamard transformation
H⊗n. Equation (2.30) then
gives
H⊗n1√
2/parenleftbig
|x0/angbracketright+| x0⊕a/angbracketright/parenrightbig
=1
2(n+1)/22n−1/summationdisplay
y=0/parenleftbig
(−1)x0·y+(−1)(x0⊕a)·y/parenrightbig
|y/angbracketright.
(2.37)
Since ( −1)(x0⊕a)·y=(−1)x0·y(−1)a·y, the coefﬁcient of |y/angbracketrightin (2.37) is
0i f a·y=1 and 2( −1)x0·yifa·y=0. Therefore (2.37) becomes
1
2(n−1)/2/summationdisplay
a·y=0(−1)x0·y|y/angbracketright, (2.38)
where the sum is now restricted to those yfor which the modulo-2
bitwise inner product a·yis 0 rather than 1. So if we now measure the
input register, we learn (with equal probability) any of the values of y

<<<PAGE 74>>>

2.5 SIMON’S PROBLEM 5 7
for which a·y=0 – i.e. for which
n−1/summationdisplay
i=0yiai=0 (mod 2) , (2.39)
where aiand yiare corresponding bits in the binary expansions of a
and y.
This completes our description of the quantum computation: with
each invocation of Ufwe learn a random ysatisfying a·y=0. What
remains is the purely mathematical demonstration that this information
enables us to determine awith high probability with not many more
than ninvocations. To see that this is plausible, note ﬁrst that with just
a single invocation of Uf, unless we are unlucky enough to get y=0
(which happens with the very small probability 1 /2n−1), we learn a
nonzero value of y, and therefore a nontrivial subset of the nbits of
awhose modulo-2 sum vanishes. One of those bits is thus entirely
determined by the others in the subset, so we have cut the number ofpossible choices for ain half, from 2
n−1 (the−1 reﬂecting the fact that
we are told that a/negationslash=0) to 2n−1−1. In one invocation of the subroutine
we can, with very high probability, eliminate half the candidates for a!
(Contrast this to the classical case, in which a single invocation of Uf
can tell us nothing whatever about a.)
If we now repeat the whole procedure, then with very high proba-
bility the new value of ythat we learn will be neither 0 nor the same
as the value we learned the ﬁrst time. We will therefore learn a newnontrivial relation among the bits of a, which enables us to reduce the
number of candidates by another factor of 2, eliminating three quartersof the possibilities available for awith two invocations of the subrou-
tine. (Compare this to the classical situation in which only a single valueofacan be removed with two invocations.)
If every time we repeat the procedure we have a good chance of
reducing the number of choices for aby another factor of 2, then with n
invocations of the subroutine we might well expect to have a signiﬁcantchance of learning a. This intuition is made precise in Appendix G,
where some slightly subtle but purely mathematical analysis shows thatwith n+xinvocations of
Ufthe probability qof acquiring enough
information to determine ais
q=/parenleftbigg
1−1
2n+x/parenrightbigg/parenleftbigg
1−1
2n+x−1/parenrightbigg
···/parenleftbigg
1−1
2x+2/parenrightbigg
>1−1
2x+1.
(2.40)
Thus the odds are more than a million to one that with n+20 invoca-
tions of Ufwe will learn a, no matter how large nmay be.
The intrusion of some mildly arcane arithmetic arguments, to con-
ﬁrm that the output of the quantum computer does indeed providethe needed information in the advertised number of runs, is charac-teristic of many quantum-computational algorithms. The action of the

<<<PAGE 75>>>

5 8 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
quantum computer itself is rather straightforward, but we must engage
in more strenuous mathematical exertions to show that the outcomeof the quantum computation does indeed enable us to accomplish therequired task.
2.6 Constructing Toffoli gates
As noted in Section 1.6, constraints on what is physically feasiblelimit us to unitary transformations that can be built entirely out of1- and 2-Qbit gates. It is assumed that 1-Qbit unitary gates will be rel-atively straightforward to make, though even this can be challenging formany of the physical systems proposed for Qbits. Making 2-Qbit gatespresents an even tougher challenge to the quantum-computational en-gineer, since they will require one to manipulate with precision thephysical interaction between the two Qbits. Making an inherently 3-Qbit gate goes beyond present hopes.
It has been known since before the arrival of quantum computa-
tion that to build up all arithmetical operations on a reversible classical
computer it is necessary (and sufﬁcient) to use at least one classicallyirreducible 3-Qbit gate – for example controlled-controlled-NOT (cc-NOT) gates, known as Toffoli gates . Such 3-Qbit gates cannot be built
up out of 1- and 2-Cbit gates. This would appear to be bad news forthe prospects of practical quantum computation.
Remarkably, however, the linear extension of the Toffoli gate to
Qbits canbe built up out of 1-Qbit unitary gates acting in suitable
combination with 2-Qbit cNOT gates. The quantum extension of thisclassically irreducible 3-Cbit gate can be realized with a rather smallnumber of 1- and 2-Qbit gates.
The 3-Qbit Toffoli gate
Tacts on the computational basis to ﬂip
the state of the third (target) Qbit if and only if the states of both of the
ﬁrst two (control) Qbits) are 1:
T|x/angbracketright|y/angbracketright|z/angbracketright=| x/angbracketright|y/angbracketright|z⊕xy/angbracketright. (2.41)
Since Tis its own inverse, it is clearly reversible, and therefore its linear
extension from the classical basis to arbitrary 3-Qbit states is unitary,by the general argument in Section 1.6.
The Toffoli gate enables one to calculate the logical AND of two bits
(i.e. their product) since
T|x/angbracketright|y/angbracketright|0/angbracketright=| x/angbracketright|y/angbracketright|xy/angbracketright. Since all Boolean
operations can be built up out of AND and NOT , and since all ofarithmetic can be constructed out of Boolean operations, with Tof-foli gates one can build up all of classical computation through re-versible operations. (One can even produce NOT with a Toffoli gate:
T|1/angbracketright|1/angbracketright|x/angbracketright=| 1/angbracketright|1/angbracketright|x/angbracketright, but this would be a ridiculously hard way to
implement NOT on a quantum computer.)
There are (at least) two rather different ways to construct a ccNOT
gate Tout of cNOT gates and 1-Qbit unitaries. The ﬁrst way to be

<<<PAGE 76>>>

2.6 CONSTRUCTING T OFFOLI GATES 5 9
found requires eight cNOT gates. Later a more efﬁcient construction
was discovered that requires only six cNOT gates. Nobody has founda construction with fewer than six cNOT gates, but I do not knowof a proof that six are required. I describe both constructions, sincethey take advantage of and therefore illustrate several useful quantum-computational tricks.
The construction of a Toffoli gate from eight cNOT gates is based
on three ingredients. (a) For any 1-Qbit unitary
Uone deﬁnes the 2-
Qbit controlled- Ugate CU
10as one that acts on the computational basis
as the identity if the state of Qbit 1 (the control Qbit) is |0/angbracketrightand acts on
Qbit 0 (the target Qbit) as Uif the state of the control Qbit is |1/angbracketright:
CU
10|x1x0/angbracketright= Ux1
0|x1x0/angbracketright. (2.42)
(The cNOT operation Cis thus a CXoperation, but so important a
one as to make it the default form when no Uis speciﬁed.) We shall
show that a controlled- Ugate for arbitrary Ucan be built out of two
cNOT gates and 1-Qbit unitaries. (b) We shall show that a 3-Qbitdoubly-controlled- U
2gate, which takes |x2x1x0/angbracketrightinto ( U2x2x1
0)|x2x1x0/angbracketright,
can be constructed out of two controlled- Ugates, one controlled- U†
gate, and two additional cNOT gates, making a total of eight cNOT
gates. (c) We shall show that there is a unitary square-root-of-NOTgate,√
X. Taking Uin (b) to be√
Xgives the desired Toffoli gate. We
now elaborate on each part of the construction.
(a) Let Vand Wbe two arbitrary 1-Qbit unitary transformations
and consider the product
V0C10V†
0W0C10W†0. (2.43)
One easily conﬁrms that (2.43) acts on the computational basis as CU
10
with
U=(VXV†)(WXW†)=/parenleftbig
V(−→x·−→σ)V†/parenrightbig/parenleftbig
W(−→x·−→σ)W†/parenrightbig
.(2.44)
As shown in Appendix B, one can pick VandWso that
/parenleftbig
V(−→x·−→σ)V†/parenrightbig/parenleftbig
W(−→x·−→σ)W†/parenrightbig
=(−→a·−→σ)(−→b·−→σ)=−→a·−→b+i(−→a⊗−→b)·−→σ,(2.45)
for arbitrary unit vectors−→aand−→b. Appendix B also establishes that
any 1-Qbit unitary transformation has, to within a multiplicative nu-merical phase factor e
iα, the form
u(−→n,θ)=exp( i1
2θ−→n·−→σ)=cos(1
2θ)1+isin(1
2θ)−→n·−→σ.
(2.46)
Ifaand bare in the plane perpendicular to nand the angle between them
is1
2θ, then U=u(n,θ). The 1-Qbit unitary transformation E=eiαn,
applied to Qbit 1, multiplies by the phase factor eiαif and only if the

<<<PAGE 77>>>

6 0 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
=
U W V VE
W† †Fig 2.11 How to construct
a controlled- Ugate CU
from unitary 1-Qbit gates
and two controlled-NOTgates. If the control Qbit isin the state |0/angbracketright, the
operations on the target
wire combine to give(
VV†)(WW†)=1. But if
the control Qbit is in thestate|1/angbracketrightthen the
operations combine to give
U=(VσxV†)(WσxW†),
where σx=−→x·−→σ=X.
To within an overall
numerical phase factor a
general two-dimensionalunitary transformation canalways be put in this formfor appropriate
VandW.
The Eon the control wire
is the unitarytransformation
E=eiαn=/parenleftbigg10
0 eiα/parenrightbigg
,
which supplies such a
phase factor when the stateof the control Qbit is |1/angbracketright.
The two unitary gatesbetween the cNOT gateson the lower wire,
Wand
V†, can be combined into
the single unitary gate
V†W, so in addition to the
two cNOT gates the
construction uses four
1-Qbit unitaries.computational-basis state of Qbit 1 is |1/angbracketright. The resulting circuit for
constructing CUis shown in Figure 2.11.
(b) Given such a controlled- Ugate CU
ijwith Qbit ithe control and
jthe target, a doubly-controlled- U2gate, controlled by Qbits 2 and 1
and targeting Qbit 0, can be constructed out of three such controlled- U
gates and two more cNOT gates:
CU2=CU
10C21CU†
10C21CU
20. (2.47)
The corresponding circuit diagram is shown in Figure 2.12. It is
straightforward to establish that the sequence of operators on the rightof (2.47) acts on the 3-Qbit computational-basis states as
1unless Qbits
2 and 1 are both in the state |1/angbracketright, in which case it acts on Qbit 0 as U2.
(c) Finally, note that
√
Z=/parenleftbigg10
0 i/parenrightbigg
, (2.48)
which is clearly unitary. Therefore, since X=HZH and H2=1, we
have
√
X=H√
ZH. (2.49)
This plays the role of Uin (b) to make the Toffoli gate.
The alternative construction of the Toffoli gate that uses only six
cNOT gates has an action that is somewhat more transparent. It isillustrated in Figure 2.13. If
Aand Bare any two unitaries with A2=
B2=1then the 3-Qbit gate
CB
10CA
20CB
10CA
20 (2.50)
clearly acts as the identity on the computational basis, unless the
states of Qbits 1 and 2 are both |1/angbracketright, in which case it acts as ( BA)2
on Qbit 0, so it is a doubly-controlled-( BA)2gate. Take A=−→a·−→σ
and B=−→b·−→σfor unit vectors−→aand−→b. Since−→n·−→σcan be
expressed as V†/parenleftbig−→x·−→σ/parenrightbig
V=V†XVfor appropriate unitary V, each
controlled- Aand controlled- Bgate can be constructed with a single
controlled-NOT gate and 1-Qbit unitaries. The product BAis the
unitary/parenleftbig−→b·−→σ/parenrightbig/parenleftbig−→a·−→σ/parenrightbig
=(−→b·−→a)1+i/parenleftbig−→b×−→a/parenrightbig
·−→σ.Pick the
unit vectors−→band−→awith the angle between them π/4, lying in
the plane perpendicular to xwith their vector product directed along
−→x, so that/parenleftbig−→b·−→σ/parenrightbig/parenleftbig−→a·−→σ/parenrightbig
=cos(π/4)1+isin(π/4)−→x·−→σ.(For

<<<PAGE 78>>>

2.6 CONSTRUCTING T OFFOLI GATES 6 1
U2U U U=
†
Fig 2.12 How to construct a 3-Qbit controlled-controlled- U2gate
from 2-Qbit controlled-NOT , controlled- U, and controlled- U†gates.
If Qbits 2 and 1 (top and middle wires) are both in the state |1/angbracketrightthen U
acts twice on Qbit 0 (bottom wire) but U†does not. If Qbits 2 and 1 are
both in the state |0/angbracketrightnothing acts on Qbit 0. If Qbits 2 and 1 are in the
states|1/angbracketrightand|0/angbracketrightthen only the Uon the left and the U†act on Qbit 0
(and their product is 1), and if Qbits 2 and 1 are in the states |0/angbracketrightand
|1/angbracketrightonly the Uon the right and the U†act on Qbit 0 (and their product
is again 1.)
XU
BB A A=
Fig 2.13 How to make a doubly-controlled-NOT (Toffoli) gate using
six cNOT gates and 1-Qbit unitaries. The unitary operators AandB
are given by A=−→a·−→σandB=−→b·−→σfor appropriately chosen
real unit vectors−→aand−→b. Because−→n·−→σ=V†/parenleftbig−→x·−→σ/parenrightbig
Vfor
appropriate unitary V, each controlled- Aand controlled- Bgate can be
constructed with a single controlled-NOT gate and 1-Qbit unitaries.Because
A2=B2=1, the controlled- Aand controlled- Bgates act
together as a doubly-controlled-( BA)2gate. One can pick the
directions−→aand−→bso that ( BA)2=iX. The controlled- Ugate on
the right corrects for this unwanted factor of i. Here Uis the 1-Qbit
unitary e−i(π/2)n. Since any controlled-U gate can be constructed with
two cNOT gates and 1-Qbit unitaries, this adds two more cNOT gatesto the construction, making a total of six.
example take−→b=−→zand−→a=(1/√
2)(−→z−−→y).) Then ( BA)2=
cos(π/2)1+isin(π/2)−→x·−→σ=i−→x·−→σ=iX.
Thus (2.50) produces a doubly-controlled-NOT gate except for an
extra factor of iaccompanying the NOT . We can correct for this by
applying an additional CU
21gate, where Uis the 1-Qbit unitary e−i(π/2)n.
This controlled- Ugate acts as the identity on the computational basis
unless the states of Qbits 2 and 1 are both |1/angbracketright, in which case it multiplies
the state by e−iπ/2=− i, thereby getting rid of the unwanted factor
ofi. Since we have just established that any controlled- Ugate can be

<<<PAGE 79>>>

6 2 GENERAL FEATURES AND SOME SIMPLE EXAMPLES
constructed with two cNOT gates and 1-Qbit unitaries, correcting the
phase adds two more cNOT gates to the construction, making a totalof six.
Alternatively, one can view this as a way to construct a Toffoli gate
from four cNOT gates and a single controlled-phase gate of preciselythe kind that plays a central role in the quantum Fourier transform de-scribed in Chapter 3. If quantum computation ever becomes a workingtechnology, it might well be easier to construct controlled-phase gatesas fundamental gates in their own right – pieces of 2-Qbit hardware asbasic as cNOT gates.
As this and subsequent examples reveal, the cNOT gate is of funda-
mental importance in quantum computation. Appendix H gives someexamples of how such gates might actually be realized. That appendix isaddressed primarily to physicists, but readers with other backgroundsmight ﬁnd it an interesting illustration of the rather different questionsthat arise when one starts thinking about how actually to produce someof the basic quantum-computational hardware.

<<<PAGE 80>>>

Chapter 3
Breaking RSA encryption
3.1 Period finding, factoring, and cryptography
Simon’s problem (Section 2.5) starts with a subroutine that calculates
a function f(x), which satisﬁes f(x)=f(y) for distinct xand yif and
only if y=x⊕a, where ⊕denotes the bitwise modulo-2 sum of the
n-bit integers aand x. The number of times a classical computer must
invoke the subroutine to determine agrows exponentially with n,b u t
with a quantum computer it grows only linearly.
This is a rather artiﬁcial example, of interest primarily because it
gives a simple demonstration of the remarkable computational powera quantum computer can possess. It amounts to ﬁnding the unknownperiod aof a function on n-bit integers that is “periodic” under bitwise
modulo-2 addition. A more difﬁcult, but much more natural problemis to ﬁnd the period rof a function fon the integers that is periodic
under ordinary addition, satisfying f(x)=f(y) for distinct xand y
if and only if xand ydiffer by an integral multiple of r. Finding the
period of such a periodic function turns out to be the key to factoringproducts of large prime numbers, a mathematically natural problemwith quite practical applications.
One might think that ﬁnding the period of such a periodic function
ought to be easy, but that is only because when one thinks of periodicfunctions one tends to picture slowly varying continuous functions(like the sine function) whose values at a small sample of points withina period can give powerful clues about what that period might be. Butthe kind of periodic function to keep in mind here is a function on theintegers whose values within a period rare virtually random from one
integer to the next, and therefore give no hint of the value of r.
The best known classical algorithms for ﬁnding the period rof such a
function take a time that grows faster than any power of the number nof
bits of r(exponentially with n
1/3). But in 1994 Peter Shor discovered
that one can exploit the power of a quantum computer to learn theperiod r, in a time that scales only a little faster than n
3.
Because the ability to ﬁnd periods efﬁciently, combined with some
number-theoretic tricks, enables one to factor efﬁciently the prod-uct of two large prime numbers, Shor’s discovery of super-efﬁcientquantum period ﬁnding is of considerable practical interest. The verygreat computational effort required by all known classical factorization
63

<<<PAGE 81>>>

6 4 BREAKING RSA ENCRYPTION
techniques underlies the security of the widely used RSA1method of
encryption. Any computer that can efﬁciently ﬁnd periods would bean enormous threat to the security of both military and commercialcommunications. This is why research into the feasibility of quantumcomputers is a matter of considerable interest in the worlds of war andbusiness.
Although the elementary number-theoretic tricks that underlie the
RSA method of encryption have nothing directly to do with how a quan-tum computer ﬁnds periods, they motivate the problem that Shor’squantum-computational algorithm so effectively solves. Furthermore,examining the number-theoretic basis of RSA encryption reveals thatShor’s period-ﬁnding algorithm can be used to defeat it directly, with-out any detour into factoring. We therefore defer the number-theoreticconnection between period ﬁnding and factoring to Section 3.10. Ifyou are interested only in applying Shor’s period-ﬁnding algorithmto decoding RSA encryption, Section 3.10 can be skipped. If you arenot interested in the application of period ﬁnding to commerce andespionage, you can also skip the number theory in Sections 3.2 and 3.3and go directly to the quantum-computational part of the problem –super-efﬁcient period ﬁnding – in Section 3.4.
3.2 Number-theoretic preliminaries
The basic algebraic entities behind RSA encryption are ﬁnite groups,where the group operation is multiplication modulo some ﬁxed integer
N. In modulo- Narithmetic all integers that differ by multiples of N
are identiﬁed, so there are only Ndistinct quantities, which can be
represented by 0 ,1,... , N−1. For example 5 ×6≡2 (mod 7) since
5×6=30=4×7+2. One writes ≡(mod N) to emphasize that the
equality is only up to a multiple of N, reserving =for strict equality.
One can develop the results that follow using arithmetic rather thangroup theory, but the group-theoretic approach is simpler and usesproperties of groups so elementary that they can be derived from thebasic deﬁnitions in hardly more than a page. This is done in AppendixI, which readers unacquainted with elementary group theory shouldnow read.
Let G
Nbe the set of all positive integers less than N(including 1)
that have no factors in common with N. Since factoring into primes is
unique, the product of two numbers in GN(either the ordinary or the
1 Named after the people who invented it in 1977, Ronald Rivest, Adi Shamir,
and Leonard Adleman. RSA encryption was independently invented byClifford Cocks four years earlier, but his discovery was classiﬁed top secretby British Intelligence and he was not allowed to reveal his priority until1997. For this and other fascinating tales about cryptography, see SimonSingh, The Code Book , New York, Doubleday (1999).

<<<PAGE 82>>>

3.2 NUMBER-THEORETIC PRELIMINARIES 6 5
modulo- Nproduct) also has no factors in common with N,s o GNis
closed under multiplication modulo N.I f a,b, and care in GNwith
ab≡ac(mod N),then a(b−c) is a multiple of N, and since ahas
no factors in common with N, it must be that b−cis a multiple of N,
sob≡c(mod N). Thus the operation of multiplication modulo Nby
a ﬁxed member aofGNtakes distinct members of GNinto distinct
members, so the operation simply permutes the members of the ﬁniteset G
N. Since 1 is a member of GN, there must be some dinGN
satisfying ad=1 – i.e. amust have a multiplicative inverse in GN.
Thus GNsatisﬁes the conditions, listed in Appendix I, for it to be a
group under modulo- Nmultiplication.
Every member aof a ﬁnite group Gis characterized by its order k ,
the smallest integer for which (in the case of GN)
ak≡1 (mod N). (3.1)
As shown in Appendix I, the order of every member of Gis a divisor of
the number of members of G(the order ofG). If pis a prime number,
then the group Gpcontains p−1 numbers, since no positive integer
less than phas factors in common with p. Since p−1 is then a multiple
of the order kof any ainGp, it follows from (3.1) that any integer a
less than psatisﬁes
ap−1≡1 (mod p). (3.2)
This relation, known as Fermat’s little theorem, extends to arbitrary
integers anot divisible by p, since any such ais of the form a=
mp+a/primewith man integer and a/primeless than p.
RSA encryption exploits an extension of Fermat’s little theorem to
a case characterized by twodistinct primes, pand q. If an integer ais
divisible neither by pnor by q, then no power of ais divisible by either
porq. Since, in particular, aq−1is not divisible by p, we conclude
from (3.2) that
[aq−1]p−1≡1 (mod p). (3.3)
For the same reason
[ap−1]q−1≡1 (mod q). (3.4)
The relations (3.3) and (3.4) state that a(q−1)(p−1)−1 is a multiple both
ofpand of q. Since pand qare distinct primes, it must therefore be a
multiple of pq, and therefore
a(q−1)(p−1)≡1 (mod pq). (3.5)
(You are urged to check relations like (3.5) for yourself in special cases.
If, for example p=3 and q=5 then (3.5) requires 28−1 to be divis-
ible by 15, and indeed, 255 =17×15.)

<<<PAGE 83>>>

6 6 BREAKING RSA ENCRYPTION
As an alternative derivation of (3.5), note that since ais divisible
neither by pnor by q, it has no factors in common with pqand is
therefore in Gpq. The number of elements of Gpqispq−1−(p−
1)−(q−1)=(p−1)(q−1), since there are pq−1 integers less
than pq, among which are p−1 multiples of qand another distinct
q−1 multiples of p. Equation (3.5) follows because the order ( p−
1)(q−1) of Gpqmust be a multiple of the order of a.
We get the version of (3.5) that is the basis for RSA encryption by
taking any integral power sof (3.5) and multiplying both sides by a:
a1+s(q−1)(p−1)≡a(mod pq). (3.6)
(The relation (3.6) holds even for integers athat are divisible by por
q. It holds trivially when ais a multiple of pq. And if ais divisible by
just one of pand q, let a=kq. Since ais not divisible by pneither
is any power of a, and therefore Fermat’s little theorem tells us that
[as(q−1)]p−1=1+npfor some integer n. On multiplying both sides
byawe have a1+s(q−1)(p−1)≡a+nap≡a+nkq p,so (3.6) continues
to hold.)
Note ﬁnally that if cis an integer having no factor in common with
(p−1)(q−1) then cis in G(p−1)(q−1)and therefore has an inverse in
G(p−1)(q−1); i.e. there is a dinG(p−1)(q−1)satisfying
cd≡1/parenleftbig
mod ( p−1)(q−1)/parenrightbig
. (3.7)
So for some integer s,
cd=1+s(p−1)(q−1). (3.8)
In view of (3.8) and (3.6), any integer amust satisfy
acd≡a(mod pq). (3.9)
So if
b≡ac(mod pq), (3.10)
then
bd≡a(mod pq). (3.11)
The elementary arithmetical facts summarized in this single paragraph
constitute the entire basis for RSA encryption.
3.3 RSA encryption
Bob wants to receive a message from Alice encoded so that he alone canread it. To do this he picks two large (say 200-digit) prime numbers p
and q. He gives Alice, through a public channel, their product N=pq
and a large encoding number cthat he has picked to have no factors

<<<PAGE 84>>>

3.3 RSA ENCRYPTION 6 7
in common with2(p−1)(q−1). He does not, however, reveal the
separate values of pand qand, given the practical impossibility of
factoring a 400-digit number with currently available computers, he
is quite conﬁdent that neither Alice nor any eavesdropper Eve will beable to calculate pand qknowing only their product N. Bob, however,
because he does know pand q, and therefore ( p−1)(q−1), can ﬁnd
the multiplicative inverse dofcmod ( p−1)(q−1), which satisﬁes
(3.7).
3He keeps dstrictly to himself for use in decoding.
Alice encodes a message by representing it as a string of fewer than
400 digits using, for example, some version of ASCII coding. If hermessage requires more than 400 digits she chops it up into smallerpieces. She interprets each such string as a number aless than N.
Using the coding number cand the value of N=pqshe received
from Bob, she then calculates b≡a
c(mod pq), and sends it on to Bob
through a public channel. With ctypically a 200-digit number, you
might think that this would itself be a huge computational task, but itis not, as noted in Section 3.8. When he receives b, Bob exploits his
private knowledge of dto calculate b
d(mod pq), which (3.11) assures
him is Alice’s original message a.
Were the eavesdropper Eve able to ﬁnd the factors pand qofN, she
could calculate ( p−1)(q−1) and ﬁnd the decoding integer dfrom the
publicly available coding integer c, the same way Bob did. But factoring
a number as large as Nis far beyond her classical computational powers.
Efﬁcient period ﬁnding is of interest in this cryptographic setting notonly because it leads directly to efﬁcient factoring (as described inSection 3.10), but also because it can lead Eve directly to an alternativeway to decode Alice’s message bwithout her knowing or having to
compute the factors pand qofN. Here is how it works:
Eve uses her efﬁcient period-ﬁnding machine to calculate the order
rof Alice’s publicly available encoded message b=a
cin4Gpq.Now
the order rof Alice’s encoded message b=acinGpqis the same
2 As shown in Appendix J, the probability that two large random numbers
have no common factor is greater than1
2, so such care easily found. Whether
two numbers do have any factors in common (and what their greatest
common factor is) can be determined by a simple algorithm known to Euclidand easily executed by Bob on a classical computer. The Euclidean algorithmis described in Appendix J.
3 This can easily be done classically as a straightforward embellishment of the
Euclidean algorithm. See Appendix J.
4 I assume that Alice’s unencoded message a, and hence her coded message b,
is in G
pq– i.e. that ais not a multiple of porq. Since pand qare huge
prime numbers, the odds against abeing such a multiple are astronomical.
But if Eve wants to be insanely careful she can ﬁnd the greatest commonfactor of band N, using the Euclidean algorithm. In the grossly improbable
case that it turns out not to be 1, Eve will have factored Nand can decode
Alice’s message the same way Bob does.

<<<PAGE 85>>>

6 8 BREAKING RSA ENCRYPTION
as the order of a. This is because the subgroup of Gpqgenerated by
acontains ac=b, and hence it contains the subgroup generated by
b; but the subgroup generated by bcontains bd=a, and hence the
subgroup generated by a. Since each subgroup contains the other, they
must be identical. Since the order of aorbis the number of elements
in the subgroup it generates, their orders are the same. So if Eve can
ﬁnd the order rof Alice’s code message b, then she has also learned
the order of Alice’s original text a.
Since Bob has picked cto have no factors in common with
(p−1)(q−1), and since rdivides the order ( p−1)(q−1) of Gpq,
the coding integer ccan have no factors in common with r.S o cis
congruent modulo rto a member c/primeofGr, which has an inverse d/primein
Gr, and d/primeis also a modulo- rinverse of c:
cd/prime≡1 (mod r). (3.12)
Therefore, given c(which Bob has publicly announced) and r(which
Eve can get with her period-ﬁnding program from Alice’s encodedmessage band the publicly announced value of N=pq), it is easy for
Eve to calculate d
/primewith a classical computer, using, modulo r, the same
extension of the Euclidean algorithm as Bob used to ﬁnd d, modulo
(p−1)(q−1). It then follows that for some integer m
bd/prime≡acd/prime=a1+mr=a/parenleftbig
ar/parenrightbigm≡a(mod pq). (3.13)
Eve has thus used her ability to ﬁnd periods to decode Alice’s encoded
message b=acto reveal Alice’s original message a.
This use of period ﬁnding to defeat RSA encryption is summarized
in Table 3.1.
3.4 Quantum period finding: preliminary remarks
So we can crack the RSA code if we have a fast way to ﬁnd the period
rof the known periodic function
f(x)=bx(mod N). (3.14)
This might appear to be a simple task, especially since periodic func-
tions of the special form (3.14) have the simplifying feature that
f(x+s)=f(x)only ifsis a multiple of the period r. But bx(mod N)
is precisely the kind of function whose values within a period hop aboutso irregularly as to offer no obvious clues about the period. One couldtry evaluating f(x) for random xuntil one found two different values
ofxfor which fagreed. Those values would differ by a multiple of
the period, which would provide some important information aboutthe value of the period itself. But this is an inefﬁcient way to proceed,even classically.

<<<PAGE 86>>>

3.4 QUANTUM PERIOD FINDING: PRELIMINARY REMARKS 6 9
Table 3.1. A summary of RSA encryption and how to break it with a fast period-ﬁnding routine on a
quantum computer. Bob has chosen the encoding number cto have an inverse dmodulo ( p−1)(q−1)
soccan have no factors in common with ( p−1)(q−1). Since Alice’s encoded message bis in Gpq,
its order ris a factor of the order ( p−1)(q−1) of Gpq.S o ccan have no factors in common with r,
and therefore has an inverse d/primemodulo r. Because bis a power of aand vice versa, each has the same
order rinGpq. Therefore bd/prime≡acd/prime≡a1+mr≡amodulo N.
Bob knows Alice knows Public knows
pand q(primes); a(her message); b(encoded message);
cand dsatisfying only c(not d) and only N=pq; only c(not d);
cd≡1 (mod ( p−1)(q−1)); b≡ac(mod N) (encoded message). only N=pq.
b(encoded message).
Decoding: Quantum decoding:
a≡bd(mod N). Quantum computer
finds r:br≡1 (mod N);
classical computer finds
d/prime:cd/prime≡1 (mod r);
a≡bd/prime(mod N).
Let n0be the number of bits in N=pq,s ot h a t2n0is the smallest
power of 2 that exceeds N.I f Nis a 500-digit number – a typical size
for cryptographic applications – n0will be around 1700. This also sets
the scale for the typical number of bits in the other relevant numbers
a,b, and their modulo- Nperiod r. To have an appreciable probability
of ﬁnding rby random searching requires a number of evaluations of
fthat is exponential in n0(just as in the classical approach to Simon’s
problem, described in Chapter 2). There are classical ways to improveon random searching, using, for example, Fourier analysis, but no clas-sical approach is known that does not require a time that grows fasterthan any power of n
0. With a quantum computer, however, quantum
parallelism gets us tantalizingly close (but, as in Simon’s problem, notclose enough) to solving the problem with a single application of
Uf,
and enables us to solve it completely with probability arbitrarily closeto unity in a time that grows only as a low-order polynomial in n
0.
To deal with values of xand f(x)=bx(mod N) between 0 and N,
both the input and output registers must contain at least n0Qbits. For
reasons that will emerge in Section 3.7, however, to ﬁnd the period r
efﬁciently the input register must actually have n=2n0Qbits. Dou-
bling the number of Qbits in the input register ensures that the range ofvalues of xfor which f(x) is calculated contains at least Nfull periods
off. This redundancy turns out to be essential for a successful deter-
mination of the period by Shor’s method. (We shall see in Section 3.7that if pand qboth happen to be primes of the form 2
j+1 then – and
only then – the method works without doubling the size of the inputregister. Thus N=15=(2+1)(2
2+1) does not provide a realistic

<<<PAGE 87>>>

7 0 BREAKING RSA ENCRYPTION
test case for laboratory attempts to demonstrate Shor’s algorithm for
small pand qwith real Qbits.)
We begin the quantum period-ﬁnding algorithm by using our quan-
tum computer in the familiar way to construct the state
1
2n/22n−1/summationdisplay
x=0|x/angbracketrightn|f(x)/angbracketrightn0 (3.15)
with a single application of Uf. In Section 3.8 we take a closer look at
how this might efﬁciently be done in the case of interest, f(x)=bx
(mod N). Once the state of the registers has become (3.15), we can
measure the n-Qbit output register.5If the measurement yields the
value f0, then the generalized Born rule tells us that the state of the
n-Qbit input register can be taken to be
|/Psi1/angbracketrightn=1√mm−1/summationdisplay
k=0|x0+kr/angbracketrightn. (3.16)
Here x0is the smallest value of x(0≤x0<r) for which f(x0)=f0,
and mis the smallest integer for which mr+x0≥2n,s o
m=/bracketleftbigg2n
r/bracketrightbigg
orm=/bracketleftbigg2n
r/bracketrightbigg
+1, (3.17)
depending on the value of x0(where [ x] is the integral part of x– the
largest integer less than or equal to x). As in the examples of Chapter 2,
if we could produce a small number of identical copies of the state (3.16)the job would be done, for a measurement in the computational basiswould yield a random one of the values x
0+kr, and the difference
between the results of pairs of measurements on such identical copieswould give us a collection of random multiples of rfrom which ritself
could straightforwardly be extracted. But this possibility is ruled out bythe no-cloning theorem. All we can extract is a single value of x
0+kr
for unknown random x0, which is useless for determining r. And, of
course, if we ran the whole algorithm again, we would end up with a stateof the form (3.16) for another random value of x
0, which would permit
no useful comparison with what we had learned from the ﬁrst run.
But, as with Simon’s problem, we can do something more clever
to the state (3.16) before making our ﬁnal measurement. The problemis the displacement by the unknown random x
0, which prevents any
information about rfrom being extracted in a single measurement. We
need a unitary transformation that transforms the x0dependence into
5 It is not, in fact, necessary to measure the output register. One can continue
to work with the full state (3.15) in which one breaks down the sum on xinto
a sum over all the different values of fand a sum over all the values of x
associated with each value of f. The only purpose of the measurement is to
clarify the analysis by eliminating a lot of uninteresting additional structure,coming from the sum on the values of f, that plays no role beyond making
many of the subsequent expressions somewhat lengthier.

<<<PAGE 88>>>

3.5 THE QUANTUM FOURIER TRANSFORM 7 1
a harmless overall phase factor. This is accomplished with the quantum
Fourier transform.
3.5 The quantum Fourier transform
The heart of Shor’s algorithm is a superfast quantum Fourier trans-form, which can be carried out by a spectacularly efﬁcient quantumcircuit built entirely out of 1-Qbit and 2-Qbit gates. The n-Qbit quan-
tum Fourier transform is deﬁned to be that unitary transformation
UFT
whose action on the computational basis is given by
UFT|x/angbracketrightn=1
2n/22n−1/summationdisplay
y=0e2πixy/2n|y/angbracketrightn. (3.18)
The product xyis here ordinary multiplication.6One easily veriﬁes that
UFT|x/angbracketrightis normalized to unity and that UFT|x/angbracketrightis orthogonal to UFT|x/prime/angbracketright
unless x=x/prime,s oUFTis unitary. Unitarity also emerges directly from
the analysis that follows, which explicitly constructs UFTout of 1- and
2-Qbit unitary gates. The unitary UFTis useful because, as one also
easily veriﬁes, applied to a superposition of states |x/angbracketrightwith complex
amplitudes γ(x), it produces another superposition with amplitudes
that are related to γ(x) by the appropriate discrete Fourier transform:
UFT/parenleftBigg2n−1/summationdisplay
x=0γ(x)|x/angbracketright/parenrightBigg
=2n−1/summationdisplay
x=0˜γ(x)|x/angbracketright, (3.19)
where
˜γ(x)=1
2n/22n−1/summationdisplay
y=0e2πixy/2nγ(y). (3.20)
The celebrated classical fast Fourier transform is an algorithm re-
quiring a time that grows with the number of bits as n2n(rather than/parenleftbig
2n/parenrightbig2as the obvious direct approach would require) to evaluate ˜γ. But
there is a quantum algorithm for executing the unitary transformation
UFTexponentially faster than fast, in a time that grows only as n2.
The catch, as usual, is that one does not end up knowing the complete
6 A warning to physicists (which others can ignore). This looks deceptively
like a (discretized) transformation from a position to a momentumrepresentation, and one’s ﬁrst reaction might be that it is (perhapsdisappointingly) familiar. But it has, in fact, an entirely different character.
The number xis the integer represented by the state |x/angbracketright; it is not the
position of anything. Changing xtox+1 induces an arithmetically natural
but physically quite unnatural transformation on the computational-basisstates, determined by the laws of binary addition, including carrying. It bearsno resemblance to anything that could be associated with a spatial translationin the physical space of Qbits. So your eyes should not glaze over, and youshould regard
UFTas a new and unfamiliar physical transformation of Qbits.

<<<PAGE 89>>>

7 2 BREAKING RSA ENCRYPTION
set of Fourier coefﬁcients, as one does after applying the classical fast
Fourier transform. One just has nQbits described by the state given
by the right side of (3.19), and as we have repeatedly noted, having acollection of Qbits in a given state does not enable one to learn what thatstate actually is. There is no way to extract all the Fourier coefﬁcients
˜γ, given an n-Qbit register in the state (3.19). But if γis a periodic
function with a period that is no bigger than 2
n/2,then a register in
the state (3.19) can give powerful clues about the precise value of theperiod r, even though rcan be hundreds of digits long.
Notice the resemblance of the quantum Fourier transform (3.18)
to the n-fold Hadamard transformation. Since −1=e
πi, the n-fold
Hadamard (2.30) assumes the form
H⊗n|x/angbracketrightn=1
2n/22n−1/summationdisplay
y=0eπix·y|y/angbracketrightn. (3.21)
Aside from the different powers of 2 appearing in the quantum Fourier
transform (3.18) – so the factors of modulus 1 in the superposition arenot just 1 and −1 – the only other difference between the two transforms
is that xyis ordinary multiplication in the quantum Fourier transform,
whereas x·yis the bitwise inner product in the n-fold Hadamard.
Because the arithmetic product xyis a more elaborate function of
xand ythan x·y, the quantum Fourier transformation cannot be
built entirely out of 1-Qbit unitary gates as the n-fold Hadamard is.
But, remarkably, it can be constructed entirely out of 1- and 2-Qbitgates. Even more remarkably, when the procedure is used for periodﬁnding all of the 2-Qbit gates can be replaced by 1-Qbit measurementgates followed by additional 1-Qbit unitary gates whose application iscontingent on the measurement outcomes.
To construct a circuit to execute the quantum Fourier transform
UFT, it is convenient to introduce an n-Qbit unitary operator Z, diag-
onal in the computational basis:
Z|y/angbracketrightn=e2πiy/2n|y/angbracketrightn. (3.22)
This can be viewed as a generalization to nQbits of the 1-Qbit operator
Z, to which it reduces when n=1. Using the familiar relation
H⊗n|0/angbracketrightn=1
2n/22n−1/summationdisplay
y=0|y/angbracketrightn, (3.23)
we can reexpress the deﬁnition (3.18) as
UFT|x/angbracketrightn=ZxH⊗n|0/angbracketrightn. (3.24)
This gives UFT|x/angbracketrightnas an x-dependent operator acting on the state |0/angbracketright.
We next reexpress the right side of (3.24) as an x-independent linear
operator acting on the state |x/angbracketrightn. Since the computational-basis states

<<<PAGE 90>>>

3.5 THE QUANTUM FOURIER TRANSFORM 7 3
|x/angbracketrightnare a basis, this will give us an alternative expression for UFT
itself. The construction of this alternative form for (3.24) is made more
transparent by specializing to the case of four Qbits. The structurethat emerges in the case n=4 has an obvious extension to general n.
Dealing with the case of general nfrom the start only obscures things.
When n=4 we want to ﬁnd an appropriate form for
UFT|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright=ZxH3H2H1H0|0/angbracketright|0/angbracketright|0/angbracketright|0/angbracketright. (3.25)
As usual, we number the Qbits by the power of 2 with which they
are associated, with the least signiﬁcant on the right, so that, readingfrom right to left, the Qbits are labeled 0, 1, 2, and 3;
Hiacts on
the Qbit labeled i(and as the identity on all other Qbits). If |y/angbracketright4=
|y3/angbracketright|y2/angbracketright|y1/angbracketright|y0/angbracketrightin the deﬁnition (3.22) of Z, so that y=8y3+4y2+
2y1+y0,then the operator Zcan be constructed out of single-Qbit
number operators:
Z=exp/parenleftbiggiπ
8/parenleftbig
8n3+4n2+2n1+n0/parenrightbig/parenrightbigg
. (3.26)
The operator Zxappearing in (3.25) then becomes
Zx=exp/parenleftbiggiπ
8/parenleftbig
8x3+4x2+2x1+x0/parenrightbig/parenleftbig
8n3+4n2+2n1+n0/parenrightbig/parenrightbigg
.
(3.27)
Because the 1-Qbit operator exp(2 πin) acts as the identity on either
of the 1-Qbit states |0/angbracketrightand|1/angbracketright, and because any 1-Qbit state is a
superposition of these two, nobeys the operator identity
exp(2πin)=1. (3.28)
Therefore, in multiplying out the two terms
/parenleftbig
8x3+4x2+2x1+x0/parenrightbig/parenleftbig
8n3+4n2+2n1+n0/parenrightbig
(3.29)
appearing in the exponential (3.27), we can drop all products xinj
whose coefﬁcients are a power of 2 greater than 8, getting
Zx=exp/bracketleftbig
iπ/parenleftbig
x0n3+(x1+1
2x0)n2+(x2+1
2x1+1
4x0)n1
+(x3+1
2x2+1
4x1+1
8x0)n0/parenrightbig/bracketrightbig
. (3.30)
Note next that the number and Hadamard operators for any single
Qbit obey the relation
exp( iπxn)H|0/angbracketright= H|x/angbracketright. (3.31)
This is trivial when x=0, and when x=1 it reduces to the correct
statement
(−1)n1√
2(|0/angbracketright+| 1/angbracketright)=1√
2(|0/angbracketright−| 1/angbracketright). (3.32)

<<<PAGE 91>>>

7 4 BREAKING RSA ENCRYPTION
(Alternatively, note that exp( iπn)=ZandZH=HX.) The effect on
(3.25) of the four terms in (3.30) that do not contain factors of1
2,1
4,or
1
8is to produce the generalization of (3.31) to several Qbits:
exp/bracketleftbig
iπ/parenleftbig
x0n3+x1n2+x2n1+x3n0/parenrightbig/bracketrightbig
H3H2H1H0|0/angbracketright|0/angbracketright|0/angbracketright|0/angbracketright
=/bracketleftbig
exp/parenleftbig
iπx0n3)H3/bracketrightbig/bracketleftbig
exp/parenleftbig
iπx1n2)H2/bracketrightbig/bracketleftbig
exp/parenleftbig
iπx2n1)H1/bracketrightbig
×/bracketleftbig
exp/parenleftbig
iπx3n0)H0/bracketrightbig
|0/angbracketright|0/angbracketright|0/angbracketright|0/angbracketright
=H3H2H1H0|x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketright. (3.33)
We have used the fact that number operators associated with different
Qbits commute with one another. Note also that because the numberoperator
niis multiplied by x3−ion the left side of (3.33), the state of
the Qbit labeled ion the right is |x3−i/angbracketright.
The remaining six terms in (3.30) (containing fractional coefﬁcients)
further convert (3.25) to the form
UFT|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright=exp/bracketleftbig
iπ/parenleftbig1
2x0n2+(1
2x1+1
4x0)n1
+(1
2x2+1
4x1+1
8x0)n0/parenrightbig/bracketrightbig
H3H2H1H0|x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketright. (3.34)
Since the Hadamard transformation Hicommutes with the number
operator njwhen i/negationslash=j, we can regroup the terms in (3.34) so that each
number operator niappears immediately to the left of its corresponding
Hadamard operator Hi:
UFT|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright= H3exp/bracketleftbig
iπn21
2x0/bracketrightbig
H2exp/bracketleftbig
iπn1(1
2x1+1
4x0)/bracketrightbig
H1
×exp/bracketleftbig
iπn0(1
2x2+1
4x1+1
8x0)/bracketrightbig
H0
×| x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketright. (3.35)
The state |x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketrightis an eigenstate of the number operators
n3,n2,n1,n0with respective eigenvalues x0,x1,x2,x3.If we did not
have to worry about Hadamard operators interposing themselves be-tween number operators and their eigenstates, we could replace each
x
iin (3.35) by the number operator n3−iof which it is the eigenvalue
to get
UFT|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright= H3exp/bracketleftbig
iπ1
2n2n3/bracketrightbig
H2exp/bracketleftbig
iπn1(1
2n2+1
4n3)/bracketrightbig
×H1exp/bracketleftbig
iπn0(1
2n1+1
4n2+1
8n3)/bracketrightbig
H0
×| x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketright. (3.36)
But as (3.36) makes clear, we do indeed not have to worry, because every
Hiappears safely to the leftof every nithat has replaced an x3−i.
If we deﬁne 2-Qbit unitary operators by
Vij=exp/parenleftbig
iπninj/2|i−j|/parenrightbig
, (3.37)

<<<PAGE 92>>>

3.5 THE QUANTUM FOURIER TRANSFORM 7 5
then (3.36) assumes the more readable form
UFT|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright
=H3/parenleftbig
V32H2/parenrightbig/parenleftbig
V31V21H1/parenrightbig/parenleftbig
V30V20V10H0/parenrightbig
|x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketright.(3.38)
I have put in unnecessary parentheses to guide the eye to the simple
structure, whose generalization to more than four Qbits is, as promised,obvious.
If we deﬁne the unitary operator
Pto bring about the permutation
of computational basis states
P|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright=| x0/angbracketright|x1/angbracketright|x2/angbracketright|x3/angbracketright, (3.39)
then (3.38) becomes
UFT|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright
=H3/parenleftbig
V32H2/parenrightbig/parenleftbig
V31V21H1/parenrightbig/parenleftbig
V30V20V10H0/parenrightbig
P|x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketright.(3.40)
Since (3.40) holds for all computational-basis states it holds for arbi-
trary states and is therefore equivalent to the operator identity
UFT=H3(V32H2)(V31V21H1)(V30V20V10H0)P. (3.41)
The form (3.41) expresses UFTas a product of unitary operators,
thereby independently establishing what we have already noted directlyfrom its deﬁnition, that
UFTis unitary. More importantly it gives an
explicit construction of UFTentirely out of one- and two-Qbit unitary
gates, whose number grows only quadratically with the number nof
Qbits. (The permutation Pcan be constructed out of cNOT gates and
one additional Qbit, initially in the state |0/angbracketright– an instructive exercise
to think about – but in the application that follows it is much easier tobuild directly into the circuitry the rearranging of Qbits accomplishedby
P.)
The permutation operator Pplays an important role in establishing
that the circuit (3.41) that produces the quantum Fourier transform
UFThas an inverse U†
FTpossessing the structure one expects for an
inverse Fourier transform. Since the adjoint of a product is the productof the adjoints in the opposite order, and since Hadamards and
Pare
self-adjoint, we have from (3.41)
U†
FT=P(H0V†10V†20V†30)(H1V†21V†31)(H2V†32)H3. (3.42)
One can insert 1=PPon the extreme right of (3.42) and then note
that the effect of sandwiching all the Hadamards and 1-Qbit unitariesbetween two
Ps is simply to alter all their indices by the permutation
taking 0123 →3210. Therefore
U†
FT=(H3V†
23V†13V†03)(H2V†12V†02)(H1V†01)H0P. (3.43)

<<<PAGE 93>>>

7 6 BREAKING RSA ENCRYPTION
x3
x
xx
012x
x
xx
3210
HP
V1V2V3H V1V2HV1H
Fig 3.1 A diagram of a circuit that illustrates, for four Qbits, the
construction of the quantum Fourier transform UFTdeﬁned in (3.18)
as the product of 1- and 2-Qbit gates given in (3.40).
If we now move every V†to the right past as many Hadamards as we
can, keeping in mind that each Vcommutes with all Hadamards except
those sharing either of its indices, then we have
U†
FT=(H3V†
23)(H2V†13V†12)(H1V†03V†02V†01)H0P. (3.44)
Finally, if we note from (3.37) that each Vis symmetric in its indices,
and rearrange the parentheses in (3.44) to make easier the comparisonwith the form (3.41) of
UFT,w eh a v e
U†
FT=H3(V†32H2)(V†31V†21H1)(V†30V†20V†10H0)P. (3.45)
This is precisely the form (3.41) of UFTitself, except that each Vis
replaced by its adjoint, which (3.37) shows amounts to replacing each
iby−iin the arguments of all the phase factors. This is exactly what
one does to invert the ordinary functional Fourier transform.
3.6 Eliminating the 2-Qbit gates
A circuit diagram that compactly expresses the content of (3.40) isshown in Figure 3.1. As is always the case in such diagrams, the orderin which the gates act is from left to right, although in the equation(3.40) that the diagram represents, the order in which the gates act isfrom right to left. The diagram introduces an artiﬁcial asymmetry intothe 2-Qbit unitary gate
Vij, treating one Qbit as a control bit, which
determines whether or not the unitary operator eiπn/2|i−j|acts on the
other Qbit, taken to be the target. Although this is the most commonway of representing the circuit for the quantum Fourier transform, theﬁgure could equally well have been drawn with the opposite convention,
as in Figure 3.2.
Both Figure 3.1 and Figure 3.2 follow the usual convention, in which
Qbits representing more signiﬁcant bits are represented by lines higherin the ﬁgure. Acting on the computational basis, however, the ﬁrst gate

<<<PAGE 94>>>

3.6 ELIMINATING THE 2-QBIT GATES 7 7
x
x
xx
3210x
x
xx
0123
HP
V1V2
HV1V2
H1V H V3
Fig 3.2 Since the action (3.37) of the controlled- Vgates is symmetric
iniand j, Figure 3.1 can be redrawn with control and target Qbits
interchanged.
on the left, P, permutes the states of the Qbits, exchanging the states of
the most and least signiﬁcant Qbits, the states of the next most signiﬁ-cant and next least signiﬁcant Qbits, etc. Rather than introducing sucha permutation gate, it makes more sense simply to reverse the conven-tion for the input state, associating Qbits that represent more signiﬁcantbits with lower lines in the ﬁgure. The gate
Pis then omitted, and the
conventional ordering of signiﬁcant bits is reversed for the input. Thecomplete ﬁgure thus reduces to the portion to the right of the per-mutation gate
P. For the output, of course, the conventional ordering
remains in effect: Qbits on higher lines represent more signiﬁcant bits.
If the input on the left of the complete Figure 3.1 or 3.2 (with the gate
P) is the computational-basis state |x/angbracketright4=| x3/angbracketright|x2/angbracketright|x1/angbracketright|x0/angbracketrightthe output
on the right will be UFT|x/angbracketright4, the superposition (3.18) of computational-
basis states |y/angbracketright4=| y3/angbracketright|y2/angbracketright|y1/angbracketright|y0/angbracketright, deﬁned in (3.18).
There is no need for the ﬁgures to have subscripts on the Hadamard
gates appearing in (3.40), since each is explicitly attached to the lineassociated with the Qbit on which it acts. For the same reason each2-Qbit controlled- Vgate requires only a single subscript, which spec-
iﬁes the unitary operator
Vkthat acts on the target Qbit when the
computational-basis state of the control Qbit is |1/angbracketright; the subscript kis
the number of “wires” the target Qbit is away from the control Qbit.The explicit form of
Vkiseiπn/2k, where nis the number operator for
the target Qbit.
Figure 3.2 reveals a further simpliﬁcation of great practical inter-
est, if all the Qbits are measured as soon as the action of the quantumFourier transformation is completed. This simpliﬁcation, pointed outby Grifﬁths and Niu, allows the 2-Qbit controlled- Vgates to be re-
placed by 1-Qbit gates that act or not, depending on the outcome ofa prior measurement of the control Qbit, as shown in Figure 3.3. Thesimpliﬁcation is made possible by the following general fact.
If a controlled operation
CU, or a series of consecutive controlled
operations all with the same control Qbit, is immediately followed by

<<<PAGE 95>>>

7 8 BREAKING RSA ENCRYPTION
x
x
xx
3210
yyyy23
1
03V
M1V2V
My1V My
My01V2V
000y
y
yy1y1y1
22y3
HHHH
Fig 3.3 If the Qbits are all measured immediately after all the gates of
the quantum Fourier transform have acted, then the 1-Qbitmeasurement gates can be applied to each Qbit immediately after theaction of the Hadamard gate on that Qbit, and the controlled- Vgates
that follow the action of the Hadamards in Figure 3.2 can be replacedby 1-Qbit gates that act or not depending on whether the outcome yof
the 1-Qbit measurement is 1 or 0.
a measurement of the control Qbit, then the possible ﬁnal states of all
the Qbits and the probabilities of those states are exactly the same asthey would be if the measurement of the control Qbit took place beforethe application of the controlled operation, and then the target Qbit(s)were acted upon or not by
U, depending on whether the result of the
prior measurement was 0 or 1. To conﬁrm this, write an n-Qbit state as
|/Psi1/angbracketrightn=α0|0/angbracketright1|/Phi10/angbracketrightn−1+α1|1/angbracketright1|/Phi11/angbracketrightn−1, (3.46)
where the state of the control Qbit is on the left, the states |/Phi1i/angbracketrightare unit
vectors, and the unitary operation Uacts on some or all of the remaining
n−1 Qbits. Applying the controlled- Uoperation CUto/Psi1ngives
CU|/Psi1/angbracketrightn=α0|0/angbracketright1|/Phi10/angbracketrightn−1+α1|1/angbracketright1U|/Phi11/angbracketrightn−1. (3.47)
If this is immediately followed by a measurement of the control Qbit,
the post-measurement states and associated probabilities are
|0/angbracketright|/Phi10/angbracketright,p=|α0|2;|1/angbracketrightU|/Phi11/angbracketright, p=|α1|2, (3.48)
according to the generalized Born rule. On the other hand if we
measure the control Qbit before applying the controlled- U, the
resulting states and associated probabilities are
|0/angbracketright|/Phi10/angbracketright,p=|α0|2;|1/angbracketright|/Phi11/angbracketright,p=|α1|2, (3.49)
so if we then apply Uto the remaining n−1 Qbits if and only if the
result of the earlier measurement was 1, we end up with exactly thesame states and probabilities as in (3.48).
We shall see that if one’s aim is to ﬁnd the period of the function
f, one can indeed measure each Qbit immediately after applying the

<<<PAGE 96>>>

3.7 FINDING THE PERIOD 7 9
quantum Fourier transform. So this replacement of controlled uni-
tary gates by 1-Qbit unitary gates, which act or not depending on theoutcome of the measurement, is of great importance from the tech-nological point of view, 1-Qbit unitaries being far easier to implementthan 2-Qbit controlled gates.
To see how the general procedure works in this particular case,
consider ﬁrst the bottom wire in Figure 3.2. Once
Hand the three
controlled- Vgates have acted on it, nothing further happens to that
Qbit until its ﬁnal measurement. If the result of that measurementis 1, the state of all four Qbits reduces to that component of thefull superposition in which
V1,V2, and V3have acted on the three
wires above the bottom wire; if the result of the measurement is 0, the4-Qbit state reduces to the component in which they have not acted.We can produce exactly the same effect if we measure the least signif-icant output Qbit immediately after
Hhas acted on the bottom wire,
before any of the other gates have acted, and then apply or do not applythe three unitary transformations to the other three Qbits, dependingon whether the outcome of the measurement is 1 or 0. Next, we applythe Hadamard transformation to the second wire from the bottom. Wethen immediately measure that Qbit and, depending on the outcome,apply or do not apply the appropriate 1-Qbit unitary transformationsto each of the remaining two Qbits. Continuing in this way, we end upproducing exactly the same statistical distribution of measurement re-sults as we would have produced had we used the 2-Qbit controlled- V
gates, measuring none of the Qbits until the full unitary transformation
UFThad been produced. Thus Figure 3.2, followed by measurements
of all four Qbits on the right yielding the values y3,y2,y1, and y0,i s
equivalent to Figure 3.3.
The most attractive (but least common) way of representing the
quantum Fourier transform with a circuit diagram is shown in Figure3.4.
7In this form the inversion in order from most to least signiﬁcant
Qbits between the input and the output is shown by bending the Qbitlines, rather than by inverting the order in the state symbols. The 2-Qbit gates
Vare also displayed in a symmetric way that does not suggest
an artiﬁcial distinction between control and target Qbits.
3.7 Finding the period
The period roffappears in the state (3.16) of the input-register Qbits
produced from a single application of Uf. To get valuable information
7 The ﬁgure is based on one drawn by Robert B. Grifﬁths and Chi-Sheng Niu
in their paper setting forth the Grifﬁths–Niu trick, “Semiclassical Fouriertransform for quantum computation,” Physical Review Letters 76, 3228–3231
(1996) ( http://arxiv.org/abs/quant-ph/9511007 ).

<<<PAGE 97>>>

8 0 BREAKING RSA ENCRYPTION
xxxx
0123 HHHHFig 3.4 A more symmetric
way of drawing Figure 3.1or 3.2, due to Grifﬁths andNiu. Although it issuperior to theconventional diagram, itdoes not seem to havecaught on. Thepermutation
Pthat in
effect permutes the Qbitsin the input register is nowbuilt into the diagram byusing lines that no longerconnect input-registerQbits to output-registerQbits at the samehorizontal level. Becausethe lines now cross oneanother, the unitaryoperators
Vcan be
represented by the circlesat the intersections of thelines associated with theQbits that they couple,eliminating the artiﬁcialdistinction between controland target Qbits used inFigures 3.1 and 3.2. Theform of each such operator
is
V=exp/parenleftbig
iπnn/prime/2k/parenrightbig
,
where nandn/primeare the Qbit
number operatorsassociated with the twolines that cross at the dot,and k=1,2,or 3
depending on whether thedot lies in the ﬁrst, second,or third horizontal rowbelow the top row ofHadamardtransformations. Thelarger the phase producedby
V, the blacker the circle.about rwe apply the quantum Fourier transformation (3.18) to the
input register:
UFT1√mm−1/summationdisplay
k=0|x0+kr/angbracketright=1
2n/22n−1/summationdisplay
y=01√mm−1/summationdisplay
k=0e2πi(x0+kr)y/2n|y/angbracketright
=2n−1/summationdisplay
y=0e2πix0y/2n1√
2nm/parenleftBiggm−1/summationdisplay
k=0e2πik ry/2n/parenrightBigg
|y/angbracketright.
(3.50)
If we now make a measurement, the probability p(y) of getting the
result yis just the squared magnitude of the coefﬁcient of |y/angbracketrightin (3.50).
The factor e2πix0y/2n, in which the formerly troublesome x0explicitly
occurs, drops out of this probability8and we are left with
p(y)=1
2nm/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglem−1/summationdisplay
k=0e2πik ry/2n/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle2
. (3.51)
This completes the quantum-computational part of the process,
except that, as noted below, we may have to repeat the procedure asmall number of times (of order ten or so) to achieve a high probabilityof learning the period r. To see why the form (3.51) of p(y) makes this
possible, we require some further purely mathematical analysis, that ata certain point will exploit yet another branch of elementary numbertheory.
The probability (3.51) is a simple explicit function of the integer y,
whose magnitude has maxima when yis close
9to integral multiples of
8 The random value of x0<ralso determines whether mis given by rounding
the enormous value of 2n/rup or down to the nearest integer – see Equation
(3.17) and the surrounding text – but this makes a negligible difference inwhat follows.
9 Such sums of phase factors are familiar to physicists (to whom this
cautionary footnote is addressed), particularly in the context oftime-dependent perturbation theory, where one approximates them in termsof Dirac delta-functions concentrated in the maximum values. The analysis

<<<PAGE 98>>>

3.7 FINDING THE PERIOD 8 1
2n/r. In fact we now show that the probability is at least 0.4 that the
measured value of ywill be as close as possible to – i.e. within1
2of –
an integral multiple of 2n/r. To see this we calculate a lower bound for
p(y) when
y=yj=j2n/r+δj, (3.52)
with|δj|≤1
2. Only the term in δjcontributes to the exponentials in
(3.51). The summation is a geometric series, which can be explicitlysummed to give
p(y
j)=1
2nmsin2(πδ jmr/2n)
sin2(πδ jr/2n). (3.53)
Since (3.17) tells us that mis within an integer of 2n/r, and since
2n/r≥N2/r>N, we can with negligible error replace mr/2nby 1
in the numerator of (3.53), and replace the sine in the denominator byits (extremely small) argument. This gives
p(y
j)=1
2nm/parenleftbiggsin(πδ j)
πδ jr/2n/parenrightbigg2
=1
r/parenleftbiggsin(πδ j)
πδ j/parenrightbigg2
. (3.54)
When xis between 0 and π/2, the graph of sin xlies above the
straight line connecting the origin to the maximum at x=π/2:
x/slashbig/parenleftbig1
2π/parenrightbig
≤sinx,0≤x≤π/2. (3.55)
Sinceδj≤1
2the probability (3.54) is bounded below by
p(yj)≥(4/π2)/r. (3.56)
Since there are at least r−1 different values of j, and since ris a large
number,10one has at least a 40% chance (4 /π2=0.4053) of getting
one of the special values (3.52) for y– a value that is within1
2of an
integral multiple of 2n/r.
Note, in passing, that as δj→0 in (3.54) the probability p(yj)
becomes 1 /r, so that if all the δjare 0 – i.e. if the period ris exactly a
power of 2 – then the probability of measuring an integral multiple of2
n/ris essentially 1. Indeed, you can easily check that in this (highly
unlikely) case the probability remains 1 even if we do not double thenumber of Qbits in the input register and take n=n
0. Thus the case
r=2javoids some of the major complications of quantum period
required here is different in two important ways. Because we need to know
the enormous integer rexactly we must pay much more careful attention to
just how much of the probability is concentrated in those special values of
y, and we must also solve the subtle problem of how to get from such
maximum values to the precise period ritself.
10 One can easily test with a classical computer all values of rless than, say,
100, to see whether they are periods of f; one need resort to the quantum
computation only if ritself is enormous.

<<<PAGE 99>>>

8 2 BREAKING RSA ENCRYPTION
ﬁnding. Since rdivides ( p−1)(q−1), all periods modulo pqmust be
powers of 2 if pand qare both primes of the form 2n+1. The smallest
such primes are 3, 5, 17, and 257. Hence claims to have realized theShor algorithm for factoring 15 are to be taken cum grano salis , as should
possible future claims based on factoring 51, 85, and 771.
Note also that the derivation of (3.56) requires only that the argu-
ment of the sine in the denominator of (3.53) be small. This will be thecase if 2
nis any large multiple of N– i.e. if the input register is large
enough to contain many periods of bx(mod N). The stronger require-
ment that 2nshould be as large as N2– that the input register should
actually be able to accomodate at least Nfull periods – emerges when
we examine whether it is possible to learn ritself, given an integral
multiple of 2n/r.
Suppose that we have found a ythat is within1
2ofj2n/rfor some
integer j. It follows that
/vextendsingle/vextendsingle/vextendsingley
2n−j
r/vextendsingle/vextendsingle/vextendsingle≤1
2n+1. (3.57)
Since yis the result of our measurement and we know n, the number
of input-register Qbits, we have an estimate for the fraction j/r.I ti s
here that our use of an n-Qbit input register with 2n>N2is crucial.
By using twice as many Qbits as needed to represent all the integersup to N, we have ensured that our estimate (3.57) of j/ris off by
no more than 1 /(2N
2). But since r<N, and since any two distinct
fractions with denominators less than Nmust differ11by at least 1 /N2,
the measured value of yand the fact that ris less than Nis enough to
determine a unique value of the rational number j/r.
That value of j/rcan be efﬁciently extracted from the known value
ofy/2nby an application of the theory of continued fractions. This
exploits the theorem that if xis an estimate for j/rthat differs from it
by less than 1 /(2r2), then j/rwill appear as one of the partial sums in
the continued-fraction expansion of x. The application of the theorem
in this context is illustrated in Appendix K. The continued-fractionexpansion of y/2
ngives us not jand rseparately, but the fraction j/r
reduced to lowest terms – i.e. it gives us integers j0and r0with no
common factors that satisfy j0/r0=j/r. The r0we learn is thus a
divisor of r.
Since risr0times the factors jhas in common with r,i fw ew e r e
lucky enough to get a jthat is coprime to r, then r0=r. Since, as shown
in Appendix J, two random numbers jand rhave a better than even
chance of having no common factors, we do not have to be terribly lucky.
11 For/vextendsingle/vextendsingle/vextendsinglea
b−c
d/vextendsingle/vextendsingle/vextendsingle≥1
bd
unless the two fractions are identical.

<<<PAGE 100>>>

3.8 CALCULATING THE PERIODIC FUNCTION 8 3
We can easily check to see whether r0itself is the period rby computing
(with a classical computer) br0(mod N) and seeing whether or not it is
b. If it is not, we can try several low multiples, 2 r0,3r0,4r0,... , since
it is unlikely that jwill share a large factor with r.
If this fails, we can repeat the entire quantum computation from
the beginning. We now get j/prime/r, where j/primeis another (random) integer,
yielding another divisor r/prime
0ofr, which is rdivided by the factors it has
in common with j/prime.I f jand j/primehave no factors in common – which
has a better than even chance of happening – then rwill be the least
common multiple12of its two divisors r0and r/prime
0. We can again test to see
whether we have the right rby evaluating br(mod N) to see whether
it is indeed equal to b. If it is not, we can again try some of the lower
multiples of our candidate for rand, if necessary, go through the whole
business one more time to get yet another random multiple of 1 /r.
Because we are not certain that our measurement gives us one of the
yjand thus a divisor of r, we may have to repeat the whole procedure
several (but not a great many) times before succeeding, carrying outsome not terribly taxing mathematical detective work, with the aid of aclassical computer, to ﬁnd the period r. The detective work is greatly
simpliﬁed by the fact (established in Appendix L) that when Nis the
product of two primes, the period ris not only less than N, but also
less than
1
2N. As a result, a more extended analysis shows that the
probability of learning a divisor of rfrom the measured value of yis
bounded from below not just by 0.4, but by more than 0.9. Furthermore,by adding just a small number qof additional Qbits to the input register,
so that nexceeds 2 n
0+q, the probability of learning a divisor of rin a
single run can be made quite close to 1. These reﬁnements are describedin Appendix L.
3.8 Calculating the periodic function
We have assumed the existence of an efﬁcient subroutine that calcu-lates b
x(mod N). You might think that calculating f(x)=bx(mod
N) for arbitrary values of xless than, say, 2n=10800would require
astronomical numbers of multiplications, but it does not. We simplysquare b(mod N), square the result (mod N), square that, etc., cal-
culating the comparatively small number of powers b
2j(mod N) with
j<n. The binary expansion of x=xn−1xn−2...x1x0tells us which
of these must be multiplied together to get bx=/producttext
j(b2j)xj.
So if we start with xin the input register, 1 (i.e. 000 ...001) in
the output register, and bin an additional work register, then we can
proceed as follows:
12 The least common multiple of two numbers is their product divided by
their greatest common divisor; the greatest common divisor can be foundwith the Euclidean algorithm, as shown in Appendix J.

<<<PAGE 101>>>

8 4 BREAKING RSA ENCRYPTION
(a) multiply the ouput register by the work register if and only if
x0=1;
(b) replace the contents of the work register by its modulo- Nsquare;
(a/prime)repeat (a) with the multiplication now conditional on x1=1;
(b/prime)repeat (b);
(a/prime/prime)repeat (a) with the multiplication now conditional on x2=1; etc.
At the end of this process we will still have xin the input register (which
serves only as a set of control bits for the ncontrolled multiplications),
and we will have bx(mod N) in the output register. The work register
will contain b2nwhatever the value of xin the input register, and it
will therefore be unentangled with the input and output registers andcan be ignored when we take our starting point to be a superpositionof classical inputs.
13
Note the striking difference between classical and quantum pro-
gramming styles. One’s classical computational instincts would directone to make a look-up table of all nmodulo- Nmultiple squares of b,
since (a) Cbits are cheap and stable and (b) otherwise to get b
x(mod
N) for all the needed values of xone would have to recalculate the
successive squares so many times that this would become ridiculouslyinefﬁcient. But the situation is quite the opposite with a quantumcomputer, since (a) Qbits are expensive and fragile and (b) “quantumparallelism” makes it possible to produce the state (3.15) with only asingle execution of the procedure that does the successive squarings,thereby relieving us of any need to store all the modulo- Nsquares, at
a substantial saving in Qbits.
As usual with quantum parallelism, there is the major catch that an
immediate measurement of Qbits in the state (3.15) can reveal only thevalue of a single (random) one of the modulo- Npowers of b. But by
applying
UFTto the input register of the state (3.15) and only then
making the measurement, we can get important collective informationabout the modulo- Nvalues of b
x– in this case a divisor of the crucial
period r– at the (unimportant) price of losing all information about
the individual values of bx.
3.9 The unimportance of small phase errors
To execute the quantum Fourier transform one needs 2-Qbit gates
Vij=eiπninj/2|i−j|or, if one exploits the Grifﬁths–Niu trick, 1-Qbit
gates Vj=eiπnj/2j.Since we need to deal with numbers of many
hundreds of digits, the 2jappearing in these phase gates can be larger
than 10100. Producing such tiny phase shifts requires a degree of control
over the gates that is impossible to achieve. Typically such phase-shift
13 As noted in Chapter 2, any additional registers used in the squaring and
multiplication subroutines must also be restored to their initial states toinsure that they are also disentangled from the input and output registers.

<<<PAGE 102>>>

3.9 THE UNIMPORTANCE OF SMALL PHASE ERRORS 8 5
gates would allow two Qbits to interact in a carefully controlled way
for an interval of time that was speciﬁed very precisely, but obviouslynot to hundreds of signiﬁcant ﬁgures. It is therefore crucial that theeffectiveness of the period-ﬁnding algorithm not be greatly affected bysmall errors in the phase shifts.
On the face of it this seems worrisome. Since we need to know the
period rto hundreds of digits, don’t we have to get the phase shifts right
to a comparable precision? Here the fundamentally digital character ofthe actual output of a quantum computation saves the day. To learn r
we require the outcomes of several hundreds of 1-Qbit measurements,each of which has just two possible outcomes (0 or 1). The action of theunitary gates that precede the measurements is like that of an analogcomputer, involving continuously variable phase shifts that cannot becontrolled with perfect precision. But this analog evolution affects onlythe probabilities of the sharply deﬁned digital outputs. Small alterations
in the phases produce small alterations in the probabilities of gettingthat extremely precise digital information, but not the precision of theinformation itself, once it is acquired.
14
Suppose that the phase of each term in the quantum Fourier trans-
form (3.18) is incorrect by an amount ϕ(x,y), and that each of these
altered phases is bounded in magnitude by ϕ/lessmuch1. The probability
p(y) in (3.51) will be changed to
pϕ(y)=1
2nm/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglem−1/summationdisplay
k=0e2πik ry/2neiϕk(y)/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle2
, (3.58)
where ϕk(y)=ϕ(x0+kr,y). Since all the phases ϕk(y) are small com-
pared with unity,
eiϕk(y)≈1+iϕk(y), (3.59)
and therefore
pϕ(y)≈1
2nm/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglem−1/summationdisplay
k=0e2πik ry/2n/parenleftbig
1+iϕk(y)/parenrightbig/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle2
. (3.60)
What effect does this have on the probability of learning from the
measurement one of the special values yjgiven in (3.52)?
We have
pϕ(yj)≈1
2nm/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsinglem−1/summationdisplay
k=0e2πik rδj/2n/parenleftbig
1+iϕjk/parenrightbig/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle2
, (3.61)
14 For a long time this crucial point seems to have been discussed only in an
unpublished internal IBM report by D. Coppersmith. In 2002 that 1994report ﬁnally appeared: D. Coppersmith, “ An approximate Fouriertransform useful in quantum factoring,”http://arxiv.org/abs/quant-ph/0201067.

<<<PAGE 103>>>

8 6 BREAKING RSA ENCRYPTION
where ϕjk=ϕk(yj). If we expand to linear order in the small quantities
ϕjk,w eg e t
pϕ(yj)≈p(yj)+2
2nmIm/bracketleftBigg/parenleftBiggm−1/summationdisplay
k=0e−2πik rδj/2nϕjk/parenrightBigg/parenleftBiggm−1/summationdisplay
k/prime=0e2πik/primerδj/2n/parenrightBigg/bracketrightBigg
.
(3.62)
We can get an upper bound on the magnitude of the difference be-
tween the exact and approximate probabilities by replacing the imagi-nary part of the product of the two sums by the product of the absolutevalues of the sums, and then replacing each term in each sum by itsabsolute value. Since the absolute value of each ϕ
jkis bounded by ϕ,
we can conclude that
|p(yj)−pϕ(yj)|≤2m
2nϕ=2
rϕ. (3.63)
Since there are rdifferent yj, the probability of getting one of the
special values yjis altered by less than 2 ϕ. So if one is willing to
settle for a probability of getting a special value that is at worst 1%less than the ideal value of about 0.4, then one can tolerate phaseerrors up to ϕ=0.4/200=1/500. If one leaves out of the quan-
tum Fourier transform circuit all controlled-phase gates e
πininj/2|i−j|
with|i−j|>/lscript, the maximum phase error ϕthis can produce in any
term is ϕ=nπ/2/lscript, and therefore the probability will be within 1% of
its ideal value if 1 /2/lscript<1/(500 nπ).
The number nof Qbits in the input register might be as large as 3000
for problems of interest (factoring a 500-digit N). Consequently for all
practical purposes one can omit from the quantum Fourier transformall controlled-phase gates connecting Qbits that are more than about/lscript=22 wires apart in the circuit diagram. This has two major advan-
tages. Of crucial importance, quantum engineers will not have to pro-duce impossibly precise phase changes. Furthermore, the size of the cir-cuit executing the quantum Fourier transform has to grow only linearlywith large nrather than quadratically. Since nis likely to be of order
10
3for practical code breaking, this too is a signiﬁcant improvement.
3.10 Period finding and factoring
Since Shor’s period-ﬁnding quantum algorithm is always described asa factoring algorithm, we conclude this chapter by noting how periodﬁnding leads to factoring. We consider only the case relevant to RSAencryption, where one wants to factor the product of two large primes,
N=pq, although the connection between period ﬁnding and factoring
is more general.
If we have a way to determine periods (such as Shor’s algorithm)
and want to ﬁnd the large prime factors of N=pq, we pick a random

<<<PAGE 104>>>

3.10 PERIOD FINDING AND FACTORING 8 7
number acoprime to N. The odds that a random ahappens to be
a multiple of por of qare minuscule when pand qare enormous,
but if you are the worrying kind you can check that it isn’t, using theEuclidean algorithm. (In the overwhelmingly unlikely event that ais
a multiple of porqthen the Euclidean algorithm applied to aand N
will give you porqdirectly, and you will have factored N.) Using our
period-ﬁnding routine, we ﬁnd the order of ainG
pq: the smallest r
for which
ar≡1 (mod pq). (3.64)
We can use this information to factor Nif our choice of awas lucky in
two ways.
Suppose ﬁrst that we are fortunate enough to get an rthat is even.
We can then calculate
x=ar/2(mod pq) (3.65)
and note that
0≡x2−1≡(x−1)(x+1) (mod pq). (3.66)
Now x−1=ar/2−1 is not congruent to 0 modulo pq, since ris the
smallest power of acongruent to 1. Suppose in addition – our second
piece of good fortune – that
x+1=ar/2+1/negationslash≡0 (mod pq). (3.67)
In that case neither x−1 nor x+1 is divisible by N=pq, but (3.66)
tells us that their product is. Since pand qare prime this is possible
only if one of them, say p, divides x−1 and the other, q, divides
x+1. Because the only divisors of Nare pand q, it follows that pis
the greatest common divisor of Nand x−1, while qis the greatest
common divisor of Nand x+1. We can therefore ﬁnd porqby a
straightforward application of the Euclidean algorithm.
So it all comes down to the likelihood of our being lucky. We show in
Appendix M that the probability is at least 0.5 that a random number
ainGpqhas an order rthat is even with ar/2/negationslash≡− 1 (mod pq). So we
do not have to repeat the procedure an enormous number of times toachieve a very high probability of success. If you’re willing to acceptthe fact that you don’t have to try out very many random numbers a
in order to succeed, then this elementary argument is all you need toknow about why period ﬁnding enables you to factor N=pq. But if
you’re curious about why the probability of good fortune is so high,then you must contend with Appendix M, where I have constructed anelementary but rather elaborate argument, by condensing a fairly largebody of number-theoretic lore into the comparatively simple form itassumes when applied to the special case in which the number Nis the
product of two primes.

<<<PAGE 105>>>

Chapter 4
Searching with a quantum computer
4.1 The nature of the search
Suppose you know that exactly one n-bit integer satisﬁes a certain
condition, and suppose you have a black-boxed subroutine that actson the N=2
ndifferent n-bit integers, outputting 1 if the integer sat-
isﬁes the condition and 0 otherwise. In the absence of any other infor-mation, to ﬁnd the special integer you can do no better with a classicalcomputer than to apply the subroutine repeatedly to different randomnumbers until you hit on the special one. If you apply it to Mdifferent
integers the probability of your ﬁnding the special number is M/N.
You must test
1
2Ndifferent integers to have a 50% chance of success.
If, however, you have a quantum computer with a subroutine that
performs such a test, then you can ﬁnd the special integer with a prob-ability that is very close to 1 when Nis large, using a method that calls
the subroutine a number of times no greater than ( π/4)√
N.
This very general capability of quantum computers was discovered
by Lov Grover, and goes under the name of Grover’s search algorithm .
Shor’s period-ﬁnding algorithm and Grover’s search algorithm,together with their various modiﬁcations and extensions, constitutethe two masterpieces of quantum-computational software.
One can think of Grover’s black-boxed subroutine in various ways.
The subroutine might perform a mathematical calculation to determinewhether the input integer is the special one. Here is a simple example. Ifan odd number pcan be expressed as the sum of two squares, m
2+n2,
then since one of mornmust be even and the other odd, pmust be of
the form 4 k+1. It is a fairly elementary theorem of number theory that
ifpis aprime number of the form 4 k+1 then it can always be expressed
as the sum of two squares, and in exactly one way. (Thus 5 =4+1,
13=9+4, 17=16+1, 29=25+4, 37=36+1, 41=25+16,
53=49+4, 61=36+25, etc.) Given any such prime p, the simple-
minded way to ﬁnd the two squares is to take randomly selected integers
xwith 1 ≤x≤N, with Nthe largest integer less than√p/2, until
you ﬁnd the one for which/radicalbig
p−x2is an integer a.I f pis of the
order of a trillion, then following the simple-minded procedure youwould have to calculate/radicalbig
p−x2for nearly a million xto have a better
than even chance of succeeding. But using Grover’s procedure withan appropriately programmed quantum computer you could succeed
88

<<<PAGE 106>>>

4.2 THE GROVER ITERATION 8 9
with a probability of success extremely close to 1 by calling the quantum
subroutine that evaluated/radicalbig
p−x2fewer than a thousand times.
Mathematically well-informed friends tell me that for this particular
example there are ways to proceed with a classical computer that aremuch more efﬁcient than random testing, but the quantum algorithm to
be described below enables even mathematical ignoramuses, equipped
with a quantum computer, to do better than random testing by a fac-tor of 1 /√
N. And Grover’s algorithm will provide this speed-up on
arbitrary problems.
Alternatively, the black box could contain Qbits that have been
loaded with a body of data – for example alphabetically ordered namesand phone numbers – and one might be looking for the name that wentwith a particular phone number. It is with this kind of application inmind that Grover’s neat trick has been called searching a database.Using as precious a resource as Qbits, however, merely to store clas-sical information would be insanely extravagant, given our current oreven our currently foreseeable ability to manufacture Qbits. Finding aunique solution – or one of a small number of solutions, as described inSection 4.3 – to a tough mathematical puzzle seems a more promisingapplication.
4.2 The Grover iteration
Grover’s algorithm assumes that we have been given a quantum searchsubroutine that indicates, when presented with any n-bit integer x,
whether or not xis the special abeing sought, returning this informa-
tion as the value of a function f(x) satisfying
f(x)=0, x/negationslash=a; f(x)=1, x=a. (4.1)
Grover discovered a completely general way to do signiﬁcantly better
than the classical method of merely letting the subroutine operate ondifferent numbers from the list of 2
ncandidates until it produces the
output 1. The quantum-computational speed-up relies on the usualimplementation of the subroutine that calculates f, in the form of a
unitary transformation
Ufthat acts on an n-Qbit input register that
contains xand a 1-Qbit output register that is or is not ﬂipped from 0
to 1, depending on whether xis or is not the special number a:
Uf/parenleftbig
|x/angbracketrightn|y/angbracketright1/parenrightbig
=| x/angbracketrightn|y⊕f(x)/angbracketright1. (4.2)
An example of a simple circuit that has precisely this action is shown
in Figure 4.1. The ﬁgure can be viewed as providing a minimalistversion of Grover’s algorithm, reminiscent of the Bernstein–Vaziraniproblem (Section 2.4), though not susceptible to the special trick thatworked in that simpler case. In this minimalist example we are given ablack box containing the circuit depicted in Figure 4.1, but are not told

<<<PAGE 107>>>

9 0 SEARCHING WITH A QUANTUM COMPUTER
x
x
x
x
x4
3210x
x
x
x
x43210
y y + f (x)a = 10010
X
X
XX
XX
XFig 4.1 A possible
realization of a black boxthat executes the unitarytransformation
Uf(|x/angbracketrightn|y/angbracketright1)=
|x/angbracketrightn|y⊕f(x)/angbracketright1, where
f(x)=0,x/negationslash=a;
f(x)=1,x=a.The
input register has n=5
Qbits and the specialnumber ais 10010. The
6-Qbit gate in the center ofthe ﬁgure is aﬁve-fold-controlled-NOT ,which acts on thecomputational basis to ﬂipthe target bit if and only ifevery one of the ﬁvecontrol bits is in the state|1/angbracketright. The construction of
such a gate out of moreelementary gates is shownin Figures 4.4–4.7.
which of the ncontrol Qbits are acted on by NOT gates – information
speciﬁed by the unknown n-bit integer a. If there were nQbits in the
input register and the computer were classical, we could do no betterthan to try each of the N=2
npossible inputs until we found the one
for which the output register was ﬂipped. But using Grover’s algorithmwe can determine this information with probability quite close to 1, byinvoking the search subroutine no more than√
N=2n/2times – more
precisely ( π/4)√
Ntimes – when Nis large.
As in the Bernstein–Vazirani problem, it is useful to alter the ﬂip of
the state of the output register into an overall sign change, by trans-forming the 1-Qbit output register into the state
H|1/angbracketright=1√
2(|0/angbracketright−| 1/angbracketright) (4.3)
prior to the application of Uf. The action of Ufis then to multiply the
(n+1)-Qbit state by −1 if and only if x=a:
Uf(|x/angbracketright⊗H|1/angbracketright)=(−1)f(x)|x/angbracketright⊗H|1/angbracketright. (4.4)
In this form, the effect of Ufon the states |x/angbracketright⊗H|1/angbracketrightis exactly the
same as doing nothing at all to the 1-Qbit output register, while actingon the n-Qbit input register with an n-Qbit unitary transformation
V
that acts on the computational basis as follows:
V|x/angbracketright=(−1)f(x)|x/angbracketright=/braceleftbigg|x/angbracketright,x/negationslash=a,
−|a/angbracketright,x=a.(4.5)
Since Ufis linear, so is V. Acting on a general superposition |/Psi1/angbracketright=/summationtext
x|x/angbracketright/angbracketleftx|/Psi1/angbracketrightof computational basis states, Vchanges the sign of the
component of the state along |a/angbracketright, while leaving unchanged the com-
ponent orthogonal to |a/angbracketright:
V|/Psi1/angbracketright=|/Psi1/angbracketright−2|a/angbracketright/angbracketlefta|/Psi1/angbracketright. (4.6)

<<<PAGE 108>>>

4.2 THE GROVER ITERATION 9 1
So we can write Vas
V=1−2|a/angbracketright/angbracketlefta|, (4.7)
where |a/angbracketright/angbracketlefta|is the projection operator1on the state |a/angbracketright.
As we shall see, Ufis the only unitary transformation appearing
in Grover’s algorithm that acts as anything other than the identityon the output register. Because the output register starts in the state
H|1/angbracketright, unentangled with the input register, and because Ufmaintains
the output register in this particular state, the output register remainsunentangled with the input register and in the state
H|1/angbracketrightthroughout
Grover’s algorithm. We could continue to describe things in terms of
Ufand retain the 1-Qbit output register, expanding (4.6), for example,
to the form
Uf(|/Psi1/angbracketright⊗H|1/angbracketright)=[|/Psi1/angbracketright−2|a/angbracketright/angbracketlefta|/Psi1/angbracketright]⊗H|1/angbracketright. (4.8)
But it is simpler to suppress all explicit reference to the unaltered output
register, which is always unentangled with the input register and alwaysin the state
H|1/angbracketright. We simply replace the ( n+1)-Qbit unitary Ufwith
the n-Qbit unitary Vthat acts on the n-Qbit input register, and deﬁne
all other operators that appear in the algorithm only by their action onthe input register, with the implicit understanding that they act as theidentity on the output register.
To execute Grover’s algorithm, we once again initially transform
the n-Qbit input register into the uniform superposition of all possible
inputs,
|φ/angbracketright=
H⊗n|0/angbracketrightn=1
2n/22n−1/summationdisplay
x=0|x/angbracketrightn. (4.9)
In addition to V, Grover’s algorithm requires a second n-Qbit unitary
Wthat acts on the input register in a manner similar to V, but with a
ﬁxed form that does not depend on a. The unitary transformation W
preserves the component of any state along the standard state |φ/angbracketrightgiven
in (4.9), while changing the sign of its component orthogonal to |φ/angbracketright:
W=2|φ/angbracketright/angbracketleftφ|−1, (4.10)
where |φ/angbracketright/angbracketleftφ|is the projection operator on the state |φ/angbracketright. We defer to
Section 4.3 the not entirely obvious question of how to build Wout of
1- and 2-Qbit unitary gates.
Given implementations of Vand W, Grover’s algorithm is quite
straightforward. It consists of simply applying many times the product
WV to the input register, taken initially to be in the state |φ/angbracketright. Each
such application requires one invocation of the search subroutine.
1 This notation for projection operators is developed in Appendix A.

<<<PAGE 109>>>

9 2 SEARCHING WITH A QUANTUM COMPUTER
aqqWVa
f
=Vfa
aFig 4.2 Real linear
combinations of the specialstate|a/angbracketright, and the uniform
superposition|φ/angbracketright=2
−n/2/summationtext|x/angbracketright, deﬁne a
plane in which these twostates are very nearlyorthogonal. The state |a
⊥/angbracketright
in that plane is orthogonalto|a/angbracketright, and therefore makes
a small angle θwith|φ/angbracketright.
The unitary transformation
Vtakes any vector in the
plane into its reﬂection inthe line through the originalong|a
⊥/angbracketright,s oi tl e a v e s |a⊥/angbracketright
invariant. The unitarytransformation
Wtakes
any vector in the plane intoits reﬂection in the linethrough the origin along|φ/angbracketright, so it rotates |a
⊥/angbracketright
counterclockwise throughthe angle 2 θ. Therefore the
combined operation
WV
rotates |a⊥/angbracketright
counterclockwise through2θ, and since
WV is a
rotation it does the same toany vector in the plane.To see what is accomplished by repeatedly applying WV to the
initial state |φ/angbracketright, note that both VandWacting on either |φ/angbracketrightor|a/angbracketrightgive
linear combinations of these two states. Since /angbracketlefta|φ/angbracketright=/angbracketleftφ|a/angbracketright=1/2n/2,
whatever the value of a, the linear combinations have real coefﬁcients
and are given by
V|a/angbracketright=− | a/angbracketright, V|φ/angbracketright=|φ/angbracketright−2
2n/2|a/angbracketright;
(4.11)
W|φ/angbracketright=|φ/angbracketright, W|a/angbracketright=2
2n/2|φ/angbracketright−| /angbracketright a.
So if we start with the state |φ/angbracketrightand let any sequence of these two
operators act successively, the states that result will always remain inthe two-dimensional plane spanned by real linear combinations of |φ/angbracketright
and|a/angbracketright. Finding the result of repeated applications of
WV to the initial
state|φ/angbracketrightreduces to an exercise in plane geometry.
It follows from the form (4.9) of |φ/angbracketrightthat|φ/angbracketrightand|a/angbracketright, considered as
vectors in the plane of their real linear combinations, are very nearlyperpendicular, since the cosine of the angle γbetween them is given by
cosγ=/angbracketleft a|φ/angbracketright=2
−n/2=1/√
N, (4.12)
which is small when Nis large. It is convenient to deﬁne |a⊥/angbracketrightto be
the normalized real linear combination of |φ/angbracketrightand|a/angbracketrightthat is strictly
orthogonal to |a/angbracketrightand makes the small angle θ=π/2−γwith|φ/angbracketright,
as illustrated in Figures 4.2 and 4.3. Since
sinθ=cosγ=2−n/2=1/√
N, (4.13)
θis very accurately given by
θ≈2−n/2(4.14)
when√
Nis large.

<<<PAGE 110>>>

4.2 THE GROVER ITERATION 9 3
f
faa
WV
f
qq2
VqFig 4.3 Since the rotation
WV rotates any vector in
the plane of real linearcombinations of |a/angbracketrightand|φ/angbracketright
clockwise through an angle
2θ, it takes |φ/angbracketrightinto a vector
WV|φ/angbracketrightthat makes an angle
3θwith|a⊥/angbracketright. This can also
be seen directly from theseparate behaviors of
Vand
W:Vtakes|φ/angbracketrightinto its
mirror image in |a⊥/angbracketright, and
Wthen takes V|φ/angbracketrightinto its
mirror image in |φ/angbracketright.
Since Wleaves|φ/angbracketrightinvariant and reverses the direction of any vector
orthogonal to |φ/angbracketright, its geometrical action on any vector in the two-
dimensional plane containing |φ/angbracketright,|a/angbracketright,and|a⊥/angbracketrightis simply to replace
the vector by its reﬂection in the mirror line through the origin along|φ/angbracketright. On the other hand
Vreverses the direction of |a/angbracketrightwhile leaving any
vector orthogonal to |a/angbracketrightinvariant, so it acts on a general vector in the
two-dimensional plane by replacing it with its reﬂection in the mirrorline through the origin along |a
⊥/angbracketright. The product WV, being a product of
two two-dimensional reﬂections, is a two-dimensional rotation.2The
angle of that rotation is most easily seen by considering the effect of WV
on|a⊥/angbracketright(see Figure 4.2). The application of Vleaves |a⊥/angbracketrightinvariant,
and the subsequent action of Won|a⊥/angbracketrightreﬂects it in the line through
the origin along the direction of |φ/angbracketright. So the net effect of the rotation
WV on|a⊥/angbracketrightis to rotate |a⊥/angbracketrightpast|φ/angbracketrightthrough a total angle that is twice
the angle θbetween |a⊥/angbracketrightand|φ/angbracketright.
Because WV is a rotation, the result of applying it to any other
vector in the plane is also to rotate that vector through the angle 2 θ
in the direction from |a⊥/angbracketrightto|φ/angbracketright. So applying WV to the initial state
|φ/angbracketrightgives a vector rotated away from |a⊥/angbracketrightby 3θ, since |φ/angbracketrightis already
rotated away from |a⊥/angbracketrightbyθ(Figure 4.3). Applying WV a second time
results in a vector rotated away from |a⊥/angbracketrightby 5θ, and each subsequent
application of WV increases the angle between the ﬁnal state and |a⊥/angbracketright
2 A two-dimensional reﬂection can be achieved by adding a third dimension
perpendicular to the plane and performing a 180◦rotation with the mirror
line as axis. This reverses the irrelevant direction orthogonal to the plane.The product of two such three-dimensional rotations is also a rotation, takesthe plane into itself, and does not reverse the third orthogonal direction, so itis a two-dimensional rotation in the plane.

<<<PAGE 111>>>

9 4 SEARCHING WITH A QUANTUM COMPUTER
by another 2 θ. Since θis very close to 2−n/2, after an integral number
of applications as close as possible to
(π/4)2n/2, (4.15)
the resulting state will be very nearly orthogonal to |a⊥/angbracketrightin the plane
spanned by |φ/angbracketrightand|a/angbracketright– i.e. it will be very nearly equal to |a/angbracketrightitself.
Consequently a measurement of the input register in the computa-
tional basis will yield awith a probability very close to 1. We can check
to see whether we have been successful by “querying the oracle.” If
f(a) is 1, as it will be with very high probability, this conﬁrms that we
have found the desired a. If we were unlucky we might have to repeat
the whole procedure a few more times before achieving success.
4.3 How to construct W
It remains to specify how to construct Wout of 1- and 2-Qbit unitary
gates. Now −Wworks just as well as Wfor purposes of the search
algorithm, since it leads to a ﬁnal state that differs, if at all, only by aharmless overall minus sign. It follows from (4.9) and (4.10) and thefact that
H⊗nis its own inverse that
−W=1−2|φ/angbracketright/angbracketleftφ|=H⊗n(1−2|00...00/angbracketright/angbracketleft00...00|)H⊗n,(4.16)
so we need a gate that acts as the identity on every computational-
basis state except |00...00/angbracketright, which it multiplies by −1. This is just the
action of an ( n−1)-fold-controlled- Zgate, with the roles of the 1-Qbit
states|0/angbracketrightand|1/angbracketrightinterchanged. This interchange is accomplished by
sandwiching the ( n−1)-fold-controlled- Zbetween X⊗ngates, and we
therefore have
−W=H⊗nX⊗n(cn−1Z)X⊗nH⊗n. (4.17)
Z Z=Fig 4.4 The
n-fold-controlled- Z
transformation, cnZ, acts
as the identity on states ofthe computational basisunless all ncontrol Qbits
are in the state |1/angbracketright, when it
acts on the target Qbit as
Z.
Here it is constructed outof doubly controlled gates,using an additional n−2
ancilliary Qbits, all initiallyin the state |0/angbracketright. One uses
2(n−2)
c2X(Toffoli)
gates and a c2Zgate. The
construction is illustratedfor the case n=5. The top
three wires are the threeancillary Qbits. The nextﬁve wires from the top arethe ﬁve control Qbits, andthe bottom wire is thetarget Qbit. One easilyveriﬁes (by applying thecircuit to computational-basis states, with each ofthe ancillary Qbits in thestate|0/angbracketright) that
Zacts on the
target Qbit if and only ifevery one of the ﬁvecontrol Qbits is in the state|1/angbracketright. The Toffoli gates are
symmetrically disposed onboth sides of the diagramto ensure that at the end ofthe process each of thethree ancillary Qbits is set
back to its initial state |0/angbracketright.
This is essential if theancillary Qbits are not tobecome entangled with theQbits on which the Groveriteration acts, representedby the bottom six wires.

<<<PAGE 112>>>

4.3 HOW TO CONSTRUCT W 95
Z=
ZZ
Fig 4.5 An improved version of Figure 4.4, with twice as many gates.
Gates have been added on the left and right to ensure that the circuitworks for arbitrary initial computational-basis states of the three
ancillary Qbits at the top, restoring them to their initial states at theend of the computation. To see this note that because Toffoli gates or
c2Zgates are their own inverses, the circuit acts as the identity on
those computational-basis states of all nine Qbits in which any one ofthe ﬁve control Qbits (second through sixth wires from the bottom) isin the state |0/angbracketright, regardless of the computational-basis states of the
other Qbits. This is because, as an examination of the ﬁgure reveals,replacing the gate governed by any one of the ﬁve control Qbits by theidentity always results in a pairwise cancellation of all the remaininggates. It remains only to conﬁrm that when all ﬁve control Qbits are inthe state |1/angbracketright, the circuit acts as
Zon the target Qbit at the bottom, and
the state of the three ancillary Qbits at the top is unchanged. This isestablished in Figure 4.6, which shows the operation of the gates inFigure 4.5 when the ﬁve control Qbits are all in the state |1/angbracketright. Because
X=HZH one can also use this circuit to produce a multiply-
controlled-NOT gate, by applying Hadamard gates to the bottom wireon the far right and left.
We can construct Wby constructing cn−1Z, the ( n−1)-fold-
controlled- Z.
Figure 4.4 shows a straightforward but not terribly efﬁcient way to
make a cn−1Zgate for the case n=6. We use n−3 ancillary Qbits, all
initially in the state |0/angbracketright,2 (n−3)c2X(Toffoli) gates, and one c2Zgate.
As explained in Section 2.6, these can all be built out of 1- and 2-Qbitgates. It is essential for the success of the algorithm that each ancillaryQbit be restored to its initial state |0/angbracketright, since our analysis of the Grover
algorithm assumes that the input and output registers have states oftheir own, unentangled with any other Qbits, after each application of
WandV.

<<<PAGE 113>>>

9 6 SEARCHING WITH A QUANTUM COMPUTER
Z
==Z(a)
(b)Fig 4.6 Part (a)
reproduces what remainsof Figure 4.5 when all ﬁvecontrol Qbits are in thestate|1/angbracketright. One easily veriﬁes
that two identical cNOTgates, separated by a NOTacting on their controlQbit, have exactly the sameaction on thecomputational basis asNOT gates acting on boththe control and targetQbits. As a result each ofthe two identical sets of ﬁveadjacent gates acting on thethree ancillary Qbits at thetop of part (a) reducessimply to three NOT gates,as shown in part (b).Making this furthersimpliﬁcation in part (a),note that because each ofthe three ancillary Qbits isacted on by two NOTgates, its state is unaltered.The two NOT gates actingon the upper wire alsoensure that precisely one ofthe two
cZgates applies Z
to the bottom Qbit,whatever the state of theupper wire.The construction of Figure 4.4 is rather expensive in Qbits, requir-
ing n−3 ancillas to apply the algorithm to an n-bit set of possibilities
for the special number a. At a cost of four times as many Toffoli gates,
one can reduce the number of ancillas to a single one, regardless of thesize of n. The way to do this is developed in Figures 4.5–4.7. Figures 4.5
and 4.6 show how nearly doubling the number of gates makes it possiblefor the construction of Figure 4.4 to work for arbitrary initial states of
the ancillas. Figure 4.7 then shows how, by an additional doubling, onecan, with the aid of a single ancilla, divide an n-fold-controlled- Zinto
two multiply-controlled-NOT gates and two multiply-controlled- Z
gates, each acting on about
1
2nQbits. (Since X=HZH , one can convert
a multiply-controlled- Zgate into a multiply-controlled-NOT gate by
applying Hadamard gates to the target Qbit at the beginning and endof the circuit.) The multiply-controlled- Zgates in Figure 4.7 are able
nondisruptively to use the control Qbits of the multiply-controlled-NOT gates as their ancillary Qbits in the construction of Figure 4.5.And the multiply-controlled-NOT gates in Figure 4.7 can make similaruse of the control Qbits of the multiply-controlled- Zgates.
4.4 Generalization to several special numbers
If there are several special numbers, essentially the same algorithm can
be used to ﬁnd one of them, if we know how many there are. Thefunction fin (4.1) now becomes
f(x)=0,x/negationslash=a
1,... , am; f(x)=1,x=a1,... , am.
(4.18)

<<<PAGE 114>>>

4.4 GENERALIZATION TO SEVERAL SPECIAL NUMBERS 9 7
=
ZZ Z
Fig 4.7 The identity illustrated by the circuit is easily conﬁrmed.
There is only one ancilla, whose state is left unchanged. Byintroducing circuits of the form in Figure 4.5 into this circuit one canproduce
cnZorcnXgates with the aid of just a single ancilla. (Since
X=HZH Figure 4.5 works for either type.) In constructing each of
the multiply-controlled-NOT gates in Figure 4.7 out of Toffoli gates,one can borrow the control Qbits of the multiply-controlled- Zgates to
use as ancillary Qbits in the expansions of Figure 4.5, since thoseexpansions work whatever the state of their ancillary Qbits, and restorethat state to its original form. For the same reasons one can alsoborrow the control Qbits of the multiply-controlled-NOT gates toconstruct the multiply-controlled- Zgates.
The n-Qbit unitary transformation Vextracted from (4.4) becomes
one whose action on computational-basis states in the input register isgiven by
V|x/angbracketright=| x/angbracketright,x/negationslash=a1,... , am; V|x/angbracketright=− | x/angbracketright,x=a1,... , am.
(4.19)
If we replace the state |a/angbracketrightby
|ψ/angbracketright=1√mm/summationdisplay
i=1|ai/angbracketright, (4.20)
then starting with |φ/angbracketright, which continues to have the form (4.9), the
transformations Vand Wnow keep the state of the input register in
the two-dimensional plane spanned by the real linear combinations of|ψ/angbracketrightand|φ/angbracketright. The unitary transformation
Vchanges the sign of |ψ/angbracketrightbut
preserves the linear combination of |φ/angbracketrightand|ψ/angbracketrightorthogonal to |ψ/angbracketright,s o
Vis now a reﬂection in the line through the origin along the vector
|ψ⊥/angbracketrightperpendicular to |ψ/angbracketrightin the plane. Everything else is just as in the
case of a single special number except that now the angle /Theta1between
|ψ⊥/angbracketrightand|φ/angbracketrightsatisﬁes
sin/Theta1=cos(π/2−/Theta1)=/angbracketleftψ|φ/angbracketright=/radicalbig
m/2n. (4.21)

<<<PAGE 115>>>

9 8 SEARCHING WITH A QUANTUM COMPUTER
When m/2n<<1, we can arrive at a state very close to |ψ/angbracketrightwith
(π/4)2n/2/√m (4.22)
applications of WV. A measurement then gives us, with a probability
very close to 1, a random one of the special values ai. Note that the
mean number of invocations of the subroutine decreases only as 1 /√m
with the number mof marked items, in contrast to a classical search,
for which doubling the number of acceptable solutions would halve thetime of the search. When m/2
nis not small we have to reexamine the ex-
pression (4.22) for the optimal number of iterations, but at that point the
quantum search offers little signiﬁcant advantage over a classical one.
We must know how many special numbers there are for the procedure
to work, since we have to know how many times to do the Groveriteration before making our measurement. By exploiting the fact thatthe Grover iteration is periodic, restoring the initial state after aboutπ2
n/2/√miterations, it is possible to combine Grover iterations with a
clever application of the quantum Fourier transform to learn the valueofmwith enough accuracy to enable one then to apply the Grover
iteration the right number of times to ensure a high probability ofsuccess, even when mis not known at the start.
4.5 Searching for one out of four items
The simplest nontrivial application of Grover’s algorithm is to the case
n=2, or N=4. (When n=1 a single invocation of the subroutine
sufﬁces to identify aeven with a classical computer.) When n=2,
(4.13) tells us that sin θ=1
2,s oθ=30◦. Consequently 3 θ=90◦, and
the probability of identifying awith a single invocation of the subrou-
tine is exactly 1.
This is a signiﬁcant improvement on the classical computer, with
which one can do no better than trying each of the four possibilitiesfor ain random order. It is equally likely that the marked item will
be the ﬁrst, second, third, or fourth on the list. Since the probabilityis
1
4that the marked item is ﬁrst on the list,1
4that it is second, and
1
4+1
4=1
2that it is third or fourth, the mean number of attempts
is1
4×1+1
4×2+1
2×3=21
4.(It is not necessary to make a fourth
attempt, since if the ﬁrst three attempts fail to produce a, then one
knows that ais the one remaining untested number.)
The case n=2 is also special in that one does not have to resort
to the elaborate procedure speciﬁed in Figures 4.4–4.7 to produce then-fold-controlled- Zgate. A single Toffoli gate sandwiched between
Hadamards on the target Qbit does the job.

<<<PAGE 116>>>

Chapter 5
Quantum error correction
5.1 The miracle of quantum error correction
Correcting errors might sound like a dreary practical problem, of little
aesthetic or conceptual interest. But aside from being of crucial im-portance for the feasibility of quantum computation, it is also one ofthe most beautiful and surprising parts of the subject. The surpriseis that error correction is possible at all, since the only way to detecterrors is to make measurements, but measurement gates disruptivelyalter the states of the measured Qbits, apparently making things evenworse. “Quantum error correction” would seem to be an oxymoron.The beauty lies in the ingenious ways that people have found to getaround this apparently insuperable obstacle.
The discovery in 1995 of quantum error correction by Peter Shor
and, independently, Andrew Steane had an enormous impact on theprospects for actual quantum computation. It changed the dream ofbuilding a quantum computer capable of useful computation from aclearly unattainable vision to a program that poses an enormous butnot necessarily insuperable technological challenge.
Error correction is not a major issue for classical computation. In a
classical computer the physical systems that embody individual bits –the Cbits – are immense on the atomic scale. The two states of a Cbitrepresenting 0 and 1 are so grossly different that the probability isinﬁnitesimal for ﬂipping from one to the other as a result of thermalﬂuctuations, mechanical vibrations, or other irrelevant extraneous in-teractions.
Error correction does become important, even classically, in the
transmission of information over large distances, because the fartherthe signal travels, the more it attenuates. One can deal with this in avariety of straightforward or ingenious ways. One of the crudest is toencode each logical bit in three actual bits, replacing |0/angbracketrightand|1/angbracketrightby the
codewords
|
0/angbracketright=| 0/angbracketright|0/angbracketright|0/angbracketright=| 000/angbracketright, |1/angbracketright=| 1/angbracketright|1/angbracketright|1/angbracketright=| 111/angbracketright. (5.1)
One can then monitor each codeword, checking for ﬂips in any of
the individual Cbits and restoring them by applying the principle ofmajority rule whenever a ﬂip is detected. Monitoring has to take place
99

<<<PAGE 117>>>

1 0 0 QUANTUM ERROR CORRECTION
often enough to make negligible the probability that more than a single
bit has ﬂipped in a single codeword between inspections.
Quantum error correction also uses multi-Qbit codewords and also
requires monitoring at a rate that renders certain kinds of compounderrors highly improbable. But there are several ways in which error
correction in a quantum computer is quite different.
(a)A quantum computer, unlike a classical computer, requires error
correction. The physical Qbits are individual atomic-scale physicalsystems such as atoms, photons, trapped ions, or nuclear magneticmoments. Any coupling to anything not under the explicit con-trol of the computer and its program can substantially disrupt thestate associated with those Qbits, entangling them with computa-tionally irrelevant features of the computer or the world outsidethe computer, thereby destroying the computation. For a quantumcomputer to work without error correction, each Qbit would have tobe impossibly well isolated from irrelevant interactions with otherparts of the computer and anything else in its environment.
(b)In contrast to classical error correction, checking for errors in a
quantum computer is problematic. The obvious way to monitor aQbit is to measure it. But the result of measuring a Qbit is to alterits state, if it has one of its own, and, more generally, to destroyits quantum correlations with other Qbits with which it might beentangled. Such disruptions are stochastic – i.e. unpredictable –and introduce major errors of their own. One must turn to lessobvious forms of monitoring.
(c)Bit ﬂips are not the only errors. There are entirely nonclassical
sources of trouble. For example phase errors, such as the alterationof|0/angbracketright+| 1/angbracketrightto|0/angbracketright−| 1/angbracketright, can be just as damaging.
(d)Unlike the discrete all-or-nothing bit-ﬂip errors suffered by Cbits,
errors in the state of Qbits grow continuously out of their uncor-rupted state.
We begin our discussion of error correction by examining in
Section 5.2 a simple model of quantum error correction that workswhen the possible errors are artiﬁcially limited to a few speciﬁc kindsof disruption. Although this is clearly unrealistic, the error-correctionprocedure is easy to follow. It also introduces in a simple setting mostof the tricks that continue to work in the more realistic case.
5.2 A simplified example
Much of the ﬂavor of quantum error correction is conveyed by anartiﬁcially simple model in which the only errors a collection of Qbitsis allowed to experience are the classically meaningful errors: random

<<<PAGE 118>>>

5.2 A SIMPLIFIED EXAMPLE 1 0 1
0 1b a +
0
0000 111+b aFig 5.1 A unitary circuit
that encodes the 1-Qbitstateα|0/angbracketright+β|1/angbracketrightinto the
3-Qbit code stateα|000/angbracketright+β|111/angbracketright,using
two cNOT gates and two
other Qbits each initially in
the state |0/angbracketright. The circuit
clearly works for thecomputational-basis states|0/angbracketrightand|1/angbracketright, and therefore,
by linearity, it works forarbitrary superpositions.
ﬂips of individual Qbits. We shall examine the more general possibilities
for quantum errors in Section 5.3 below.
Bit-ﬂip errors in a computation can be modeled by a circuit that
differs from the ideal error-free circuit only in the occasional presenceof extraneous 1-Qbit NOT gates. If such randomly occurring error-producing NOT gates are sufﬁciently rare, then since the only allowederrors are bit-ﬂip errors, one might hope to be able to correct thecorruptions they introduce by tripling the number of Qbits and usingprecisely the 3-Qbit code (5.1) that corrects for bit-ﬂip errors in theclassical case. Because of the disruptive effect of measurement gatesin diagnosing errors, it is not at all clear that such a 3-Qbit code canbe effective for bit-ﬂip errors in the quantum case. It can neverthelessbe made to work, though the way in which one does the encoding andperforms the error correction is much subtler for Qbits than it is forCbits.
To begin with, there is the question of encoding. Classically one
merely replaces each of the two computational-basis states |x/angbracketrightby the
codeword states |
x/angbracketright=| x/angbracketright|x/angbracketright|x/angbracketright,for x=0 or 1. Qbits, however, can
also be in superpositions α|0/angbracketright+β|1/angbracketright, and one requires a circuit that
automatically encodes this into α|0/angbracketright+β|1/angbracketright=α|0/angbracketright|0/angbracketright|0/angbracketright+β|1/angbracketright|1/angbracketright|1/angbracketright
for arbitrary αandβ, in the absence of any knowledge of what the values
ofαandβmight be. This can be done with two cNOT gates that target
two additional Qbits initially both in the state |0/angbracketright, as illustrated in
Figure 5.1:
α|0/angbracketright+β|1/angbracketright=α|0/angbracketright|0/angbracketright|0/angbracketright+β|1/angbracketright|1/angbracketright|1/angbracketright= C21C20/parenleftbig
α|0/angbracketright+β|1/angbracketright/parenrightbig
|0/angbracketright|0/angbracketright.
(5.2)
Having produced such a 3-Qbit codeword state, we must then guard
against its corruption by the possible action of an extraneous NOTgate that acts on at most one of the three Qbits, as illustrated inFigure 5.2. This is easily done for Cbits, for which there are onlytwo possible uncorrupted initial states, |000/angbracketrightand|111/angbracketright, and examining
them is unproblematic. To see whether either initial state has been cor-rupted by the action of a single NOT gate, one nondisruptively reads

<<<PAGE 119>>>

1 0 2 QUANTUM ERROR CORRECTION
0 1b a+
0
0
000 111+b a
random flip o f
at most 1 Q bitX
Xor
or
XFig 5.2 The encoded state
of Figure 5.1 may or maynot be corrupted by theaction of a singleextraneous NOT gate. Theerror-inducing gates aredepicted in a lighter font –Xinstead of
X– and inside
a noisy-looking corruptedbox.
the three Cbits. If this reveals all three Cbits to be in the same state,
there is no corruption to correct. If one of them is found to be in adifferent state from the other two, that particular Cbit is the one thatwas acted upon by the extraneous NOT gate, and applying a secondNOT gate to that Cbit restores the initial state.
One cannot, however, nondisruptively “read” the state of a collec-
tion of Qbits. The only way to extract information is by the action ofmeasurement gates. But measuring any of the three Qbits immediatelydestroys the uncorrupted superposition
|/Psi1/angbracketright=α|000/angbracketright+β|111/angbracketright, (5.3)
converting it either to |000/angbracketright(with probability |α|
2)o rt o |111/angbracketright(with
probability |β|2). There is a similar coherence-destroying effect on
each of the three possible corrupted states,
|/Psi10/angbracketright= X0|/Psi1/angbracketright=α|001/angbracketright+β|110/angbracketright,
|/Psi11/angbracketright= X1|/Psi1/angbracketright=α|010/angbracketright+β|101/angbracketright, (5.4)
|/Psi12/angbracketright= X2|/Psi1/angbracketright=α|100/angbracketright+β|011/angbracketright,
obliterating any dependence of the post-measurement state on the com-
plex amplitudes αandβ. This might appear (and for some time was
thought) to be the end of the story: quantum error correction is im-possible because of the disruptive effect of the measurement needed todiagnose the error.
But there are subtler ways to extract the information needed to di-
agnose and correct possible errors. Although there continues to be adisruption in these reﬁned procedures, the damaging effects are shiftedfrom the codeword Qbits to certain ancillary Qbits. By coupling thecodeword Qbits to these ancillary Qbits with appropriate 2-Qbit unitary

<<<PAGE 120>>>

5.2 A SIMPLIFIED EXAMPLE 1 0 3
gates, and then applying measurement gates only to the ancillas, one can
extract information about certain relations prevailing among the code-
word Qbits. This more limited information turns out to be enough todiagnose and correct certain errors in a coherence-preserving manner,without revealing anything about the original uncorrupted codewordstate. Acquiring no information about the uncorrupted state is a neces-sary restriction on any error-correction procedure capable of perfectlyrestoring the uncorrupted state. If one could get even partial infor-mation about the structure of a state without disrupting it, one couldcontinue collecting additional information nondisruptively until onewas well on the way to violating the no-cloning theorem.
Note that all possible forms for the uncorrupted 3-Qbit codeword
(5.3) – given by assigning all possible values to the amplitudes αandβ–
lie in a two-dimensional subspace of the full eight-dimensional spacecontaining all possible 3-Qbit states. Furthermore, each of the threeallowed corruptions (5.4) also lies in a two-dimensional subspace ofthe full 3-Qbit space, and the three subspaces containing the threeallowed corruptions are each orthogonal to the subspace containingthe uncorrupted codeword, and orthogonal to each other. This turnsout to be crucial to the success of the enterprise.
More generally, if we wanted to use an n-Qbit codeword in a model
in which the only allowed errors were ﬂips of a single Qbit, then wewould require 2(1 +n) dimensions to accommodate the n+1 mutually
orthogonal two-dimensional subspaces associated with a general un-corrupted state and its ndifferent 1-Qbit corruptions. Since all possible
states of nQbits span a 2
n-dimensional space, a necessary condition
for an n-Qbit bit-ﬂip-error-correcting code to be possible is
2n−1≥1+n. (5.5)
The smallest nsatisfying (5.5) is n=3, for which it holds as an equality.
This shows that the 3-Qbit code is, in this sense, perfect for the purposeof correcting errors limited to ﬂips of a single Qbit.
Figure 5.3 shows that 3-Qbit codewords, as well as meeting this
necessary condition for the correction of quantum bit-ﬂip errors, actu-ally do permit it to be carried out. The error detection and correctionrequires two additional ancillary Qbits (the upper two wires), initiallyboth in the state |0/angbracketright. Both ancillas are targeted by pairs of cNOT gates
controlled by subsets of the three codeword Qbits. Note ﬁrst that ifthe 3-Qbit codeword has not been corrupted, so its state remains (5.3),then both the ancillary Qbits remain in the state |0/angbracketrightafter the action of
the cNOT gates, since the term |000/angbracketrightin the codeword results in none
of the target Qbits being ﬂipped, while the term |111/angbracketrightresults in both
of the target Qbits being ﬂipped twice, which is equivalent to no ﬂip.
In a similar way each of the three corruptions (5.4) results in a
different unique ﬁnal state for the ancillary Qbits. The ﬁrst of those

<<<PAGE 121>>>

1 0 4 QUANTUM ERROR CORRECTION
Mx
My
random flip of
atm o s t1Q bit0
0
000 +a
111b000 +a
111b
xyxyX
Xor
or
Xyx
XxyX
0 = 1
1 = 0X
~~~
~
Fig 5.3 How to detect and correct the three possible single-bit-ﬂip
errors shown in Figure 5.2. One requires two ancillary Qbits (the uppertwo wires), each initially in the state |0/angbracketright, coupled to the codeword
Qbits by cNOT gates. After the cNOT gates have acted each ancilla ismeasured. If both measurements give 0, then none of the erroneousNOT gates on the left have acted and none of the error-correctingNOT gates on the right need to be applied. If the upper measurementgate shows x=1 and the lower one shows y=0, then the uppermost
of the three erroneous NOT gates has acted on the left. Its action isundone by applying the uppermost of the three NOT gates on theright. The other two possible 1-Qbit errors are similarly corrected.
corruptions results in |0/angbracketrightfor the upper ancilla and |1/angbracketrightfor the lower,
since either term in the superposition α|001/angbracketright+β|110/angbracketrightresults in zero
or two ﬂips for the upper ancilla, and a single ﬂip for the lower ancilla.The next form in (5.4) produces a single ﬂip for both ancillas, resultingin|1/angbracketrightfor both. The third results in |1/angbracketrightfor the upper and |0/angbracketrightfor the
lower ancilla.
So if the two ancillary Qbits are measured after the cNOT gates
have acted, the four possible readings, 00, 01, 10, and 11, of the two

<<<PAGE 122>>>

5.2 A SIMPLIFIED EXAMPLE 1 0 5
measurement gates reveal whether or not a random one of the codeword
Qbits has been ﬂipped and, in the event of a ﬂip, which of the three hassuffered it. On the basis of this information one can either accept thecodeword as uncorrupted or apply a NOT gate to the Qbit that has beenidentiﬁed as the ﬂipped one, thereby restoring the initial uncorruptedstate. One easily conﬁrms that this is precisely what is accomplishedby the NOT gates on the extreme right of Figure 5.3.
This accomplishes what any valid quantum error-correction pro-
cedure must do: it restores the original uncorrupted state without re-vealing any information whatever about what the form of that state –the particular values of the amplitudes αandβ– might actually be.
The procedure succeeds in preserving the superposition by extractinginformation only about correlations among the Qbits making up thecodeword, without ever extracting information about individual Qbits.Working only with correlations makes it possible to apply a single lineartest that works equally well for diagnosing 1-Qbit errors in either |000/angbracketright
or|111/angbracketright, and therefore also works for any superposition of those states.
This simple example of quantum error correction requires the use
of measurement gates to diagnose the error. The outputs of the mea-surement gates are noted, and then used to determine which, if any, of acollection of error-correcting NOT gates should be applied. The pro-cedure can be automated into a bigger quantum circuit that eliminates(or almost eliminates) the need to use measurement gates combinedwith unitary gates, which are or are not applied depending on the read-ings of the measurement gates. This can be achieved by a combinationof cNOT and Toffoli gates, controlled by the ancillary Qbits, as shownin Figure 5.4.
Replacing measurement gates by additional cNOT gates does not
entirely eliminate the need for measurement, because at the end of theprocess the state of the ancillary Qbits will depend on the character ofthe error and will in general no longer be the state |0/angbracketright|0/angbracketrightwith which the
error-correction procedure starts. If one wishes to reuse these ancillaryQbits for further error correction, it is necessary to reset them to theirinitial state |0/angbracketright|0/angbracketright. This can efﬁciently be done by measuring them and
applying the appropriate NOT gates if either is found to be in the state|1/angbracketright. Thus measurement gates followed by NOT gates that depend on
the measurement outcome are still needed to prepare the circuit for apossible future error correction.
This procedure (automated or not) will continue to work even when
the codeword Qbits are entangled with many other codeword Qbits, asthey will be in the course of a nontrivial computation. In such a casethe codeword Qbits have no state of their own, the state of all the manycodeword Qbits being of the form
α|000/angbracketright|/Psi1/angbracketright+β|111/angbracketright|/Phi1/angbracketright, (5.6)

<<<PAGE 123>>>

1 0 6 QUANTUM ERROR CORRECTION
0
0
random flip of
at most 1 Q bit111b000 +a
111b000 +aX
Xor
or
XΨ
Fig 5.4 Automation of the error-correction process of Figure 5.3. The
three controlled gates on the right – one of them a doubly controlled
Toffoli gate with multiple targets – have precisely the same
error-correcting effect on the three codeword Qbits as does theapplication of NOT gates contingent on measurement outcomes inFigure 5.3. The ﬁnal state |/Psi1/angbracketrightof the ancillas (which is also the state
that determines the action of the three controlled gates on the right) is|00/angbracketrightif none of the erroneous NOT gates on the left has acted. It is |10/angbracketright
if only the upper erroneous NOT gate has acted, |11/angbracketrightif only the
middle one has acted, and |01/angbracketrightif only the lower one has acted.
with the error correction applied to the three Qbits on the left.
One easily conﬁrms that the added complication of entanglementwith other Qbits has no effect on the validity of the error-correctionprocedure.
There is an alternative way of representing the use of cNOT gates in
Figure 5.3 to diagnose the error, which is useful in correcting quantum
errors in more realistic cases. The alternative point of view is basedon the easily conﬁrmed fact that the uncorrupted state (5.3) is leftunaltered by either of the operators
Z2Z1and Z1Z0, while the three
corruptions (5.4) are each eigenstates of Z2Z1and Z1Z0with distinct

<<<PAGE 124>>>

5.2 A SIMPLIFIED EXAMPLE 1 0 7
Table 5.1. Two operators that diagnose the error syndrome
for the 3-Qbit code that protects against bit-ﬂip errors. Thefour entries in each of the two rows indicate whether theoperator for that row commutes ( +) or anticommutes ( −) with
the operators at the top of the four columns
X2 X1 X0 1
Z2Z1 −−+ +
Z1Z0 +−− +
sets of eigenvalues: 1 and −1 in the case of |/Psi10/angbracketright;−1 and−1 in the case
of|/Psi11/angbracketright; and−1 and 1 in the case of |/Psi12/angbracketright.
While these last three facts can be conﬁrmed directly from the ex-
plicit forms of |/Psi10/angbracketright,|/Psi11/angbracketright, and|/Psi12/angbracketrighton the right of (5.4), it is worth
noting, for purposes of comparison with some of the more complexcases that follow, that they also follow from the facts that
Z2Z1and
Z1Z0act as the identity on the uncorrupted state |/Psi1/angbracketright, that the cor-
rupted states are of the form |/Psi1j/angbracketright= Xj|/Psi1/angbracketright, and that Xjcommutes
with Ziwhen i/negationslash=j, while Xjanticommutes with Zj:ZjXj=− XjZj.
The resulting pattern of commutations (+) or anticommutations ( −)
is summarized in Table 5.1.
Thus the joint eigenvalues of the commuting operators Z2Z1and
Z1Z0distinguish among the uncorrupted state and each of the three
possible corruptions. A procedure that takes advantage of this bysandwiching controlled
Z2Z1and controlled Z1Z0gates between
Hadamards acting on the control Qbits is shown in Figure 5.5.Although it takes a little thought to conﬁrm directly from the ﬁg-ure that Figure 5.5 does indeed accomplish error correction – we shallwork this out in Section 5.4 as a special case of a much more gen-eral procedure – one can conﬁrm that it does by simply noting thatFigure 5.5 is mathematically equivalent to Figure 5.3. This equiva-lence follows from the facts that
X=HZH , that H2=1, and that the
action of controlled- Zis unaltered by exchanging the target and control
Qbits.
This oversimpliﬁed example, in which only bit-ﬂip errors are al-
lowed, illustrates most of the features of quantum error correction thatone encounters in more realistic cases. The more general procedureis complicated by the fact that, as noted above and made precise inSection 5.3 below, the general error a Qbit can experience is morecomplicated than just a single bit ﬂip. As a result, one needs codewordscontaining more than three Qbits to correct general single-Qbit errors,and one requires more complicated diagnostic and corrective proce-dures than those of Figures 5.3–5.5, involving more than just a pairof ancillary Qbits. But although the codewords and error-correcting

<<<PAGE 125>>>

1 0 8 QUANTUM ERROR CORRECTION
random flip of
at most 1 Q bit0
0Mx
My
yx
000 +a
111b000 +a
111b
xyxyX
Xor
or
XH
HH
H
Z
Z XxyXX
0 = 1
1 = 0Z
Z
~~~~
Fig 5.5 An apparently unnecessary complication of the
error-correcting circuit in Figure 5.3, which transforms it into themore general form described in Section 5.4. The circuit is equivalentto that in Figure 5.3: (1) the cNOT gates in Figure 5.3 can be replacedby controlled- Zgates if Hadamard gates act on each ancilla before and
after the controlled gates act; (2) each of the four controlled- Zgates
acts in the same way if its control and target Qbits are interchanged;and (3) pairs of controlled gates with the same control Qbit and twodifferent targets can be combined into a single controlled gate withthat control Qbit and a 2-Qbit target operation that is just the productof the two 1-Qbit target operations. The part of the circuit betweenand including the pairs of Hadamards on the right and left is a simpleexample of the more complex error-diagnosing circuits that appear inFigures 5.8, 5.9, and N.2 (in Appendix N).
circuits are more elaborate, once we have identiﬁed the more general
form of quantum errors there are no further conceptual complicationsin understanding the kinds of procedures that can correct them.
The more general form Qbit errors can assume is discussed in
Section 5.3. Somewhat surprisingly, it turns out that the general 1-Qbit error can be viewed as a simple extension of what we have just

<<<PAGE 126>>>

5.3 THE PHYSICS OF ERROR GENERATION 1 0 9
described: in addition to the possibility of an extraneous Xgate acting
on the Qbit, there might also be an extraneous Zgate or an ext-
raneous Y=ZXgate. If we can diagnose and correct for each of these
three possible corruptions, then we can correct for arbitrary 1-Qbiterrors.
Section 5.4 describes a generalization of the diagnostic scheme we
have just exploited for extracting relational information about the Qbitsthat make up a codeword, by coupling groups of them to ancillaryQbits, which are then measured. It turns out that the operators neededto diagnose the error – generalizations of the operators
Z2Z1andZ1Z0
for the 3-Qbit code – are also useful for deﬁning the more generalcodewords.
In Section 5.5 we examine two of the most important n-Qbit codes
with n>3 that are able to correct general single-Qbit errors: the 5-
Qbit and 7-Qbit codes. The 5-Qbit code is the ideal code for general1-Qbit errors in the same way that the 3-Qbit code is ideal for bit-ﬂiperrors. The 7-Qbit code is more likely to be of practical interest, forreasons we shall describe. The earliest quantum error-correcting code –the 9-Qbit code discovered by Shor – is now of only historical interest,and is relegated to Appendix N.
5.3 The physics of error generation
Errors are not, of course, produced by extra gates accidentally appear-ing in a circuit, as in the oversimpliﬁed example of Section 5.2. Theyare produced by extraneous interactions with the world external to thecomputer or with computationally irrelevant degrees of freedom ofthe computer itself. Although one would like the state of the Qbits toevolve only under the action of the unitary transformations imposedby the gates of the computer, inevitably Qbits will interact, even if onlyweakly, with other physical systems or degrees of freedom having noth-ing to do with the computation in which the Qbits are participating.In a well-designed computer such spurious interactions will be keptto a minimum, but their disruptive effects on the quantum state ofthe Qbits can grow continuously from zero, in contrast to disruptiveeffects on Cbits, which have to exceed a large threshold before a Cbitcan change its state. In a quantum computer such spurious changes ofstate will eventually accumulate to the point where the calculation fallsapart, unless ongoing efforts are made to eliminate them.
To characterize the most general way in which a Qbit can be deﬂected
from its computational task, we must ﬁnally acknowledge that Qbits arenot the only things in the world that are described by quantum states.The quantum theory provides the most fundamental description wehave of everything in the world, and it describes everything in theworld – not just Qbits – by means of quantum states.

<<<PAGE 127>>>

1 1 0 QUANTUM ERROR CORRECTION
This spectacular expansion of the scope of quantum states might not
come as a complete surprise to the nonphysicist reader. I have stressedall along that the quantum state of a Qbit or a collection of Qbits is nota property carried by those Qbits, but a way of concisely summarizingeverything we know that has happened to them, to enable us to makestatistical predictions about the information we might then be able toextract from them. If quantum states are not properties inherent in thesystem they describe, but states of the knowledge we have managedto acquire about the prior history of the system – if they somehowincorporate fundamental aspects of how we exchange information withthe world outside of us – then they might indeed have an applicabilitygoing beyond the particular kinds of systems we have applied them toup until now.
Indeed, nowhere in this exposition of quantum computation has it
been necessary to refer to the individual character of the Qbits. Whetherthey are spinning electrons, polarized photons, atoms in cavities, orany number of other things, the quantum-mechanical description oftheir computational behavior has been exactly the same. So insofaras the assignment of quantum states to physical systems is a generalfeature of how we come to grips with the external world, it mightnot be unreasonable to assign a quantum state |e/angbracketrightto whatever part
of the world comes into interactive contact with the Qbit or Qbits –their environment . We will not make any speciﬁc assumptions about the
character of that environment or of the quantum state |e/angbracketrightassociated
with it, beyond noting that, unlike the state of a single Qbit, the stateof the environment is likely to be a state in a space of enormously manydimensions if there is any complexity to the environment that couples,however weakly, to the Qbit.
If, in spite of this recommended point of view, you still feel un-
comfortable applying quantum states to noncomputational degrees offreedom, then I invite you to regard |e/angbracketrightas the state of some enormous
collection of extra Qbits, from which one would like the computationto be completely decoupled, but which, for reasons beyond our con-trol, somehow manage to interact weakly with the Qbits we are actuallyinterested in. I offer this invitation as a conceptual aid to computerscientists uncomfortable with my claim that quantum states apply tothe description of arbitrary physical systems. But I also note that in re-cent years a few physicists have suggested that the entire world shouldindeed be viewed as an enormous collection of Qbit s – a position that
has not attracted many adherents to date.
Returning from grand world views to the practical reality of errors
in a quantum computation, we shall regard a single Qbit, initially inthe state |x/angbracketright(x= 0 or 1), as being part of a larger system consisting
of the Qbit plus its environment, initially in the state |e/angbracketright|x/angbracketright.I nt h e
ideal case, as the Qbit evolves under 1-Qbit unitary gates or interactswith other Qbits under 2-Qbit unitary gates, it stays unentangled with

<<<PAGE 128>>>

5.3 THE PHYSICS OF ERROR GENERATION 1 1 1
its environment. The environmental component of the state is then
irrelevant to the computational process and can be ignored, as we havebeen doing up to now.
Unfortunately, however, interactions with the environment will in
general transform and entangle the states of the Qbit and its environ-ment. The most general way in which this can come about can beexpressed in the form
|e/angbracketright|0/angbracketright→| e
0/angbracketright|0/angbracketright+| e1/angbracketright|1/angbracketright,(5.7)|e/angbracketright|1/angbracketright→| e2/angbracketright|0/angbracketright+| e3/angbracketright|1/angbracketright,
where |e/angbracketrightis the initially uncorrelated state of the environment and
|e0/angbracketright,... ,|e3/angbracketrightare possible ﬁnal environmental states. The environmen-
tal ﬁnal states are not necessarily orthogonal or normalized, and areconstrained only by the requirement that the two states on the rightside of (5.7) should be orthogonal, since the Qbit–environment in-teraction is required, like any other physical interaction, to lead to aunitary development in time. This corruption of a computation by theentanglement of the state of Qbits with the state of their environmentis called decoherence . It is the primary enemy of quantum computation.
Included in (5.7) are cases like the oversimpliﬁed one we examined
in Section 5.2, in which the Qbit remains isolated from the environ-ment ( |e
i/angbracketright= ai|e/angbracketright,i=0,... , 3) but still suffers in that isolation an
unintended unitary evolution. But (5.7) also includes the case of majorpractical interest. This is the case in which the interaction with theenvironment has a small but otherwise quite general entangling effecton the Qbit:
|e
0/angbracketright≈| e3/angbracketright≈| e/angbracketright;/angbracketlefte1|e1/angbracketright,/angbracketlefte2|e2/angbracketright/lessmuch 1. (5.8)
In dealing with such entangling interactions with the environment,
it is useful to introduce projection operators
Px=1+(−1)xZ
2, (5.9)
which project onto the 1-Qbit states |x/angbracketright,x=0,1.Using these
projection operators, we can combine the two time evolutions in (5.7)into a single form:
|e/angbracketright|x/angbracketright→/parenleftbig/bracketleftbig
|e
0/angbracketright1+|e1/angbracketrightX/bracketrightbig
P0/parenrightbig
|x/angbracketright+/parenleftbig/bracketleftbig
|e2/angbracketrightX+|e3/angbracketright1/bracketrightbig
P1/parenrightbig
|x/angbracketright.(5.10)
In (5.10) I have introduced the convenient notation |e/angbracketrightUto describe
the linear operator from a 1-Qbit to a many-Qbit space that takesthe 1-Qbit state |ψ/angbracketrightinto the many-Qbit state |e/angbracketright⊗
U|ψ/angbracketright; like most
embellishments of Dirac notation it is deﬁned so that the appropriateform of the associative law holds:
/parenleftbig
|e/angbracketright
U/parenrightbig
|ψ/angbracketright=| e/angbracketright⊗U|ψ/angbracketright. (5.11)

<<<PAGE 129>>>

1 1 2 QUANTUM ERROR CORRECTION
Using the explicit form (5.9) of the two projection operators, deﬁning1
Y=ZX, (5.12)
and continuing to use the notational convention (5.11), we can rewrite
(5.10) as
|e/angbracketright|x/angbracketright→/parenleftbigg|e0/angbracketright+| e3/angbracketright
21+|e0/angbracketright−| e3/angbracketright
2Z
+|e2/angbracketright+| e1/angbracketright
2X+|e2/angbracketright−| e1/angbracketright
2Y/parenrightbigg
|x/angbracketright. (5.13)
There is nothing special about the particular environmental states
appearing in (5.13), so we can rewrite it more compactly in terms of fourother (in general neither normalized nor orthogonal) states |a/angbracketright,|b/angbracketright,|c/angbracketright,
and|d/angbracketrightof the environment as
|e/angbracketright|x/angbracketright→/parenleftbig
|d/angbracketright
1+|a/angbracketrightX+|b/angbracketrightY+|c/angbracketrightZ/parenrightbig
|x/angbracketright. (5.14)
The time development represented by the arrow in (5.14) is unitary and
therefore linear, so the combination of environmental states and unitaryoperators on the right side of (5.14) acts linearly on |x/angbracketright. Therefore
(5.14) holds not only for |e/angbracketright|0/angbracketrightand|e/angbracketright|1/angbracketrightbut also for any superposition
α|e/angbracketright|0/angbracketright+β|e/angbracketright|1/angbracketright=| e/angbracketright/parenleftbig
α|0/angbracketright+β|1/angbracketright/parenrightbig
=|e/angbracketright|ψ/angbracketright,i nt h ef o r m
|e/angbracketright|ψ/angbracketright→/parenleftbig
|d/angbracketright
1+|a/angbracketrightX+|b/angbracketrightY+|c/angbracketrightZ/parenrightbig
|ψ/angbracketright. (5.15)
The actions of X,Z, and Yon the uncorrupted state |ψ/angbracketrightare some-
times described as subjecting the Qbit to a bit-ﬂip error, a phase error,and a combined bit-ﬂip and phase error. Using this terminology, a gen-eral environmental degradation of the state of a Qbit, which can alwaysbe put in the form (5.15), can be viewed as a superposition of no error(
1), a bit-ﬂip error ( X), a combined bit-ﬂip and phase error ( Y), and
a phase error ( Z). The oversimpliﬁed example of Section 5.2 ignored
the possibility of phase errors ( Z) and combined errors ( Y).
If we were to extend this analysis to the corruption of an n-Qbit
codeword |/Psi1/angbracketrightn, we would end up with a combined state of the codeword
and the environment of the form
|e/angbracketright|/Psi1/angbracketright→3/summationdisplay
µ1=0···3/summationdisplay
µn=0|eµ1···µn/angbracketrightX(µ1)⊗···⊗ X(µn)|/Psi1/angbracketright, (5.16)
where
X(0)=1, X(1)=X, X(2)=Y, X(3)=Z. (5.17)
The construction of error-correcting codewords requires a physical
assumption analogous to the assumption in Section 5.2 that at most a
1 This Ydiffers by a factor of ifrom the Ybrieﬂy used in Section 1.4.

<<<PAGE 130>>>

5.4 DIAGNOSING ERROR SYNDROMES 1 1 3
single Qbit in a codeword suffers a ﬂip error. If |/Psi1/angbracketrightis a state of a small
number nof Qbits that make up an n-Qbit codeword, then the proba-
bility of corruption of the codeword is so small that the terms in (5.16)differing from the term
1⊗···⊗ 1that reproduces the uncorrupted
state are dominated by those in which only a single one of the X(µi)
differs from 1. If this condition is met, then the general form (5.16) of
a corrupted n-Qbit codeword is a superposition of terms in which each
individual Qbit making up the word has suffered a degradation of theform (5.15):
|e/angbracketright|/Psi1/angbracketright→/parenleftBigg
|d/angbracketright
1+n−1/summationdisplay
i=0|ai/angbracketrightXi+|bi/angbracketrightYi+|ci/angbracketrightZi/parenrightBigg
|/Psi1/angbracketright. (5.18)
One can allow for the more general possibility of two or more Qbits
in a codeword being corrupted together if one is willing to use longercodewords to correct such errors. The examples of error correctiongiven below are all at the level of single-Qbit errors of the form (5.18)in the codeword. The extent to which the dominant sources of errorwill actually be of this form may well depend on the kind of physicalsystem used to realize the Qbits. Eventually the theory of quantumerror correction will have to face this issue. Meanwhile this possiblefuture source of difﬁculty should not distract you from appreciatinghow remarkable it is that an error-correction procedure exists at all,even in the restricted setting of single-Qbit errors.
To correct 1-Qbit errors we require a procedure that restores a
corrupted state of the form
|d/angbracketright|/Psi1/angbracketright+
n−1/summationdisplay
i=0/parenleftbig
|ai/angbracketrightXi|/Psi1/angbracketright+| bi/angbracketrightYi|/Psi1/angbracketright+| ci/angbracketrightZi|/Psi1/angbracketright/parenrightbig
(5.19)
to the uncorrupted form
|e/angbracketright|/Psi1/angbracketright, (5.20)
where |e/angbracketrightis the environmental state accompanying whichever of the
3n+1 terms in (5.19) our error-correction procedure has projected
the corrupted state onto. If the term in Xiwere the only one present
in (5.19), we could use a 3-Qbit codeword and achieve this projec-tion by applying precisely the error-correction technique described inSection 5.2. But to deal with the additional possibilities associated withthe terms in
YiandZiwe require longer codewords and more elaborate
diagnostic methods.
5.4 Diagnosing error syndromes
Before turning to speciﬁc quantum error-correcting codes, it is useful toanticipate the general structure of the gates we will be using to identify

<<<PAGE 131>>>

1 1 4 QUANTUM ERROR CORRECTION
and project onto a particular term in the general 1-Qbit corruption
(5.19) of a codeword. As noted earlier, these will be generalizationsof the controlled
Z2Z1and Z1Z0gates used to diagnose errors in the
artiﬁcial case in which only bit-ﬂip errors are allowed.
LetAbeany n -Qbit Hermitian operator whose square is the unit
operator:
A2=1. (5.21)
It follows from (5.21) that Ais unitary, since A†=A. The eigenvalues
ofAcan only be 1 or −1, since Aacting twice on an eigenstate must
act as the identity 1. The projection operators onto the subspaces of
states with eigenvalue +1 and−1 are, respectively,
PA
0=1+A
2and PA
1=1−A
2. (5.22)
Since P0+P1=1, any state |ψ/angbracketrightcan be expressed as a superposition
of its projections onto these two subspaces: |ψ/angbracketright= P0|ψ/angbracketright+P1|ψ/angbracketright.
The operators Z2Z1and Z1Z0encountered in the 3-Qbit code for
correcting bit-ﬂip errors are examples of such A. In the more general
cases we shall be examining, the operators Awill be more general
products of both Zand Xoperators associated with different Qbits in
the codeword; for example A=Z4X3Z2X1X0.
In addition to the nQbits on which Aacts, we introduce an ancillary
Qbit and consider the controlled operator CA, which we write here
in the alternative form cAto avoid having subscripts on superscripts,
which acts as Aon the nQbits when the state of the ancilla is |1/angbracketrightand
as the identity when the state of the ancilla is |0/angbracketright. If the state of the
ancilla is a superposition of |0/angbracketrightand|1/angbracketright, the action of cAis deﬁned by
linearity. When Ais a product of 1-Qbit operators, the operator cA
can be taken to be a product of ordinary 2-Qbit controlled operators. If
A=Z4X3Z2X1X0,then cAwould be cZ4cX3cZ2cX1cX0, where each
of the ﬁve terms has a different target Qbit, but all are controlled byone and the same ancilla.
If the ancilla is initially in the state |0/angbracketrightand one applies a Hadamard
transform
Hto the ancilla both before and after applying cAto the
n+1 Qbits and the initial state of the nQbits is |/Psi1/angbracketright, then the nQbits
will end up entangled with the ancilla in the state
/parenleftbig
H⊗1/parenrightbig
cA/parenleftbig
H⊗1/parenrightbig
|0/angbracketright|/Psi1/angbracketright=/parenleftbig
H⊗1/parenrightbig
cA1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
|/Psi1/angbracketright
=/parenleftbig
H⊗1/parenrightbig1√
2/parenleftbig
|0/angbracketright|/Psi1/angbracketright+| 1/angbracketrightA|/Psi1/angbracketright/parenrightbig
=1
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
|/Psi1/angbracketright+1
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
A|/Psi1/angbracketright
=|0/angbracketright1
2/parenleftbig
1+A/parenrightbig
|/Psi1/angbracketright+| 1/angbracketright1
2/parenleftbig
1−A/parenrightbig
|/Psi1/angbracketright
=|0/angbracketrightPA
0|/Psi1/angbracketright+| 1/angbracketrightPA
1|/Psi1/angbracketright. (5.23)

<<<PAGE 132>>>

5.4 DIAGNOSING ERROR SYNDROMES 1 1 5
Px
M
P y0
y yxx
Z
X
Z
XXxyHH
Fig 5.6 The way in which
measurement gates areemployed in quantumerror correction. Theancilla (upper wire) isinitially in the state zero.
The remaining ﬁve Qbits
are initially in the state|ψ/angbracketright. If the measurement
gate acting on the ancillagives the result x(0 or 1)
then the ﬁnal state of theﬁve Qbits will be the(renormalized) projection
Px|ψ/angbracketrightof the initial state
into the subspace spannedby the eigenstates of
Z4X3Z2X1X0with
eigenvalue ( −1)x.If we now measure the ancilla, then according to the generalized Born
rule, if the measurement gate indicates 0 or 1, then the state of the n
Qbits becomes the (renormalized) projection of |/Psi1/angbracketrightinto the subspace
of positive (eigenvalue +1) or negative (eigenvalue −1) eigenstates of
A. This is illustrated for the case A=Z4X3Z2X1X0in Figure 5.6.
This procedure is called measuring Aor a measurement ofA. The
terminology reﬂects the fact that it is a generalization of the ordinaryprocess of measuring a single Qbit, to which it reduces when n=1 and
A=Z. In that case the subspaces spanned by the positive and negative
eigenstates of Zare just the one-dimensional subspaces spanned by |0/angbracketright
and|1/angbracketright, and the probabilities of the two outcomes, as one can easily
check, are indeed given by the Born rule.
In error correction one needs several such Hermitian operators,
each squaring to unity, all acting on the same nQbits. For concreteness
consider the case of three such operators, A,B, and C. Introduce an
ancillary Qbit for each operator, labeling the ancillas 0, 1, and 2, andintroduce controlled operators
cA,cB, and cC, each controlled by the
corresponding ancilla. Now apply Hadamards to each of the ancillas(each initially taken to be in the state |0/angbracketright), both before and after the
product of all the controlled operators acts. The result (see Figure 5.7)is the obvious generalization of (5.23), taking |0/angbracketright|0/angbracketright|0/angbracketright|/Psi1/angbracketrightinto
/parenleftbig
H2H1H0/parenrightbig/parenleftbig
cCcBcA/parenrightbig/parenleftbig
H2H1H0/parenrightbig
|0/angbracketright|0/angbracketright|0/angbracketright|/Psi1/angbracketright
=1/summationdisplay
x2=01/summationdisplay
x1=01/summationdisplay
x0=0|x2/angbracketright|x1/angbracketright|x0/angbracketright/parenleftbigg1+(−1)x2C
2/parenrightbigg/parenleftbigg1+(−1)x1B
2/parenrightbigg
×/parenleftbigg1+(−1)x0A
2/parenrightbigg
|/Psi1/angbracketright
=1/summationdisplay
x2=01/summationdisplay
x1=01/summationdisplay
x0=0|x2/angbracketright|x1/angbracketright|x0/angbracketrightPC
x2PB
x1PA
x0|/Psi1/angbracketright. (5.24)

<<<PAGE 133>>>

1 1 6 QUANTUM ERROR CORRECTION
000
ΨH
HH
AB CH
HHFig 5.7 A,B, and Care
commuting operatorssatisfying
A2=B2=C2=1.They
act on the n-Qbit state |/Psi1/angbracketright
associated with the thicklower wire. The effect ofmeasuring the threeancillas (top three wires) isto project the state of the n
Qbits associated with thelower wire into itscomponent in one of theeight eigenspaces of
A,B,
andC. If the results of
measuring the control bitsassociated with
A,B, and
Care x0,x1, and x2then
the projection is into theeigenspace witheigenvalues ( −1)
x0,(−1)x1,
and (−1)x2.Such a process
is called “measuring A,B,
andC.” When n=3 and
A,B, and Care three
different 1-Qbit Z
operators, the process isequivalent to an ordinarymeasurement of the threeQbits on which the three
Z
operators act.IfA,B,andCallcommute – which is always the case in the examples
relevant to error correction – then the state
PC
x2PB
x1PA
x0|/Psi1/angbracketright=/parenleftbigg1+(−1)x2C
2/parenrightbigg/parenleftbigg1+(−1)x1B
2/parenrightbigg/parenleftbigg1+(−1)x0A
2/parenrightbigg
(5.25)
is an eigenstate of all the operators C,B, and A, with respective
eigenvalues
(−1)x2,(−1)x1,and (−1)x0. (5.26)
This follows directly from the fact that if V2=1 then
V/parenleftbigg1+(−1)xV
2/parenrightbigg
=(−1)x/parenleftbigg1+(−1)xV
2/parenrightbigg
. (5.27)
So measurement of the three ancillas projects the nQbits into one of
the eight simultaneous eigenspaces of the three commuting operators
C,B, and A, and the outcome x2x1x0of the measurement determines
which eigenspace it is. This process is described as a joint measurementof
C,B, and A.
Note that if A,B, and Care 1-Qbit operators Zi,Zj, and Zkthat
act on the ith, jth, and kth of the nQbits, then this process reduces to
the ordinary measurement of those three Qbits, since1
2(1+(−1)xZ)
projects onto the 1-Qbit state |x/angbracketright. The two equivalent error-correction
circuits in Figures 5.3 and 5.5 are measurements, in this generalizedsense, of the two commuting operators
A=Z2Z1andB=Z1Z0.
The form (5.18) of a general 1-Qbit error on an n-Qbit codeword re-
veals that to correct errors it is necessary to make a measurement, in thismore general sense of the term, that projects a possibly corrupted code-word into an identiﬁable one of 1 +3northogonal two-dimensional
spaces: one two-dimensional subspace for the uncorrupted codeword|/Psi1/angbracketright, and 3 nadditional two-dimensional subspaces for each of the 1-
Qbit error terms
Xi|/Psi1/angbracketright,Yi|/Psi1/angbracketright, and Zi|/Psi1/angbracketright,i=0,... , n−1, in (5.18).
Thus the 2n-dimensional space spanned by all the states of the nQbits
must be large enough to contain 1 +3northogonal two-dimensional
subspaces, giving us the condition
2n−1≥3n+1 (5.28)
on an n-Qbit code capable of correcting a general 1-Qbit error. The
lowest nsatisfying this condition is n=5, for which it holds as an

<<<PAGE 134>>>

5.5 THE 5-QBIT ERROR-CORRECTING CODE 1 1 7
equality. Remarkably, there is indeed a 5-Qbit code for which this can
be done. This is reminiscent of the situation in Section 5.2, where itwas necessary only to discriminate between the uncorrupted codeword|/Psi1/angbracketrightand the nNOT-corruptions
Xi|/Psi1/angbracketright. There the number of Qbits
had to satisfy (5.5), which is ﬁrst satisﬁed (again as an equality) whenn=3.
The 5-Qbit code is the most compact and elegant of the quantum
error-correcting codes, but it suffers from the fact that it is difﬁcultto construct the appropriate generalizations of 1- and 2-Qbit gatesbetween codewords. I therefore go on to describe a second, 7-Qbit code,which overcomes this problem. The ﬁrst quantum error-correctingcode, discovered by Peter Shor, which uses a 9-Qbit generalization ofthe 3-Qbit code of Section 5.2, is now of solely historical interest. It isdescribed in Appendix N.
5.5 The 5-Qbit error-correcting code
The two 5-Qbit code words |0/angbracketrightand|1/angbracketrightare most conveniently deﬁned in
terms of the very operators, described in general terms in Section 5.4,that will be used to diagnose the error syndrome. So we begin byspecifying those operators.
To distinguish 1 +(3×5)=16 mutually orthogonal two-
dimensional subspaces we require four such mutually commutingHermitian operators that square to unity, since each can independentlyhave two eigenvalues ( ±1) and 2
4=16. These operators are deﬁned
as follows:
M0=Z1X2X3Z4,
M1=Z2X3X4Z0,(5.29)M2=Z3X4X0Z1,
M3=Z4X0X1Z2.
Each of the Misquares to unity because each is a product of commut-
ing operators that square to unity. To check that the Miare mutually
commuting, note that all the individual XiandZjoperators commute
with one another except for an Xiand Ziwith the same index, which
anticommute: XiZi=− ZiXi. But in converting the product of any
two different Mito the product in the reverse order by reversing the
orders of the individual Xiand Zioperators that make them up, one
always encounters exactly two interchanges that result in a minus sign.
One might be tempted to break the irritating asymmetry of (5.30)
by adding to the list
M4=Z0X1X2Z3, (5.30)

<<<PAGE 135>>>

1 1 8 QUANTUM ERROR CORRECTION
but it is not independent of the other four. Every Xiand Ziappears
exactly twice in the product of all ﬁve Mi, so the product must be either
1o r−1. One easily checks that
M0M1M2M3M4=1, (5.31)
and therefore
M4=M0M1M2M3. (5.32)
The 5-Qbit codewords are most clearly and usefully deﬁned in terms
of the Mi(rather than writing out their lengthy explicit expansions in
computational-basis states):
|0/angbracketright=1
4(1+M0)(1+M1)(1+M2)(1+M3)|00000/angbracketright,
(5.33)
|1/angbracketright=1
4(1+M0)(1+M1)(1+M2)(1+M3)|11111/angbracketright.
Before examining how one might produce ﬁve Qbits in either of these
states, we discuss how the states work to correct 1-Qbit errors.
Since each Mﬂips two Qbits, |0/angbracketrightis a superposition of computational-
basis states with an odd number of zeros (and an even number of ones),while|
1/angbracketrightis a superposition of states with an odd number of ones (and
an even number of zeros). Consequently the two codeword states areorthogonal. They are also normalized to unity. Since
M2
i=1,
(1+Mi)2=2(1+Mi). (5.34)
So we have
/angbracketleft0|0/angbracketright=/angbracketleft 00000|(1+M0)(1+M1)(1+M2)(1+M3)|00000/angbracketright,
(5.35)
/angbracketleft1|1/angbracketright=/angbracketleft 11111|(1+M0)(1+M1)(1+M2)(1+M3)|11111/angbracketright.
If we expand the products of 1+Miinto 16 terms, the term 1con-
tributes 1 to /angbracketleft0|0/angbracketrightand to /angbracketleft1|1/angbracketright. Each of the remaining 15 terms can
be reduced, using (5.31) (and the fact that each M2
i=1), to either a
single Mior a product of two ( i=0,... , 4). So each of the 15 terms
ﬂips either two or four Qbits and contributes 0 to the inner products.
Because the Miall commute and because
Mi(1+Mi)=1+Mi, (5.36)
the states |0/angbracketright,|1/angbracketright, and their superpositions
|/Psi1/angbracketright=α|0/angbracketright+β|1/angbracketright (5.37)
are all eigenstates of each of the Miwith eigenvalue 1.
The 15 possible corruptions of (5.37) appearing in the corrupted
state (5.18) are also eigenstates of the Mi, distinguished by the

<<<PAGE 136>>>

5.5 THE 5-QBIT ERROR-CORRECTING CODE 1 1 9
Table 5.2. The four error-syndrome operators Mifor the 5-Qbit
code, and whether each of them commutes (+) or anticommutes ( −)
with each of the 15 operators Xi,Yi, and Zi,i=1,... , 5, associated
with the 15 different terms in the corrupted codeword. Note thateach of the 15 columns, and the 16th column associated with
1(no
error), has a unique pattern of +and−signs.
X0Y0Z0X1Y1Z1X2Y2Z2X3Y3Z3X4Y4Z41
M0=Z1X2X3Z4+++ −−+ +−− +−− −−+ +
M1=Z2X3X4Z0−−+ +++ −−+ +−− +−− +
M2=Z3X4X0Z1+−− −−+ +++ −−+ +−− +
M3=Z4X0X1Z2+−− +−− −−+ +++ −−+ +
15=24−1 other possible sets of eigenvalues ±1 that the four Mi
(i=0,... , 3) can have. To see this, note ﬁrst that each Xi,Yi, and
Zicommutes or anticommutes with all four Mi. Therefore each of
the terms Xi|/Psi1/angbracketright,Yi|/Psi1/angbracketright, and Zi|/Psi1/angbracketrightappearing in (5.18) is indeed an
eigenstate of each Miwith eigenvalue 1 or −1.
Table 5.2 indicates whether each Micommutes ( +) or anticommutes
(−) with each of the Xi,Yi,Zi, and (trivially) the unit operator 1. In-
spection of the table reveals that each of the 16 possible binary columnsof four symbols ( +or−) appears in exactly one column. Therefore,
when the four
Miare measured, the corrupted state (5.18) is projected
back to its original form if all four eigenvalues are +1, or projected onto
one of the 15 corrupted states X0|/Psi1/angbracketright,... , Z4|/Psi1/angbracketrightdepending on which
column in the table describes the eigenvalues. In each corrupted casethe original state can be restored by application of the correspondingunitary transformation
Xi,−Yi=XiZi,o rZito the appropriate Qbit.
A circuit that measures the four operators (5.29) is shown inFigure 5.8.
The perfect efﬁciency of the 5-Qbit code leads to a straightfor-
ward way to manufacture the two 5-Qbit codeword states (5.33).As noted above, the 16 distinct sets of eigenvalues for the fourmutually commuting operators
Midecompose the 32-dimensional
space of ﬁve Qbits into 16 mutually orthogonal two-dimensional sub-spaces, spanned by |
0/angbracketrightand|1/angbracketrightand by each of their 15 pairs of 1-Qbit
corruptions.
The two-fold degeneracy of the four Miwithin each of these 16
subspaces is lifted by the operator
Z=Z0Z1Z2Z3Z4, (5.38)
which commutes with all the Mi. Since |00000/angbracketrightand|11111/angbracketrightare eigen-
states of Zwith eigenvalues 1 and −1, and since Zcommutes with Zi,

<<<PAGE 137>>>

1 2 0 QUANTUM ERROR CORRECTION
H
H
H
HH
H
H
H
ZXXZ
X
ZX
ZZ
XX
Z
XZ
Z
XFig 5.8 A circuit to
measure the errorsyndrome for the 5-Qbitcode. The ﬁve Qbits are theﬁve lower wires. The fourupper wires are the ancillasto be measured in themanner of Figure 5.7,associated with measuringthe four commutingoperators
Z1X2X3Z4,
Z2X3X4Z0,Z3X4X0Z1,
andZ4X0X1Z2of (5.29).
When controlled- Zgates
are present together withcontrolled-NOT gates, theﬁgure is more readable ifthe cNOT gates arerepresented ascontrolled- Xgates.
while anticommuting with XiandYi, it follows that
Z|0/angbracketright=| 0/angbracketright, Z|1/angbracketright=− | 1/angbracketright,
ZZ i|0/angbracketright= Zi|0/angbracketright, ZZ i|1/angbracketright=− Zi|1/angbracketright,
ZX i|0/angbracketright=− Xi|0/angbracketright, ZX i|1/angbracketright= Xi|1/angbracketright,
ZY i|0/angbracketright=− Yi|0/angbracketright, ZY i|1/angbracketright= Yi|1/angbracketright.(5.39)
Consequently if one takes ﬁve Qbits in any state you like (perhaps
most conveniently |00000/angbracketright) and measures the four Mitogether with Z,
one projects the Qbits into one of the 32 states
|0/angbracketright,Xi|0/angbracketright,Yi|0/angbracketright,Zi|0/angbracketright,|1/angbracketright,Xi|1/angbracketright,Yi|1/angbracketright,Zi|1/angbracketright, (5.40)
and learns from the results of the measurement which it is. Just as in the
error-correction procedure, if the state is not |0/angbracketrightor|1/angbracketrightwe can restore
it to either of these forms by applying the appropriate Xi,Yi,o rZi.I f
we wish to initialize the ﬁve Qbits to |0/angbracketrightwe can apply X, where
X=X0X1X2X3X4, (5.41)
should the measurement indicate that the error-corrected state is |1/angbracketright.
This process of using a generalized measurement to produce ﬁve Qbitsin the state |
0/angbracketrightis analogous to the procedure of using an ordinary
measurement to produce a single Qbit in the state |0/angbracketrightdescribed in
Section 1.10.
There is quite a different way to construct the 5-Qbit codewords, by
applying a set of 1- and 2-Qbit unitary gates to an uncoded 1-Qbit stateand four ancillary Qbits all initially in the state |0/angbracketright. This is described
in Section 5.9.

<<<PAGE 138>>>

5.6 THE 7-QBIT ERROR-CORRECTING CODE 1 2 1
H
HH
H
H
HH
HH
HH
H
H
HH
HH
HH
H
XZ
ZZ
ZZ
Z
ZZ
ZZ
Z
Z XX
X
XX
X
XX
X
X
XFig 5.9 A circuit to
measure the errorsyndrome for the 7-Qbitcode. The seven Qbits arethe seven lower wires. Thesix upper wires are the
ancillas to be measured,
resulting in a measurementof the six commutingoperators
Z0Z4Z5Z6,
Z1Z3Z5Z6,Z2Z3Z4Z6,
X0X4X5X6,X1X3X5X6,
andX2X3X4X6of (5.42).
5.6 The 7-Qbit error-correcting code
The 5-Qbit code is theoretically ideal but suffers from the problem
that circuits performing extensions of many of the basic 1- and 2-Qbit operations to the 5-Qbit codewords are cumbersome. The currentfavorite is a 7-Qbit code, devised by Andrew Steane, which permitsimplementations of many basic operations on codewords, which are notonly quite simple but also themselves susceptible to error correction.
The Steane code uses six mutually commuting operators to diagnose
the error syndrome:
M0=X0X4X5X6, N0=Z0Z4Z5Z6,
M1=X1X3X5X6, N1=Z1Z3Z5Z6,
M2=X2X3X4X6, N2=Z2Z3Z4Z6.(5.42)
The six operators in (5.42) clearly square to give the unit operator. The
Mitrivially commute among themselves as do the Ni, and each Mi
commutes with each Nj, in spite of the anticommutation of each Xk
with the corresponding Zk, because in every case they share an even
number of such pairs. A circuit that measures the six operators (5.42)is shown in Figure 5.9.

<<<PAGE 139>>>

1 2 2 QUANTUM ERROR CORRECTION
The 7-Qbit codewords are deﬁned by
|0/angbracketright=2−3/2(1+M0)(1+M1)(1+M2)|0/angbracketright7,
|1/angbracketright=2−3/2(1+M0)(1+M1)(1+M2)X|0/angbracketright7,(5.43)
where
X=X0X1X2X3X4X5X6, (5.44)
so that
|1111111 /angbracketright= X|0000000 /angbracketright. (5.45)
We again defer our discussion of how to produce these states until after
our discussion of how they are used in error correction.
The two states in (5.43) are orthogonal, since each Mﬂips four
Qbits while Xﬂips all seven of them, so the ﬁrst state is a superposition
of 7-Qbit states with an odd number of zeros while the second is asuperposition with an even number of zeros. They are normalized tounity, for essentially the same reasons as in the case of 5-Qbit code.
Since
Xcommutes with all the Mi, a general superposition of the
two codewords can be written as
|/Psi1/angbracketright=α|0/angbracketright+β|1/angbracketright=/parenleftbig
α1+βX/parenrightbig
|0/angbracketright, (5.46)
and its corruption (5.18) assumes the form
|e/angbracketright|/Psi1/angbracketright→/parenleftBigg
|d/angbracketright1+7/summationdisplay
i=1/bracketleftbig
|ai/angbracketrightXi+|bi/angbracketrightYi+|ci/angbracketrightZi/bracketrightbig/parenrightBigg
|/Psi1/angbracketright.(5.47)
Because the Miall commute and Mi(1+Mi)=1+Mi, and be-
cause the Njcommute with the the Miand with Xand have |0000000 /angbracketright
as an eigenstate with eigenvalue 1, it follows that |0/angbracketright,|1/angbracketright, and the gen-
eral superposition (5.46) are eigenstates of each of the MiandNiwith
eigenvalue 1. The 21 possible corruptions of (5.46) appearing in (5.47)are also eigenstates, distinguished by the possible sets of eigenvalues±1 that the three
Miand three Nican have. As in the 5-Qbit case, this
is because each Xi,Yi, and Zicommutes or anticommutes with each of
theMiandNi, so each state appearing in (5.47) is indeed an eigenstate
of each MiandNiwith eigenvalue 1 or −1.
To see why the results of the six measurements of the Miand Ni
determine a unique one of the 22 terms in (5.47), examine Table 5.3,which indicates by a bullet ( •) whether an
Xiappears in each of the Mi
and whether a Ziappears in each of the Ni. Each Micommutes with
every Xj; it anticommutes with Yjand Zjif a bullet appears in the
column associated with Xjand commutes if there is no bullet; each Ni
commutes with every Zj; it anticommutes with Xjand Yjif a bullet
appears in the column associated with Zjand commutes if there is no
bullet.

<<<PAGE 140>>>

5.6 THE 7-QBIT ERROR-CORRECTING CODE 1 2 3
Table 5.3. The six error-syndrome operators MiandNi,i=0,1,2,
for the 7-Qbit code. A bullet ( •) indicates whether a given Xiappears
in each Miand whether a given Ziappears in each Ni.
X0 X1 X2 X3 X4 X5 X6
M0 •• • •
M1 ••• •
M2 ••• •
Z0 Z1 Z2 Z3 Z4 Z5 Z6
N0 •• • •
N1 ••• •
N2 ••• •
The signature of an Xierror (or no error) is that all three Mimeasure-
ments give +1. The pattern of −1 eigenvalues in the Nimeasurements
then determines which of the seven possible Xicharacterize the error.
(If all three Nimeasurements also give +1 there is no error.)
In the same way, the signature of a Zierror (or no error) is that all
three Nimeasurements give +1 and then the pattern of −1 eigenvalues
in the Mimeasurements determines which of the seven possible Zi
characterize the error.
Finally, the signature of a Yierror is that at least some of both the
Miand the Nimeasurements give −1. The resulting pattern of −1
eigenvalues (which will be the same for both the Miand the Nimea-
surements) then determines which of the seven possible Yicharacterize
the error.
So the six measurements project the corrupted state into a unique
one of the 22 terms in (5.47) and establish which term it is. One canthen undo the corruption by applying the appropriate one of the 22operators
1,X0,... , Z6.
To produce the 7-Qbit codewords one cannot immediately extend
the method we used in Section 5.5 to produce the 5-Qbit codewords,because the two 7-Qbit codewords and their 21 1-Qbit corruptionsconstitute only 44 mutually orthogonal states, while the space of sevenQbits has dimension 2
7=128. One can, however, provide the missing
84 dimensions by noting the following.
The 2 ×7×6=84 states given by
XiZj|0/angbracketrightand XiZj|1/angbracketright, i/negationslash=j, (5.48)
are also easily veriﬁed to be eigenstates of all the Miand Ni. These
states can be associated with some of the possible 2-Qbit errors, butthis is not pertinent to the use to which we put them here. Like the1-Qbit
Yierrors, these states result in at least some of both the Miand

<<<PAGE 141>>>

1 2 4 QUANTUM ERROR CORRECTION
theNimeasurements giving −1, but unlike the Yierrors, the resulting
pattern of −1 eigenvalues will notbe the same for both the Miand the
Nimeasurements, since i/negationslash=j. Each of the 7 ×6=42 possibilities for
XiZjleads to its own characteristic pattern of +1 and−1 eigenvalues.
This gets us back to the situation we encountered in the 5-Qbit case.
By measuring the seven mutually commuting operators Mi,Ni, and
Z=Z0Z1Z2Z3Z4Z5Z6, (5.49)
we can produce from seven Qbits in an arbitrarily chosen state a unique
one of the 128 mutually orthogonal states given by |0/angbracketright,|1/angbracketright, their 42
different 1-Qbit corruptions, and their 84 different special kinds of2-Qbit corruptions. The results of the measurement tell us the char-acter (if any) of the corruption, from which we know what operators(
Xi,Yi,Zi,o rXiZj, possibly combined with X) we must apply to the
post-measurement state to convert it into |0/angbracketright.
A simpler way to produce 7-Qbit codewords is to start with seven
Qbits in the standard initial state |0/angbracketright7, and then measure M0,M1, and
M2. The resulting state will be one of the eight states
2−3/2(1±M0)(1±M1)(1±M2)|0/angbracketright7, (5.50)
with the speciﬁc pattern of +and−signs being revealed by the mea-
surement. The upper part of Table 5.3 now permits one to choose aunique
Zithat commutes or anticommutes with each Midepending on
whether it appears in (5.50) with a +or a−sign. Since Zi|0/angbracketright7=|0/angbracketright7,
acting on the seven Qbits with that particular Ziconverts their state to
2−3/2(1+M0)(1+M1)(1+M2)|0/angbracketright7=|0/angbracketright. (5.51)
In Section 5.8 we examine a surprisingly simple circuit that encodes
a general 1-Qbit state into a 7-Qbit codeword state in the manner ofFigure 5.1, without using any measurement gates.
5.7 Operations on 7-Qbit codewords
The virtue of the 7-Qbit code, that makes it preferable to the 5-Qbitcode in spite of its greater expenditure of Qbits, is that many of thefundamental 1- and 2-Qbit gates are trivially extended to 7- and 14-Qbit gates acting on the codewords. Because, for example,
Xcommutes
with the Miand ﬂips all seven Qbits, it implements the logical NOT
on the codewords (5.43):
X|0/angbracketright=| 1/angbracketright, X|1/angbracketright=| 0/angbracketright. (5.52)
Similarly, Zcommutes with the Mi, anticommutes with X, and leaves
|0/angbracketright7invariant, so it implements the logical Zon the codewords:
Z|0/angbracketright=| 0/angbracketright, Z|1/angbracketright=− | 1/angbracketright. (5.53)

<<<PAGE 142>>>

5.7 OPERATIONS ON 7-QBIT CODEWORDS 1 2 5
This much works equally well for the 5-Qbit code. More remarkably,
for the 7-Qbit code the bitwise Hadamard transformation,
H=H0H1H2H3H4H5H6, (5.54)
also implements the logical Hadamard transformation on the code-
words:
H|0/angbracketright=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
, H|1/angbracketright=1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
. (5.55)
(This does not hold for the 5-Qbit code.)
To see this, note ﬁrst that two normalized states |φ/angbracketrightand|ψ/angbracketrightare
identical if and only if their inner product is 1. (For one can alwaysexpress |ψ/angbracketrightin the form |ψ/angbracketright=α|φ/angbracketright+β|χ/angbracketright, where |χ/angbracketrightis orthogonal
to|φ/angbracketrightand|α|
2+|β|2=1.We then have /angbracketleftφ|ψ/angbracketright=α,s oi f/angbracketleftφ|ψ/angbracketright=1,
thenα=1 andβ=0.) Since |0/angbracketrightand|1/angbracketrightare normalized and orthogonal
and since His unitary and therefore preserves the normalization of |0/angbracketright
and|1/angbracketright, the four states appearing in the two equalities in (5.55) are all
normalized. Therefore, to establish those equalities it sufﬁces to showthat
1=
1√
2/parenleftbig
/angbracketleft0|H|0/angbracketright+/angbracketleft 0|H|1/angbracketright/parenrightbig
, 1=1√
2/parenleftbig
/angbracketleft1|H|0/angbracketright−/angbracketleft 1|H|1/angbracketright/parenrightbig
.
(5.56)
This in turn would follow if we could show that the matrix of theencoded Hadamard in the encoded states is the same as the matrix ofthe 1-Qbit Hadamard in the 1-Qbit states:
/angbracketleft
0|H|0/angbracketright=/angbracketleft 0|H|1/angbracketright=/angbracketleft 1|H|0/angbracketright=1√
2, /angbracketleft1|H|1/angbracketright=−1√
2.(5.57)
To establish (5.57), note that it follows from the deﬁnition (5.43) of
the codewords |0/angbracketrightand|1/angbracketrightthat the four matrix elements appearing in
(5.57) are
/angbracketleftx|H|y/angbracketright=2−3
7/angbracketleft0|Xx(1+M0)(1+M1)(1+M2)H(1+M0)
×(1+M1)(1+M2)Xy|0/angbracketright7. (5.58)
Since HX=ZHand XH=HZ, and since each Nidiffers from Mi
only by the replacement of each Xby the corresponding Z, it follows
that
HM i=NiH, MiH=HN i. (5.59)
So we can bring all three terms 1+Miin (5.58) on the right of Hover
to the left if we replace each by 1+Ni. But since the Ms and Ns all
commute we can then bring all three terms 1+Mion the left of H
over to the right if we again replace each by 1+Ni. The effect of these
interchanges is simply to change all the Ms in (5.58) into Ns:
/angbracketleftx|H|y/angbracketright=2−3
7/angbracketleft0|Xx(1+N0)(1+N1)(1+N2)H(1+N0)
×(1+N1)(1+N2)Xy|0/angbracketright7. (5.60)

<<<PAGE 143>>>

1 2 6 QUANTUM ERROR CORRECTION
Since each Nicommutes with X(there are four anticommutations)
we have
/angbracketleftx|H|y/angbracketright=2−3
7/angbracketleft0|(1+N0)(1+N1)(1+N2)XxHXy(1+N0)
×(1+N1)(1+N2)|0/angbracketright7, (5.61)
but since each Niacts as the identity on |0/angbracketright7, each of the six 1+Nican
be replaced by a factor of 2, reducing (5.61) simply to
/angbracketleftx|H|y/angbracketright=23
7/angbracketleft0|XxHXy|0/angbracketright7. (5.62)
Since X,H, and|0/angbracketright7are tensor products of the seven 1-Qbit quantities
X,H, and|0/angbracketright, (5.62) is just
/angbracketleftx|H|y/angbracketright=23/angbracketleftx|H|y/angbracketright7. (5.63)
But since
/angbracketleft0|H|0/angbracketright=/angbracketleft 0|H|1/angbracketright=/angbracketleft 1|H|0/angbracketright=1√
2, /angbracketleft1|H|1/angbracketright=−1√
2,(5.64)
(5.63) does indeed reduce to (5.57), establishing that H=H⊗7does
indeed act as a logical Hadamard gate on the codewords.
Nor is it difﬁcult to make a 14-Qbit logical cNOT gate that takes the
pair of codewords |x/angbracketright|y/angbracketrightinto|x/angbracketright|x⊕y/angbracketright. One simply applies ordinary
cNOT gates to each of the seven pairs of corresponding Qbits in thetwo codewords. This works because each of the codewords in (5.43) isleft invariant by each of the
Mi. If the control codeword is in the state
|0/angbracketrightthen the pattern of ﬂips applied to the target codeword for each of
the eight terms in the expansion of the control codeword
|0/angbracketright=2−3/2/parenleftbig
1+M0+M1+M2+M1M2+M2M0
+M0M1+M0M1M2/parenrightbig
|0/angbracketright7 (5.65)
is simply given by the corresponding product of Mi. Since each Miacts
as the identity on both |0/angbracketrightand|1/angbracketright, the target codeword is unchanged.
On the other hand, if the control codeword is in the state |1/angbracketrightthen
the pattern of ﬂips applied to the target codeword differs from thisby an additional application of
X, which has precisely the effect of
interchanging |0/angbracketrightand|1/angbracketright.
Because of the simplicity of all these encoded gates, one can use
error correction to eliminate malfunctions of the elementary gatesthemselves, if the rate of malfunctioning is so low that only a sin-gle one of the seven elementary gates is likely to malfunction. In thecase of the 1-Qbit encoded gates, their elementary components act onlyon single Qbits in the codeword, so if only a single one of them mal-functions then only a single Qbit in the codeword will be corrupted andthe error-correction procedure described above will restore the correctoutput. But this works as well for the encoded cNOT gate, since ifonly a single one of the elementary 2-Qbit cNOT gates malfunctions,

<<<PAGE 144>>>

5.8 A 7-QBIT ENCODING CIRCUIT 1 2 7
0
0
00
0
0
y
0123456
Ψ
HHH
Fig 5.10 A 7-Qbit encoding circuit (a) that takes |ψ/angbracketright=α|0/angbracketright+β|1/angbracketright
into the corresponding superposition of the two 7-Qbit codewordsgiven in (5.43), |/Psi1/angbracketright=α|
0/angbracketright+β|1/angbracketright. The numbering of the Qbits from
6 to 0 is made explicit to facilitate comparison with the form(5.42)–(5.44) of the codewords.
this will affect only single Qbits in each of the two encoded 7-Qbit
words, and the correct output will again be restored by applying errorcorrection to both of the codewords.
Another virtue of codeword gates that can be constructed as ten-
sor products of uncoded gates is that they cannot (when functioningcorrectly) convert single-Qbit errors to multiple-Qbit errors, as moreelaborate constructions of codeword gates might do. This highly de-sirable property is called fault tolerance . The great advantage of the
7-Qbit code is that many of the most important logical gates can beimplemented in a fault-tolerant way.
5.8 A 7-Qbit encoding circuit
The circuit in Figure 5.10 encodes a general 1-Qbit state into a 7-Qbitcodeword without using any measurement gates, in a manner analogousto the way Figure 5.1 produces 3-Qbit codewords.
Since the circuit is unitary and therefore linear, it is enough to show
that it works when |ψ/angbracketright=| 0/angbracketrightand when |ψ/angbracketright=| 1/angbracketright. This follows from
the fact that if the ( n+1)-Qbit gate
CUis a controlled n-Qbit unitary
U, then
CU/parenleftbig
H|0/angbracketright/parenrightbig
⊗|/Phi1/angbracketrightn=CU1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
⊗|/Phi1/angbracketrightn
=1√
2/parenleftbig
1+X⊗U/parenrightbig
|0/angbracketright⊗|/Phi1/angbracketrightn, (5.66)
where the control Qbit is on the left. If this is applied to the
three controlled triple-NOT gates in Figure 5.10 then, reading fromleft to right, the resulting operations are (1 /√
2)(1+X2X3X4X6)=

<<<PAGE 145>>>

1 2 8 QUANTUM ERROR CORRECTION
(1/√
2)(1+M2), (1/√
2)(1+X1X3X5X6)=(1/√
2)(1+M1), and
(1/√
2)(1+X0X4X5X6)=(1/√
2)(1+M0).
When |ψ/angbracketright=| 0/angbracketrightthe controlled double-NOT on the left acts as the
identity, so the circuit does indeed produce the codeword |0/angbracketrightin (5.43).
When |ψ/angbracketright=| 1/angbracketright, the controlled double-NOT on the left acts as X4X5.
The circuit after that action is exactly the same as when |ψ/angbracketright=| 0/angbracketright,
except that the initial state of Qbits 3, 4, and 5 on the left is |1/angbracketrightrather
than|0/angbracketright. Since all Xicommute, the state that results is not |0/angbracketrightbut
X3X4X5|0/angbracketright.But
X3X4X5=X0X1X2X3X4X5X6M0M1M2=XM 0M1M2. (5.67)
Since M0M1M2acts as the identity on |0/angbracketright, the resulting state is indeed
|1/angbracketright= X|0/angbracketright.
A less direct method to conﬁrm that Figure 5.10 produces the 7-
Qbit encoding, analogous to the method described in Section 5.9 forthe 5-Qbit encoding, is given in Appendix O.
5.9 A 5-Qbit encoding circuit
The circuit in Figure 5.11 encodes a general 1-Qbit state into a 5-Qbitcodeword without using any measurement gates.
The circuit differs from one reported by David DiVincenzo
2only
by the presence of the 1-Qbit gates ZHZ on the left. When |ψ/angbracketright=|x/angbracketright
DiVincenzo’s circuit produces two orthogonal linear combinations ofthe codewords (5.43), which are, of course, equally valid choices. Butto get the codewords in (5.43) one needs these additional gates. (I havewritten them in the symmetric form
ZHZ rather than in the simpler
equivalent form YHboth to spare the reader from having to remember
that Y=ZXand not XZ, and also to spare her the confusion of having
to reverse the order of gates when going from a circuit diagram to thecorresponding equation.)
In contrast to the superﬁcially similar circuit for the 7-Qbit code in
Figure 5.10, there does not seem to be a transparently simple way todemonstrate that the circuit in Figure 5.11 does produce the 5-Qbitcodewords. One can always, of course, write down the action of eachsuccessive gate in the circuit, and check that the resulting unwieldyexpressions are identical to the explicit expansions of the codewords(5.33) in computational-basis states. A less clumsy proof follows fromthe fact that |
0/angbracketrightis the unique (to within an overall phase factor eiϕ)
joint eigenvector with all eigenvalues 1 of the ﬁve mutually commutingoperators consisting of the four error-syndrome operators
M0,... , M3
2 David P . DiVincenzo, “Quantum Gates and Circuits,” Proceedings of the
Royal Society of London A454, 261–276 (1998),
http://arxiv.org/abs/quant-ph/9705009 .

<<<PAGE 146>>>

5.9 A 5-QBIT ENCODING CIRCUIT 1 2 9
0000x
xHH
H
HH H
HZHZ
_
Fig 5.11 A 5-Qbit encoding circuit. If the initial state of the Qbit on
the top wire is |ψ/angbracketright=α|0/angbracketright+β|1/angbracketright, then the circuit produces the
corresponding superposition of the two 5-Qbit codewords given in(5.33), |/Psi1/angbracketright=α|
0/angbracketright+β|1/angbracketright. This fact is established in Figures
5.12–5.20. The ﬁgure illustrates this for the states |0/angbracketrightand|1/angbracketright(x=0o r
1) on the upper wire. Since a product of unitary gates is linear, thecircuit encodes arbitrary superpositions of these states.
of Equation (5.29) and the operator Zof Equation (5.38). So if we can
establish that the state |x/angbracketrightproduced in Figure 5.11 is invariant under
the four Mi, that it is invariant under Zwhen x=0, and that applying
the 5-Qbit Xto|x/angbracketrightis the same as applying the 1-Qbit Xto|x/angbracketright, then we
will have shown that the circuit produces the 5-Qbit encoding to withinan overall phase factor e
iϕ. Having done this, we can then conﬁrm that
eiϕ=1 by evaluating the projection on |0/angbracketright5of the state produced by
the circuit when x=0.
To learn the actions of various products of 1-Qbit Xs and Zso nt h e
state produced by the circuit in Figure 5.11, we apply them on the rightside of the diagram, and then bring them to the left through the cNOTgates and 1-Qbit gates that make up the circuit, until they act directlyon the input state on the left. In doing this we must use the fact thatbringing an
X(or a Z) through a Hadamard converts it to a Z(or an
X), bringing an Xthrough a Zintroduces a factor of −1, and bringing
anXor a Zthrough a cNOT has the results shown in Figure 5.12: a
Zon the control Qbit (or an Xon the target Qbit) commutes with a
cNOT , while bringing a Zthrough the target Qbit (or an Xthrough
the control Qbit) introduces an additional Zon the control Qbit (or X
on the target Qbit).
Figure 5.13 uses these elementary facts to show that M0=
Z1X2X3Z4leaves both codewords invariant, by demonstrating that it
can be brought to the left through all the gates in the circuit to act onthe input state |x0000/angbracketrightas
Z2.Figures 5.14–5.16 show similar things
forM1=Z2X3X4Z0,M2=Z3X4X0Z1, and M3=Z4X0X1Z2, which
can be brought to the left through all the gates to act on the input stateas
Z0,Z3, and Z1. Figure 5.17 shows that X=X0X1X2X3X4can be
brought to the left through all the gates of the circuit to act on theinput state |x0000/angbracketrightas
X4Z2Z1, which simply interchanges x=0 and

<<<PAGE 147>>>

1 3 0 QUANTUM ERROR CORRECTION
=
==
=(a) (b)
(d) (c)X XX X X
ZZZZ
Z
Fig 5.12 Easily veriﬁable identities useful in determining how various
products of Xs and Zs act on the circuit of Figure 5.11. (a) A cNOT
can be interchanged with an Xacting on the control Qbit, if another X
acting on the target Qbit is introduced. (b) A cNOT commutes with an
Xacting on the target Qbit. (c) A cNOT can be interchanged with a Z
acting on the target Qbit, if another Zacting on the control Qbit is
introduced. (d) A cNOT commutes with a Zacting on the control
Qbit.
x=1, thereby demonstrating that Xacts as logical Xon the codewords.
Figure 5.18 shows the analogous property for Z=Z0Z1Z2Z3Z4, which
can be brought to the left through all the gates of the circuit to act on theinput state |x0000/angbracketrightas
Z4Z3Z0, which multiplies it by ( −1)x, thereby
demonstrating that Zacts as logical Zon the codewords. Finally Fig-
ures 5.19 and 5.20 show that the inner product of the codeword state |0/angbracketright
with the computational-basis state |00000/angbracketrightis1
4, thereby demonstrating
that the circuit produces the codewords (5.33) with the right phase.
In Appendix O this circuit-theoretic approach is used to give a sec-
ond (more complicated, but instructive) demonstration of the validityof the 7-Qbit encoding circuit of Figure 5.10.

<<<PAGE 148>>>

5.9 A 5-QBIT ENCODING CIRCUIT 1 3 1
0000x
0134
2
0134
2
(a) (b) (d)( c) (e) (f) (g)M0H
H
ZXZ
X
HH
HH
H
Z
X
ZX
X
ZX
ZZZX
XZZXZZZ
Z ZZHZ
Fig 5.13 Demonstration that M0=Z1X2X3Z4acting on the output
of the encoding circuit in Figure 5.11 is the same as Z2acting on the
input, which leaves the input invariant. On the extreme left M0is
applied to the output of the circuit. The insets (a)–(g) show whathappens as the
XandZgates making up M0are moved to the left
through the gates of the circuit. (a) Z4andX3are changed to X4and
Z3as a result of having been brought through Hadamard gates. (b)
Bringing the two Xgates through the control Qbits of cNOT gates
produces a pair of cancelling Xgates on the common target Qbit, so
the set of gates in (a) is unchanged when it is moved to (b). (c) TheHadamard gates convert
X4andZ1toZ4andX1. (d) Bringing X2
through the control Qbit of the cNOT produces an Xon its target
Qbit which cancels the Xalready there. (e) The Hadamard on Qbit 2
converts the Xto aZ. (f) Moving the Z2through the targets of the two
cNOTs produces Zgates on their control Qbits which cancel the two
Zgates already there. (g) The resulting Z2can be moved all the way to
the left.

<<<PAGE 149>>>

1 3 2 QUANTUM ERROR CORRECTION
0000x
0134
2
0134
2M1
(a) (c) (b)HH
HH
HH
H
ZX
X
Z
Z
Z Z ZZHZ
Z
Z
Fig 5.14 Using the identities in Figure 5.12 and the fact that bringing
aZthrough a Hadamard converts it to an Xand vice versa establishes
that M1can be brought to the left through the gates of the encoding
circuit to act directly on |x0000/angbracketrightasZ0.
0000x
0134
2
0134
2M2
(a) (b) (c) (d) (e) (f) (g) (h)HH
HH
HH
H
Z
XX
ZZHZ
XX
X
XZ
X
ZZ
X
ZX
XX
XZ
ZZ Z
Fig 5.15 M2can be brought to the left through the gates of the
encoding circuit to act directly on |x0000/angbracketrightasZ3.

<<<PAGE 150>>>

0000x
0134
2
0134
2
(d)M3
(a) (b) (c) (e)HH
HH
HH
H
Z
X
XZ
XXZ Z
XZZ
Z Z ZZHZ
X X
Fig 5.16 M3can be brought to the left through the gates of the
encoding circuit to act directly on |x0000/angbracketrightasZ1.
X0000x
−Z −Z 4
3
2
1
0
(a) (b) (c) (e)( d) (i)( g) (h)( f)2
14
3
0HH
HH
H
X
X
XZ XZ
XZ
Z ZH
HZHZ
ZZXZ Z
Z
ZZZX
X
X
Z
Z
XZ
ZX
XZ
XZZ
XZX
Z
ZX
Z X
X
Fig 5.17 Demonstration that X=X0X1X2X3X4acting on the output
of the encoding circuit in Figure 5.11 is the same as X4Z2Z1acting on
the input, which interchanges |00000/angbracketrightand|10000/angbracketright. (a) Bringing X4
andX3through the Hadamards converts them to Z4andZ3. (b)
Bringing X2through the cNOT controlled by Qbit 2 produces an Xon
the target Qbit 0, which cancels the Xalready there. (c) The
Hadamards convert Z4andX1toX4andZ1. (d) Bringing X4andX2to
the left produces two X1gates which cancel; bringing Z1to the left
then produces additional Z4andZ2gates. (e) The Hadamard H2
interchanges the X2andZ2gates. (f) First bring to the left the Z2gate,
then the X4gate. (g) The H4converts ZXZ toXZX=− Z. (h) No
further changes. (i) Zcommutes with itself, is changed to Xon passing
through H, and acquires another minus sign on passage through Z.

<<<PAGE 151>>>

1 3 4 QUANTUM ERROR CORRECTION
0000x
(a) (c) (e) (i)( g) (h)( f)Z
(b) (d)4
3
2
10
4
3
21
0HH
HH
HH
HZHZ
Z
Z ZZZ
Z Z ZXZ
ZX
ZXZ
ZXZ
ZZ
X
X
ZZ
Z
Z X ZXZ
ZXXZ
ZXXZ
ZX
ZZ
ZX
X
ZZ−X
Fig 5.18 Demonstration that Z=Z0Z1Z2Z3Z4acting on the output
of the encoding circuit in Figure 5.11 is the same as Z4Z3Z0acting on
the input, which takes |x0000/angbracketrightinto (−1)x|x0000/angbracketright.
Φ Ψ Φ
ΩΨ Φ Ω A B Ω B A = ΦB AB A =
=(a)
(b)
Fig 5.19 A circuit-theoretic way to evaluate inner products. (a) A
circuit taking the input |/Phi1/angbracketrightinto the output |/Psi1/angbracketright=BA|/Phi1/angbracketright.The inner
product /angbracketleft/Psi1|/Omega1/angbracketrightof the output state /Psi1with some other state |/Omega1/angbracketrightis given
by/angbracketleft/Phi1|A†B†|/Omega1/angbracketright. The diagram on the right in (b) shows this inner
product being evaluated by ﬁrst letting B†act on |/Omega1/angbracketright, then letting A†
act on the result, and then taking the inner product with the input state
|/Phi1/angbracketright. Evidently this generalizes to the product of many gates. If the
gates are all Hermitian, as they are in the circuit of Figure 5.11, thenthe circuit on the right of (b) is identical to the circuit on the left of (a).The resulting evaluation of the inner product of |/Omega1/angbracketright=| 0/angbracketright
5with the
state|0/angbracketrightproduced by letting the circuit of Figure 5.11 act on
|/Phi1/angbracketright=| 0/angbracketright5is carried out in Figure 5.20.

<<<PAGE 152>>>

0001
20 0114
11===
=+
00 11
4014 14011
001 11
4=
0
0
0
0
0
000000
0
0
0
0
00000
00 1(a)
(b)
(c)
(d)
(e)H
H H
Z HH
Z HH
HH
HHHH
H
HH H
HZHZ
HH
H
HH H
HXH
H
Z
Fig 5.20 Demonstration that the state produced by the encoding
circuit in Figure 5.11 when x=0 has an inner product with the state
|0/angbracketright5that is1
4, thereby establishing that the phase factor eiϕ=1 – i.e.
that the state is precisely |0/angbracketrightwithout any additional phase factor. (a)
Circuit-theoretic representation of the inner product, following theprocedure developed in Figure 5.19; all gates now act to the right. (b)Elimination of operations in (a) that act as the identity: the cNOT onthe extreme right of (a) can be dropped since its control Qbit is in thestate|0/angbracketright; since
H|0/angbracketrightis invariant under X, the pair of cNOT gates
targeting Qbit 1 can be dropped, as can the pair targeting Qbit 2. (c) Apair of Hadamards on Qbit 4 in (b) cancel; a Hadamard on Qbit 3 in (b)is moved to the left converting a cNOT to a controlled- Z; Qbits 2 and
1 in (b) simply give the matrix element /angbracketleft0|
H|0/angbracketright=1√
2, resulting in an
overall factor of1
2. (d) Expanding both states H|0/angbracketright=1√
2(|0/angbracketright+| 1/angbracketright)o n
the right of (c), the effect of the two cNOT gates in (c) is that only the
terms in |0/angbracketright|0/angbracketrightand|1/angbracketright|1/angbracketrightgive nonzero contributions. (e) The action of
the controlled- Zgates in (d) has been carried out, leaving a sum of
products of matrix elements of H.

<<<PAGE 153>>>

Chapter 6
Protocols that use just a few Qbits
6.1 Bell states
In this chapter we examine some elementary quantum information-
theoretic protocols which are often encountered in the context of quan-tum computation, though they also have applications in the broaderarea of quantum information processing. Because they use only a smallnumber of Qbits, they have all been carried out in at least one laboratory,unlike any but the most trivial and atypical examples of the protocolswe have considered in earlier chapters.
Most of these examples make use of the 2-Qbit entangled state,
|ψ
00/angbracketright=1√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
. (6.1)
This state can be assigned to two Qbits, each in the state |0/angbracketright, by applying
a Hadamard to one of them, and then using it as the control Qbit for acNOT that targets the other (Figure 6.1(a)):
|ψ
00/angbracketright= C10H1|00/angbracketright. (6.2)
We generalize (6.2) by letting the original pair of unentangled Qbits
be in any of the four 2-Qbit computational-basis states |00/angbracketright,|01/angbracketright,|10/angbracketright,
and|11/angbracketright(Figure 6.1(b)):
|ψxy/angbracketright= C10H1|xy/angbracketright. (6.3)
Since the four states |xy/angbracketrightare an orthonormal set and the Hadamard
and cNOT gates are unitary, the four entangled states |ψxy/angbracketrightare also an
orthonormal set, called the Bell basis to honor the memory of the physi-
cist John S. Bell, who discovered in 1964 one of the most extraordinaryfacts about 2-Qbit entangled states. We examine a powerful 3-Qbitversion of Bell’s theorem in Section 6.6.
If we rewrite (6.3) as
|ψ
xy/angbracketright= C10H1Xx
1Xy
0|00/angbracketright, (6.4)
and recall that HX=ZHand that either a Zon the control Qbit or an
Xon the target Qbit commutes with a cNOT , then we have
|ψxy/angbracketright= Zx
1Xy
0C10H1|00/angbracketright= Zx
1Xy
01√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
, (6.5)
136

<<<PAGE 154>>>

6.2 QUANTUM CRYPTOGRAPHY 1 3 7
00 xy
(a) (b)H
y
00 H
yx
y
Fig 6.1 (a) A circuit that creates the entangled state
|ψ00/angbracketright=1√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
from the unentangled computational-basis
state|00/angbracketright. (b) A circuit that creates the four orthonormal entangled
Bell states |ψxy/angbracketrightfrom the unentangled computational-basis state |xy/angbracketright.
xyy = ==
yxH
00xH
yX 00Hx
yXXZ
Fig 6.2 The Bell states |ψxy/angbracketrightcan be constructed from
|ψ00/angbracketright=1√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
by ﬂipping a single Qbit, changing the sign
from + to −, or doing both of these.
as illustrated in Figure 6.2. This shows that the other Bell states are
obtained from (1 /√
2)(|00/angbracketright+| 11/angbracketright) by ﬂipping one of the Qbits, by
changing the +to a−, or by doing both. This, of course, can also be
derived directly from (6.3) by letting the Hadamard and cNOT act for
each of the four choices for the pair xy.
We now examine a few simple protocols in which some or all of
the Bell states (or, in Section 6.6, their 3-Qbit generalizations) play animportant role.
6.2 Quantum cryptography
A decade before Shor’s discovery that quantum computation posed athreat to the security of RSA encryption, it was pointed out that Qbits(though the term did not exist at the time) offered a quite different anddemonstrably secure basis for the exchange of secret messages.
Of all the various possible applications of quantum mechanics to in-
formation processing, quantum cryptography arguably holds the mostpromise for becoming a practical technology. There are several reasonsfor this. First of all, it works Qbit by Qbit. The only relevant gates area small number of simple 1-Qbit gates. Interactions between pairs ofQbits like those mediated by cNOT gates play no role, at least in themost straightforward versions of the protocol.
Furthermore, in actual realizations of quantum cryptography the
physical Qbits are extremely simple. Each Qbit is a single photon

<<<PAGE 155>>>

1 3 8 PROTOCOLS THAT USE JUST A FEW QBITS
of light. The state of the Qbit is the linear polarization state of the
photon. If the states |0/angbracketrightand|1/angbracketrightdescribe photons with vertical and
horizontal polarization, then the states H|0/angbracketright=(1/√
2)/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
and
H|1/angbracketright=(1/√
2)/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
describe photons diagonally polarized, ei-
ther at 45◦or at−45◦to the vertical. Photons in any of these four
polarization states can be prepared in any number of ways, most sim-ply (if not most efﬁciently) by sending a weak beam of light through anappropriately oriented polaroid ﬁlter. Once a photon has been preparedin its initial polarization state it does not have to be manipulated anyfurther beyond eventually measuring either its horizontal–vertical orits diagonal polarization by, for example, sending it through an appro-priately oriented birefringent crystal and seeing which beam it emergesin, or seeing whether it does or does not get through another appropri-ately oriented polaroid ﬁlter. Photons can effectively be shielded fromextraneous interactions by sending them through optical ﬁbers, wherethey can travel in a polarization-preserving manner at the speed of light.
This procedure can be viewed as the simplest possible quantum
computation. First the Qbit is assigned an initial state by sending itthrough a 1-Qbit measurement gate. Then a 1-Qbit unitary gate isor is not applied (depending on whether a subsequent polarizationmeasurement is to be along the same direction as the ﬁrst). And ﬁnallythe Qbit is sent through a second 1-Qbit measurement gate.
The usefulness of easily transportable single Qbits for secret com-
munication stems from one important cryptographic fact: Alice andBob can have an unbreakable code if they share newly created identi-cal strings of random bits, called one-time codepads . If they both have
such identical random strings, then Alice can take her message, in theform of a long string of zeros and ones, and transform it into its bitwisemodulo-2 sum (also called the exclusive or or XOR) with a random string
of zeros and ones of the same length taken from her one-time codepad.Flipping or not ﬂipping each bit of a coherent message according towhether the corresponding bit of a random string is 0 or 1 convertsthe message into another random string. (If this is not obvious, thinkof the process as ﬂipping or not ﬂipping each bit of the random string,according to whether the corresponding bit of the coherent message is0 or 1.) Nobody can reconstruct the original string without knowingthe random string used to encode it, so only Bob can decode the mes-sage. He does this by taking the XOR of the now meaningless stringof zeros and ones, received from Alice, with his own copy of the ran-dom string that she used to do the encoding. The string he gets in thisway is M⊕S⊕S, where Mis the message, Sis the random string,
and M⊕Sis the encoded message from Alice. Since S⊕S=0, Bob
recovers the original message.
The problem with one-time codepads is that they can be used only
once. If an eavesdropper (Eve) picks up two messages encoded with

<<<PAGE 156>>>

6.2 QUANTUM CRYPTOGRAPHY 1 3 9
the same pad, she can take the XOR of the two encoded messages. The
random string used to encode the two messages drops out of the pro-cess, leaving the XOR of the two unencoded messages. But the XORof two meaningful messages, combined with the usual code-breakingtricks based on letter frequencies, can be used (with more subtletythan would be required for a single message) to separate and decodeboth texts. So to be perfectly secure Alice and Bob must continu-ally refresh their one-time codepad with new identical random stringsof bits.
The problem of exchanging such random strings in a secure way
might appear to be identical to the original problem of exchangingmeaningful messages in a secure way. But at this point quantum me-chanics comes to the rescue and provides an entirely secure means forexchanging identical sequences of random bits. Pause to savor this sit-uation. Nobody has ﬁgured out how to exploit quantum mechanics toprovide a secure means for directly exchanging meaningful messages.The secure exchange is possible only because the bit sequences arerandom. On the face of it one would think nothing could be more use-less than such a transmission of noise. What is bizarre is that humaningenuity combined with human perversity has succeeded in inventinga context in which the need to hide information from a third partyactually provides a purpose for such an otherwise useless exchange ofrandom strings of bits.
The scheme for doing this is known as BB84 after its inventors,
Charles Bennett and Gilles Brassard, who published the idea in 1984.Alice sends Bob a long sequence of photons. For each photon Alice ran-domly chooses a polarization type for the photon (horizontal–verticalor diagonal) and within each type she randomly chooses a polariza-tion state for the photon – one of the two orthogonal states associatedwith that type of polarization. In Qbit language Alice sends Bob a longsequence of Qbits randomly chosen to be in one of four states: |0/angbracketright(polar-
ized horizontally), |1/angbracketright(polarized vertically),
H|0/angbracketright=(1/√
2)(|0/angbracketright+| 1/angbracketright)
(polarized diagonally along 45◦), or H|1/angbracketright=(1/√
2)(|0/angbracketright−| 1/angbracketright) (polar-
ized diagonally along −45◦).
Reverting from photon-polarization language to our more familiar
quantum-computational language, we divide the four equally likelytypes of Qbits that Alice sends to Bob into two categories: those withstate|0/angbracketrightor|1/angbracketright, which we call type-1 Qbits, and those with state
H|0/angbracketrightor
H|1/angbracketright, which we call type- HQbits. As each Qbit arrives Bob randomly
decides whether to send it directly through a measurement gate, orto apply a Hadamard and only then send it through a measurementgate. We call these two options type-1 and type- Hmeasurements. The
Qbits must be individually identiﬁable – for example by the sequencein which they arrive – so that Alice and Bob can compare what each ofthem knows about each one.

<<<PAGE 157>>>

1 4 0 PROTOCOLS THAT USE JUST A FEW QBITS
29 1 345678
Type:
State:
Outcome:1
0
1100111000 0 1 0 1 1 0 1
HHHH1 1 1 H
H H 11 H111.  .  .
.  .  .
.  .  .Bob:Alice:.  .  ..  .  .
ment type:Measure-HFig 6.3 Quantum
cryptography. For eachQbit she sends to Bob,Alice randomly decideswhich type of state toprepare it in (type
1means
|x/angbracketrightand type Hmeans
H|x/angbracketright) and which state of
that type ( x=0o r1 )t o
prepare. For each Qbit hereceives from Alice, Bobrandomly decides whether(
H) or not ( 1) to apply a
Hadamard gate beforemeasuring it. In those cases(about half, enclosed inrectangular boxes) forwhich Bob’s choice ofmeasurement type is thesame as Alice’s choice ofstate, they acquire identicalrandom bits. When theirchoices differ they acquireno useful information.When Bob has measured all the Qbits in this way, Alice tells him
over an insecure channel which of the Qbits she sent him were type-1 and which were type- H. But she does not reveal which of the two
possible states she prepared within each type: |0/angbracketrightor|1/angbracketrightfor type-1 Qbits
and
H|0/angbracketrightorH|1/angbracketrightfor type- H. For those Qbits (about half of them) for
which Bob’s random choice of measurement type agrees with Alice’srandom choice of which type to send, Bob learns from the result of hismeasurement the actual random bit – 0 or 1 – that Alice chose to send.For those Qbits (the other half) for which Bob’s choice of which type tomeasure disagrees with Alice’s choice of which type to send, the resultof his measurement is completely uncorrelated with Alice’s choice ofbit, and reveals nothing about it. This is illustrated in Figure 6.3.
Finally, Bob tells Alice, over an insecure channel, which of the Qbits
he subjected to a type of measurement that agreed with her choice ofwhich type to prepare – i.e. which Qbits were of the kind that providesthem with identical random bits. They discard the useless half of theirdata for which Bob’s type of measurement differed from Alice’s type of
preparation. They are then able to construct their one-time codepads
from the identical strings of random bits they have acquired.
You might wonder why Bob doesn’t wait to decide what type of
measurement to make on each Qbit until he learns Alice’s choice oftype for that photon, thereby doubling the number of shared randombits. This would indeed be a sensible strategy if Bob could store theQbits he received from Alice. However, storing individual photonsin a polarization-preserving manner is difﬁcult. For feasible quantumcryptography today, Bob must make his decision and measure the po-larization of each photon as it arrives.
The reason Alice randomly varies the type of Qbit she sends to
Bob is to provide security against eavesdroppers. If Alice sent all Qbitsof the same type, then an eavesdropper, Eve, could acquire the sameinformation as Bob without being detected. If, for example, Alice andBob had agreed that all the Qbits would be type-1 and Eve learnedof this, then she could intercept each Qbit before it reached Bob andsend it directly through a measurement gate without altering its state,subsequently sending it (or another Qbit she prepared in the state shejust learned) on to Bob. In this way she too could acquire the random

<<<PAGE 158>>>

6.2 QUANTUM CRYPTOGRAPHY 1 4 1
bit that Alice sends out and that Bob subsequently acquires when he
makes his own type-1 measurement. Nothing in the protocol wouldgive Bob a clue that Eve was listening in. But by making each Qbitsecretly and randomly of type 1 or type HAlice deprives Eve of this
strategy.
The best Eve can do, like Bob, is to make type-1 or type- Hmeasure-
ments randomly. In doing so she necessarily reveals her presence. Boband Alice can determine that Eve has compromised the security of theirbits by sacriﬁcing some of the supposedly identical random bits theyextracted from the Qbits they both ended up treating in the same way.They take a sample of these bits and check (over an insecure channel)to see whether they actually do agree, as they would in the absence ofeavesdropping. If Eve intercepts the Qbits, randomly making type-1 ortype- Hmeasurements of her own before sending them on to Bob, then
for about half of the useful Qbits her choice will differ from the commonchoice of Alice and Bob. In about half of those cases, Eve’s intervention
will result in the outcome of Bob’s measurement disagreeing with whatAlice sent him. If, for example, Eve makes a type-1 measurement of aQbit that Alice has prepared in the state
H|0/angbracketright, then she will necessarily
change its state to one or the other of the two states |0/angbracketrightor|1/angbracketright. In either
case if Bob then applies a Hadamard before measuring he will get theresult 0 only half the time.
So if Eve is systematically intercepting Qbits, Bob’s result will fail
to agree with Alice’s preparation for about a quarter of their sample.This warns them that the transmission was insecure. If all the sampledata agree except for a tiny fraction, then they can set an upper limitto the fraction of bits that Eve might have picked up, enabling them tomake an informed judgment of the security with which they can usethe remaining ones.
Can Eve do better by a more sophisticated attack, that involved
capturing each of Alice’s Qbits and processing it in a quantum computerthat restored it to its initial state, before sending it on to Bob? Thiswould eliminate the possibility of her eavesdropping being revealed toBob. But the requirement that Alice’s Qbit be returned to its initialstate also eliminates the possibility of Eve learning anything useful, forreasons rather like our earlier proof of the no-cloning theorem.
Let|φ
µ/angbracketright,µ=0,... , 3, be the four possible states of Alice’s Qbit:
|0/angbracketright,|1/angbracketright,H|0/angbracketright, and H|1/angbracketright. Let|/Phi1/angbracketrightbe the initial state of the nQbits in
Eve’s computer, and let Ube the ( n+1)-Qbit unitary transformation
the computer executes on its own Qbits and Alice’s. Since Alice’s Qbitmust emerge in its original state, we have
U/parenleftBig
|φµ/angbracketright⊗|/Phi1/angbracketright/parenrightBig
=|φµ/angbracketright⊗|/Psi1µ/angbracketright. (6.6)
Eve’s hope is to devise a Uthat yields four |/Psi1µ/angbracketrightwhose differences
enable her, by subsequent processing and measurement, to extract

<<<PAGE 159>>>

1 4 2 PROTOCOLS THAT USE JUST A FEW QBITS
useful information about which of the four possible states |φµ/angbracketrightwas.
But unitary transformations preserve inner products, so
/angbracketleftφν|φµ/angbracketright/angbracketleft/Phi1|/Phi1/angbracketright=/angbracketleftφν|φµ/angbracketright/angbracketleft/Psi1ν|/Psi1µ/angbracketright. (6.7)
Because /angbracketleft/Phi1|/Phi1/angbracketright=1 and because /angbracketleftφν|φµ/angbracketright/negationslash=0f o rµν=02,03,12,13,
it follows that
/angbracketleft/Psi1ν|/Psi1µ/angbracketright=1,µ ν =02,03,12,13. (6.8)
Since the inner product of two normalized states can be 1 only if they
are identical, it follows from (6.8) that
|/Psi10/angbracketright=|/Psi11/angbracketright=|/Psi12/angbracketright=|/Psi13/angbracketright. (6.9)
The price Eve pays for eliminating all traces of her eavesdropping is
that the resulting state of her quantum computer can teach her nothingwhatever about the four possible states of Alice’s Qbit.
There is a less practical version of this cryptographic protocol that
appears, at ﬁrst sight, to be different, but turns out to be exactly thesame. Suppose that there were some central source that produced pairsof Qbits in the entangled state
|/Psi1/angbracketright=
1√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
, (6.10)
and then sent one member of each pair to Alice and the other to Bob.
One easily veriﬁes that
/parenleftbig
H⊗H/parenrightbig1√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
=1√
2/parenleftbig
|00/angbracketright+| 11/angbracketright/parenrightbig
, (6.11)
so if Alice and Bob make measurements of the same type, they will get
identical random results.
This might seem even more secure than the ﬁrst protocol, since
the Qbits are in an entangled state until Alice or Bob actually makes ameasurement. The correlated bits – the outcomes of the measurement –do not even exist until a measurement has been made, and that does
not happen until both Qbits are safely in Alice’s and Bob’s separatepossession. But this is only the case if Eve does not intercept a Qbit. Ifshe does measure one before it gets to Bob or Alice, then the correlatedbits do come into existence at the moment of her own measurement.This is later than in the ﬁrst protocol (when each bit exists from themoment Alice performs her measurement) but early enough to helpEve in the same way as before.
If Alice and Bob decided to produce their perfectly correlated ran-
dom bits by always making type-1 measurements then if Eve ﬁnds thisout she can intercept one member of the pair with type-1 measurementsof her own, disentangling the state prematurely, but in a way that en-ables her to learn what each random bit is, while not altering the perfectcorrelations between the values Alice and Bob will subsequently mea-sure. Alice and Bob can guard against this possibility by each randomly

<<<PAGE 160>>>

6.3 BIT COMMITMENT 1 4 3
(and, necessarily, independently) alternating between type-1 and type-
Hmeasurements, and then following a procedure identical to the one
they used when Alice sent Bob Qbits in deﬁnite states.
This returns us to the original protocol that made no use of entangled
pairs. Indeed, if Alice measures her member of the entangled pair(making either a type-1 or a type- Hmeasurement) before Bob measures
his, this is equivalent to her sending Bob a Qbit with a randomly selectedstate that she knows. The only difference is that now the random choiceof which of the two states to send within each type is not made byAlice tossing a coin, but by the basic laws of quantum mechanics thatguarantee that the outcome of her own measurement is random.
6.3 Bit commitment
One can try to formulate a similar protocol for a procedure called bitcommitment. Suppose that Alice wishes to assure Bob that she hasmade a binary decision by a certain date, but does not wish to revealthat decision until some future time. She can do this by writing YES orNO on a card, putting the card in a box, locking the box, and sendingthe box, but not the key, to Bob. Once the box is in Bob’s possession hecan be sure that Alice has not altered her decision, but while the key isin Alice’s possession she can be sure that Bob has not learned what thatdecision was. When it is time for her to reveal the decision she sendsthe key to Bob who opens the box and learns what it was.
Of course Alice might worry about Bob breaking into the box by
other means. Quantum mechanics offers a more secure procedure (butwith an exotic loophole, which we return to momentarily). Alice pre-pares a large number nof labeled Qbits. If her answer is YES, she takes
each Qbit to be randomly in the state |0/angbracketrightor the state |1/angbracketright. If her answer
is NO, she prepares each Qbit randomly in the state
H|0/angbracketrightorH|1/angbracketright.I n
either case she notes which Qbits are in which state, and then sendsthem all off to Bob, who stores them in a way that preserves both theirstate and their labels. (As noted above, such storage is beyond the rangeof current technology for polarized photons.)
If Bob has a collection of nQbits, each of which has been chosen
with equal probability to be in one of two orthogonal states |φ/angbracketrightand|ψ/angbracketright,
then there is no way for Bob to get any hint of what the two orthogonalstates are. If, for example, he measures every Qbit, then the probabilityof getting 0 is
p(0)=
1
2|/angbracketleft0|φ/angbracketright|2+1
2|/angbracketleft0|ψ/angbracketright|2. (6.12)
But
|/angbracketleft0|φ/angbracketright|2+| /angbracketleft0|ψ/angbracketright|2=1, (6.13)

<<<PAGE 161>>>

1 4 4 PROTOCOLS THAT USE JUST A FEW QBITS
since this is the sum of the squared moduli of the amplitudes of the
expansion of |0/angbracketrightin the orthonormal basis given by |φ/angbracketrightand|ψ/angbracketright:
|0/angbracketright=|φ/angbracketright/angbracketleftφ|0/angbracketright+|ψ/angbracketright/angbracketleftψ|0/angbracketright. (6.14)
So p(0)=1
2. Bob’s measurement outcomes are completely random,
regardless of what the orthogonal pair of states actually is.
In Appendix P it is shown, more generally, that no information Bob
can extract from his collection of Qbits can distinguish between thecase in which each has a 50–50 chance of being in the state |0/angbracketrightor|1/angbracketright
and the case in which each has a 50–50 chance of being in the state
H|0/angbracketrightorH|1/angbracketright. There is no way Bob can learn Alice’s choice from the
Qbits that Alice has sent him. He cannot break into the locked box.
(It is crucial for Bob’s inability to learn Alice’s choice that, regardless
of what that choice is, she sends him a collection of Qbits each of whosetwo possible states is picked randomly. If, for example, she sent himexactly
1
2nQbits in the state |0/angbracketrightand1
2nin the state |1/angbracketright, in some random
order, then with probability 1 Bob would get an equal number of zerosand ones if he measured in the computational basis. But if he applied
H
before measuring, the outcome of each measurement would be random,and the probability of getting equal numbers of zeros and ones for hismeasurements would be quite small (asymptotically√
2/(πn)) for large
n. So if he got equal numbers of zeros and ones he could be rather sure
that Alice had sent him photons in the states |0/angbracketrightand|1/angbracketrightrather than in
the states H|0/angbracketrightandH|1/angbracketright.)
When the time comes for Alice to reveal her choice for the pair of
orthogonal states, she says to Bob something like this: “My answer wasYES, so each of the Qbits I sent you was either in the state |0/angbracketrightor in the
state|1/angbracketright. To prove this I now tell you that I put Qbits 1, 2, 4, 6, 7, 11,
...into the state |0/angbracketrightand I put Qbits 3, 5, 8, 9, 10, 12, ...into the state
|1/angbracketright. You can conﬁrm that I’m telling the truth by measuring each Qbit
directly.”
Bob makes the direct measurements and gets every one of Alice’s
predicted outcomes. If instead Alice had sent him Qbits whose stateswere randomly
H|0/angbracketrightorH|1/angbracketrightshe could do the same trick by telling Bob
exactly what he would ﬁnd if he preceded each of his measurementswith a Hadamard gate. But there is no way she could do the trickfor measurements preceded by Hadamard gates in the ﬁrst case orfor direct measurements in the second. The best she could do if shewanted to deceive Bob would be to make random guesses for eachoutcome, and with nQbits she would succeed in fooling him only with
probability 1 /2
n. So this works perfectly well, and without the worry
of Bob possessing unexpected safe-cracking skills.
But, as noted above, there is a loophole – in fact, a fatal problem.
The technological skills required to take advantage of the loophole arespectacularly greater than those required for the naive protocol, so onecould imagine a stretch of years, decades, or even centuries during

<<<PAGE 162>>>

6.3 BIT COMMITMENT 1 4 5
which the naive protocol might actually be useful. But ultimately it
will be insecure. Suppose that Alice, unknown to Bob, has actuallyprepared nlabeled pairs in the entangled state (6.10), sending one
member to Bob while retaining the other for herself. Then the QbitsBob receives will have no states of their own, being entangled with the
Qbits Alice keeps for herself. Nevertheless, if Bob chooses to test some
of them with measurements, (6.11) insures that the results he gets willbe indistinguishable from the random outcomes he would have got ifAlice had been playing the game honestly. No hint of her deceptionwill be revealed by any test Bob can perform.
But now when the time comes for Alice to reveal her choice, if she
wants to prove to Bob that it was YES, she makes a direct measurementon each of the Qbits she has kept and correctly informs Bob what he willget if he makes a direct measurement on each of the paired Qbits. But ifshe wants to prove that it was NO, she instead applies Hadamards beforemeasuring each of her Qbits, enabling her, because of the identity (6.11),to tell Bob what he will ﬁnd if he also applies Hadamards before mea-suring his own Qbits. So she can use entangled pairs of Qbits to cheat atwhat would otherwise be a perfectly secure bit-commitment protocol.
Alice can cheat in the same way even if Bob measures his Qbits
(randomly applying or not applying a Hadamard before each measure-ment) before she “reveals” her commitment. If she wants to “prove”to Bob she had sent him YES she directly measures each of her Qbitsand tells Bob all her results. He notes that they do indeed agree withall the results he found for his direct measurements, and is persuadedthat she had indeed sent him YES. To “prove” she sent him NO sheapplies Hadamards before measuring each of her Qbits.
Of course the success of Alice’s cheating depends crucially on Bob’s
knowing all about 1-Qbit states, but never having taken the kind ofcourse in quantum mechanics that would have taught him anythingabout entangled 2-Qbit states. If Bob is as sophisticated a student ofthe quantum theory as Alice, they will both realize that the protocol isfatally ﬂawed, since it can be defeated by entanglement.
It is in this context that Einstein’s famous complaint about spooky
actions at a distance (“ spukhafte Fernwirkungen ”) seems pertinent. By
ﬁnally measuring her members of the entangled pairs, Alice seems toconvert the distant Qbits in Bob’s possession into the kind she decep-tively said she had sent him long ago, while retaining until the lastminute the option of which of the two kinds to pick. But of courseAlice’s action is not so much on the Qbits in Bob’s possession as it is onwhat it is possible for her to tell him about what he can learn from those
Qbits. It is this peculiar tension between what is objective (ontology)and what is known (epistemology) that makes quantum mechanics sucha source of delight (or anguish) to the philosophically inclined.
Something like Alice’s discovery of the value of entanglement for
cheating actually happened in the historical development of these ideas

<<<PAGE 163>>>

1 4 6 PROTOCOLS THAT USE JUST A FEW QBITS
about quantum information processing. When the bit-commitment
protocol described above was ﬁrst put forth it was realized that entan-gled pairs could be used to thwart it, but more sophisticated versionswere proposed that were believed to be immune to cheating with en-tanglement. There developed a controversy over whether some formof bit commitment could or could not be devised that would be secureeven if entanglement were fully exploitable. The current consensus isthat there is no way to use Qbits in a bit-commitment protocol thatcannot be defeated by using entangled states. Indeed, it has even beensuggested that the structure of quantum mechanics might be uniquelydetermined by requiring it to enable the secure exchange of randomstrings of bits, as in quantum cryptography, but not to enable bit com-mitment. Nobody has managed to show this. It does seem implausiblethat God would have taken as a fundamental principle of design thatcertain kinds of covert activity should be possible while others shouldbe forbidden.
6.4 Quantum dense coding
Although an inﬁnite amount of information is needed to specify thestate|ψ/angbracketright=α|0/angbracketright+β|1/angbracketrightof a single Qbit, there is no way for somebody
who has acquired possession of the Qbit to learn what that state is, as wehave often noted. If Alice prepares a Qbit in the state |ψ/angbracketrightand sends it
to Bob, all he can do is apply a unitary transformation of his choice andthen measure the Qbit, getting the value 0 or 1. After that the state ofthe Qbit is either |0/angbracketrightor|1/angbracketrightand no further measurement can teach him
anything about its original state |ψ/angbracketright. The most Alice can communicate
to Bob by sending him a single Qbit is a single bit of information.
If, however, Alice has one member of an entangled pair of Qbits in
the state
|/Psi1/angbracketright=
1√
2/parenleftbig
|0/angbracketright|0/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
(6.15)
and Bob has the other, then by suitably preparing her member of the
pair and then sending it to Bob, she can convey to him twobits of
information. She does this by ﬁrst applying the transformation 1,X,Z,
orZXto her Qbit, depending on whether she wants to send Bob the
message 00, 01, 10, or 11. If hers is the Qbit on the left in (6.15) thesetransform the state of the pair into one of the four mutually orthogonalBell states (6.5),
1a|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright|0/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
,
Xa|/Psi1/angbracketright=1√
2/parenleftbig
|1/angbracketright|0/angbracketright+| 0/angbracketright|1/angbracketright/parenrightbig
,
(6.16)
Za|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright|0/angbracketright−| 1/angbracketright|1/angbracketright/parenrightbig
,
ZaXa|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright|1/angbracketright−| 1/angbracketright|0/angbracketright/parenrightbig
.

<<<PAGE 164>>>

6.4 QUANTUM DENSE CODING 1 4 7
She then sends her Qbit over to Bob. He sends the pair through the
controlled-NOT gate Cab, using the Qbit he received from Alice as
control, to get
Cab1a|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
|0/angbracketright,
CabXa|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
|1/angbracketright,
(6.17)
CabZa|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
|0/angbracketright,
CabZaXa|/Psi1/angbracketright=1√
2/parenleftbig
|0/angbracketright−| 1/angbracketright/parenrightbig
|1/angbracketright,
and then he applies a Hadamard transform to get
HaCab1a|/Psi1/angbracketright=| 0/angbracketright|0/angbracketright,
HaCabXa|/Psi1/angbracketright=| 0/angbracketright|1/angbracketright,
(6.18)
HaCabZa|/Psi1/angbracketright=| 1/angbracketright|0/angbracketright,
HaCabZaXa|/Psi1/angbracketright=| 1/angbracketright|1/angbracketright.
Measuring the two Qbits then gives him 00, 01, 10, or 11 – precisely
the two-bit message Alice wished to send.
This process of transforming the Bell basis back into the compu-
tational basis – i.e. undoing the process (6.3) by which the Bell basiswas constructed from the computational basis – and then measuring iscalled “measuring in the Bell basis.”
One can directly demonstrate that this works with circuit diagrams,
without going through any of the analysis in (6.15)–(6.18). Supposethat Alice represents the two bits xand yshe wishes to transmit to Bob
as the computational-basis state |x/angbracketright|y/angbracketrightof two Qbits (the top two wires,
Figure 6.4(a)). If Bob has two Qbits initially in the state |0/angbracketright|0/angbracketright(the
bottom two wires in Figure 6.4(a)), then the circuit in Figure 6.4(a)gets the two bits to Bob in a straightforward classical way, transformingthe state |x/angbracketright|y/angbracketright|0/angbracketright|0/angbracketrighton the right to |x/angbracketright|y/angbracketright|x/angbracketright|y/angbracketrighton the left by means
of direct Qbit-to-Qbit coupling via two cNOT gates. The procedureinvolves only classical operations on classically meaningful states. Itgets the two bits from Alice to Bob by explicit interactions between herQbits and his. It would work equally well for Cbits.
One can transform this direct classical procedure into the more
exotic quantum protocol by expanding the cNOT gates into productsof quantum gates. One ﬁrst expands one of the
Cgates into HCZHin
Figure 6.4(b). Because Zacting on the control Qbit commutes with C
and because Cis its own inverse, we can further expand Figure 6.4(b)
to Figure 6.4(c). We can then bring the Hand Cgates on either side
of the CZto the extreme left and right to get Figure 6.4(d). We can
also expand the two Cgates on the left of Figure 6.4(d) into the three
Cgates on the left of Figure 6.4(e), since the action of either set is to
ﬂip the target Qbit if and only if the computational-basis states of thetwo control Qbits are different, while leaving the states of the control

<<<PAGE 165>>>

1 4 8 PROTOCOLS THAT USE JUST A FEW QBITS
X
Xxy
yx x
y
00 HHZ
X
XHH Z
X X
XZ
H X
XX Z
X
XZ xx
y
yx
y
0
0(a) (b)
(c)
(d)
(e)
(f)==
==
=H
HHH H
X X
XXFig 6.4 A circuit-theoretic
derivation of the quantumdense-coding protocol.

<<<PAGE 166>>>

6.5 T ELEPORTATION 1 4 9
Qbits unaltered. Because the state H|0/angbracketright=(1/√
2)(|0/angbracketright+| 1/angbracketright) is invari-
ant under the action of X, the Con the extreme left of Figure 6.4(e)
acts as the identity, and Figure 6.4(e) simpliﬁes to Figure 6.4(f).
The fact that Figure 6.4(f) has the same action as Figure 6.4(a)
contains all the content of the dense-coding protocol. The pair of gates
C10H1on the left of Figure 6.4(f) acts on the state |0/angbracketright|0/angbracketrightto produce
the entangled state (6.15). The bottom Qbit of the pair, Qbit 0, is givento Bob and the upper one, Qbit 1, is given to Alice, who also possessesthe upper two, Qbits 2 and 3. The pair of gates
CZ
31C21acts as 1,X,Z,
orZXon Qbit 1 depending on whether the states of Qbits 3 and 2
are|0/angbracketright|0/angbracketright,|0/angbracketright|1/angbracketright,|1/angbracketright|0/angbracketright,or|1/angbracketright|1/angbracketright. This reproduces the transformation
Alice applies to the member of the entangled pair in her possession,depending on the values of the two bits she wishes to transmit to Bob.Alice then sends Qbit 1 to Bob. The ﬁnal pair
H1C10on the right is
precisely the transformation (6.18) that Bob performs on the reunitedentangled pair before making his measurement, which yields the values
x,ythat Alice wished to transmit.
Like dense coding, many tricks of quantum information theory, in-
cluding the one we examine next, teleportation, rely on two or morepeople sharing entangled Qbits, prepared some time ago, carefullystored in their remote locations awaiting an occasion for their use.While the preparation of entangled Qbits (in the form of photons) andtheir transmission to distant places has been achieved, putting theminto entanglement-preserving, local, long-term storage remains a dif-ﬁcult challenge.
6.5 Teleportation
Suppose that Alice has a Qbit in a state
|ψ/angbracketright=α|0/angbracketright+β|1/angbracketright, (6.19)
but she does not know the amplitudes αandβ. Carol, for example, may
have prepared the Qbit for Alice by taking a Qbit initially assigned thestandard state |0/angbracketright, applying a speciﬁc unitary transformation to it, and
then giving it to Alice, without telling her what unitary transformationshe applied.
Alice would like to reassign that precise state to another Qbit pos-
sessed by Bob. Neither Alice nor Bob (who could be far away fromAlice) has any access to the other’s Qbit. Alice is, however, allowed tosend “classical information” to Bob – e.g. she can talk to him over thetelephone. And, crucially, Bob’s Qbit shares with a second Qbit of Alicethe 2-Qbit entangled state
|/Phi1/angbracketright=
1√
2/parenleftbig
|0/angbracketright|0/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
. (6.20)

<<<PAGE 167>>>

1 5 0 PROTOCOLS THAT USE JUST A FEW QBITS
The no-cloning theorem prohibits duplicating the unknown state
of Alice’s ﬁrst Qbit, either far away from her or nearby. But it turnsout to be possible for Alice and Bob to cooperate over the telephonein assigning the state |ψ/angbracketrightto Bob’s member of the entangled pair. The
no-cloning theorem is not violated because in doing so Alice obliteratesall traces of the state |ψ/angbracketrightfrom either of her own Qbits. The process –
called teleporting the state from Alice to Bob – also eliminates the en-tanglement Alice and Bob formerly shared. For each shared entangledpair, they can teleport just a single 1-Qbit state. The term “teleporta-tion” emphasizes that the state assignment acquired by Bob’s Qbit nolonger applies to Alice’s; it has been transported from her Qbit to his.
Here is how teleportation works. Alice’s ﬁrst Qbit and the entangled
pair she shares with Bob are characterized by the 3-Qbit state
|ψ/angbracketright
a|/Phi1/angbracketrightab=/parenleftbig
α|0/angbracketrighta+β|1/angbracketrighta/parenrightbig1√
2/parenleftbig
|0/angbracketrighta|0/angbracketrightb+|1/angbracketrighta|1/angbracketrightb/parenrightbig
, (6.21)
where I have given the state symbols for the Qbits in Alice’s and Bob’s
possession subscripts aand b. To teleport the unknown state of her
Qbit to Bob’s member of the entangled pair, Alice ﬁrst applies a cNOTgate, using her ﬁrst Qbit in the state |ψ/angbracketrightas the control and her member
of the shared entangled pair as the target. This produces the 3-Qbitstate
α|0/angbracketright
a1√
2/parenleftbig
|0/angbracketrighta|0/angbracketrightb+|1/angbracketrighta|1/angbracketrightb/parenrightbig
+β|1/angbracketrighta1√
2/parenleftbig
|1/angbracketrighta|0/angbracketrightb+|0/angbracketrighta|1/angbracketrightb/parenrightbig
.
(6.22)
Next she applies a Hadamard transformation Hto her ﬁrst Qbit, giving
all three Qbits the state
α1√
2/parenleftbig
|0/angbracketrighta+|1/angbracketrighta/parenrightbig1√
2/parenleftbig
|0/angbracketrighta|0/angbracketrightb+|1/angbracketrighta|1/angbracketrightb/parenrightbig
+β1√
2/parenleftbig
|0/angbracketrighta−|1/angbracketrighta/parenrightbig1√
2/parenleftbig
|1/angbracketrighta|0/angbracketrightb+|0/angbracketrighta|1/angbracketrightb/parenrightbig
=1
2|0/angbracketrighta|0/angbracketrighta/parenleftbig
α|0/angbracketrightb+β|1/angbracketrightb/parenrightbig
+1
2|1/angbracketrighta|0/angbracketrighta/parenleftbig
α|0/angbracketrightb−β|1/angbracketrightb/parenrightbig
+1
2|0/angbracketrighta|1/angbracketrighta/parenleftbig
α|1/angbracketrightb+β|0/angbracketrightb/parenrightbig
+1
2|1/angbracketrighta|1/angbracketrighta/parenleftbig
α|1/angbracketrightb−β|0/angbracketrightb/parenrightbig
. (6.23)
Now Alice measures both Qbits in her possession. (As remarked
in Section 6.4, such an application of cNOT and Hadamard gates,immediately followed by measurement gates, is called “measuring inthe Bell basis.”) If the result is 00, Bob’s Qbit will indeed acquire thestate|ψ/angbracketrightoriginally possessed by Alice’s ﬁrst Qbit (whose state would
then be reduced to |0/angbracketright). But if the result of Alice’s measurement is 10,
01, or 11 then the state of Bob’s Qbit becomes
α|0/angbracketright
b−β|1/angbracketrightb,α|1/angbracketrightb+β|0/angbracketrightb,orα|1/angbracketrightb−β|0/angbracketrightb. (6.24)
In each of these three cases there is a unitary transformation that re-
stores the state of Bob’s Qbit to Alice’s original state |ψ/angbracketright. In the ﬁrst
case we can apply Z(which leaves |0/angbracketrightalone but changes the sign of |1/angbracketright),
in the second case, X(which interchanges |0/angbracketrightand|1/angbracketright), and in the third
case, ZX.

<<<PAGE 168>>>

6.5 T ELEPORTATION 1 5 1
So all Alice need do to transfer the state of her Qbit to Bob’s member
of their entangled pair is to telephone Bob and report to him the resultsof her two measurements. He then knows whether the state has alreadybeen transferred (if Alice’s result is 00) or what unitary transformationhe must apply to his member of the entangled pair in order to com-plete the transfer (if Alice’s result is one of the other three.) Note theresemblance to quantum error correction: by making a measurementAlice acquires the information needed for Bob to reconstruct a partic-ular quantum state, without anybody acquiring any information aboutwhat the state actually is.
This appears to be remarkable. A general state of a Qbit is described
by two complex numbers αandβthat take on a continuum of values,
constrained only by the requirement that |α|
2+|β|2=1.Yet, with the
aid of a standard entangled pair, whose state does not depend on αand
β, Alice is able to provide Bob with a Qbit described by the unknown
state, at the price of only two bits of classical information (giving theresults of her two measurements) and the loss of the entanglement oftheir pair.
But of course the teleportation process does not communicate to Bob
the information that can be encoded in αandβ. Bob is no more able to
learn the values of αandβfrom manipulating his Qbit, now assigned
the state |ψ/angbracketright, than Alice was able to do when it was her Qbit that was
assigned the same state |ψ/angbracketright. On the other hand Alice’s state could be
produced at a crucial stage of an elaborate quantum computation, andits transfer to Bob could enable him to continue with the computationon his own far-away quantum computer, so one can achieve a nontrivialobjective by such teleportations.
Like dense coding, teleportation can also be constructed by manip-
ulating an elementary classical circuit diagram, without going throughany of the analysis in (6.21)–(6.24). Figure 6.5(a) shows a circuit thatexchanges the state |ψ/angbracketright=| x/angbracketrightof Alice’s Cbit with the state |0/angbracketrightof Bob’s
Cbit, regardless of whether x=0 or 1. The transfer is achieved by
direct physical coupling between the two Cbits. As a linear quantumcircuit it continues to perform this exchange for arbitrary superpo-sitions, |ψ/angbracketright=α|0/angbracketright+β|1/angbracketright. The entire teleportation protocol can be
constructed by appropriately expanding the two gates in Figure 6.5(a),with the aid of an ancillary Qbit. The aim of the expansion is to elim-inate the direct interaction between Alice’s and Bob’s Qbits throughthe two cNOT gates in Figure 6.5(a), in favor of the telephoned mes-sage from Alice to Bob, andthe interaction necessary to produce their
shared pair of entangled Qbits (which can take place well before Alicehas even acquired her Qbit in the state |ψ/angbracketright).
In Figure 6.5(b) an ancillary Qbit, not acted upon throughout the
process, is introduced in the state
|φ/angbracketright=
H|0/angbracketright=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
. (6.25)

<<<PAGE 169>>>

1 5 2 PROTOCOLS THAT USE JUST A FEW QBITS
MX
y
f
0 yf0
XX
X ZH Hy
f
0 XZHH
X
yf0y
f
0 yf0X
Xy
0 Xy0
Xy
0
0 yff
H
ZH
X
X
y
0
0HM
XX
XH
Z yoror0
01
1
yoror
00
11 y
0
0H
XXH
ZXMM==(a)
=
=(b)
(f)
(g)(e)(d)(c)
Fig 6.5 A circuit-theoretic derivation of the quantum teleportation
protocol.

<<<PAGE 170>>>

6.5 T ELEPORTATION 1 5 3
In Figure 6.5(c) the identities X=HZH and 1=HH have been
used to rewrite the cNOT gate on the right of Figure 6.5(b), and anadditional cNOT gate has been added on the left, which acts as theidentity, since
Xacts as the identity on the state H|0/angbracketright.
Figure 6.5(d) follows from Figure 6.5(c) because the action of CZ
is independent of which Qbit is the control and which the target, andbecause the two cNOT gates on the left of Figure 6.5(c) have exactlythe same action as the three cNOT gates on the left of Figure 6.5(d):acting on the computational basis, both sets of gates apply
Xon both
of the bottom two wires if the state of the top wire is |1/angbracketrightand act as the
identity if the state of the top wire is |0/angbracketright.
Figure 6.5(e) follows from Figure 6.5(d) if we write the |φ/angbracketrighton the
left of Figure 6.5(d) as H|0/angbracketrightand explicitly write the |0/angbracketrighton the right
of Figure 6.5(d) as H|φ/angbracketright. But Figure 6.5(e) is an automated version
of teleportation. To relate it to ordinary teleportation, introduce mea-surements of the upper two Qbits after the circuit of Figure 6.5(e) hasacted, as in Figure 6.5(f). Their effect is to collapse the states of eachof the two upper wires randomly and independently to |0/angbracketrightor|1/angbracketright. But
as noted in Section 3.6, measurement of a control Qbit commutes withany operation controlled by that Qbit, so the measurement gates canbe moved to the positions they occupy in Figure 6.5(g).
Figure 6.5(g) is precisely the teleportation protocol. The two gates
on the left transform the two lower Qbits into the entangled state(6.20). The subsequent applications to the top two Qbits of cNOTfollowed by
Hfollowed by two measurement gates are precisely Alice’s
“measurement in the Bell basis.” Since Alice knows the outcomes ofthe measurements, she knows whether the subsequent cNOT and
CZ
gates will or will not act, and she can replace these physical couplingsby a phone call to Bob telling him whether or not to apply
Xand/or Z
directly to his own Qbit.
Figure 6.6 demonstrates that entanglement can also be teleported.
The ﬁgure reproduces parts (b), (e), and (g) of Figure 6.5 with threechanges. (1) A bar representing nQbits in the n-Qbit state |/Phi1/angbracketright
ihas
been added above each part of the ﬁgure. No operations act on theseadditional Qbits. (2) The state to be teleported has been given a sub-script iso it is now one of several possible states |ψ
i/angbracketright. (3) Because
of the linearity of the unitary gates we may sum over the index i.
The effect of the circuit is to transfer participation in the entangledstate/summationtext
i|/Phi1i/angbracketright|ψi/angbracketrightfrom the third wire from the bottom to the bottom
wire.
So even if Alice’s Qbit has no state of its own but is entangled with
other Qbits, Alice can use the same protocol to teleport its role inthe entangled state over to Bob’s Qbit. The result is that Bob’s Qbitbecomes entangled in exactly the same way Alice’s was, and Alice’sQbit becomes entirely unentangled.

<<<PAGE 171>>>

1 5 4 PROTOCOLS THAT USE JUST A FEW QBITS
XX
f
yiΦi
0
XH
ZH
X
X
X XH X MMH
Zyi
0
0f
f
yi
Φi
yi
0
0 yiΦi
oror
00
11Φi Φif
ii
i0Φ
yi
i
=
=Fig 6.6 Figure 6.6. A
demonstration thatentanglement can beteleported.
6.6 The GHZ puzzle
We conclude with another illustration of just how strange the behavior
of Qbits can be. The situation described below is a 3-Qbit version ofone ﬁrst noticed by Daniel Greenberger, Michael Horne, and AntonZeilinger (“GHZ”) in the late 1980s, which gives a very striking versionof Bell’s theorem. An alternative version, discovered by Lucien Hardyin the early 1990s, is given in Appendix D.
Consider the 3-Qbit state
|/Psi1/angbracketright=
1
2/parenleftbig
|000/angbracketright−| 110/angbracketright−| 011/angbracketright−| 101/angbracketright/parenrightbig
. (6.26)
Note that the form of |/Psi1/angbracketrightis explicitly invariant under any permutation
of the three Qbits. Numbering the Qbits from left to right 2, 1, and 0,we have
|/Psi1/angbracketright=
C21H2X21√
2/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
. (6.27)
Since
1√
2/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
=C21C20H2X2|000/angbracketright, (6.28)

<<<PAGE 172>>>

6.6 THE GHZ PUZZLE 1 5 5
(6.27) and (6.28) provide an explicit construction of |/Psi1/angbracketrightfrom elemen-
tary 1- and 2-Qbit gates acting on the standard state |0/angbracketright3.
Because |/Psi1/angbracketrightin the form (6.26) and the state (1 /√
2)(|000/angbracketright−| 111/angbracketright)
appearing in (6.27) are both invariant under permutations of the Qbits0, 1, and 2, any of the other ﬁve forms of (6.27) associated with permu-
tations of the subscripts 0, 1, and 2 are equally valid. In particular
|/Psi1/angbracketright=
C12H1X11√
2/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
. (6.29)
It follows from (6.29) that
H2H1|/Psi1/angbracketright= H2H1C12H1X11√
2/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
=/parenleftbig
H2H1C12H1H2/parenrightbig
H2X11√
2/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
=C21H2X1/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
(6.30)
(since sandwiching a cNOT between Hadamards exchanges target and
control Qbits). Comparing the last expression in (6.30) with the formof|/Psi1/angbracketrightin (6.27) reveals that
H2H1|/Psi1/angbracketright= Z2X1|/Psi1/angbracketright (6.31)
(which can, of course, be conﬁrmed more clumsily directly from the
deﬁnition (6.26) of |/Psi1/angbracketright.) Because of the invariance of |/Psi1/angbracketrightunder per-
mutation of the three Qbits we also have
H2H0|/Psi1/angbracketright= Z2X0|/Psi1/angbracketright, (6.32)
H1H0|/Psi1/angbracketright= Z1X0|/Psi1/angbracketright. (6.33)
Now suppose that we have prepared three Qbits in the state |/Psi1/angbracketrightand
then allowed no further interactions among them. If we measure eachQbit, it follows from the form (6.26) that because |/Psi1/angbracketrightis a superposition
of computational-basis states having either none or two of the Qbits inthe state |1/angbracketright, the three outcomes are constrained to satisfy
x
2⊕x1⊕x0=0 (6.34)
(where ⊕, as usual, denotes addition modulo 2).
Suppose, on the other hand, that we apply Hadamards to Qbits
2 and 1 before measuring all three. According to (6.31) this has theeffect of ﬂipping the state of Qbit 1 in each term of the superposition(6.26) (and changing the signs of some of the terms). As a result the3-Qbit state (6.26) is changed into a superposition of computational-basis states having either one or three of the Qbits in the state |1/angbracketright.S o
if the outcomes are x
H
2,xH
1, and x0, we must have
xH
2⊕xH
1⊕x0=1. (6.35)

<<<PAGE 173>>>

1 5 6 PROTOCOLS THAT USE JUST A FEW QBITS
Similarly, if we apply Hadamards to Qbits 2 and 0 before measuring all
three, then (6.32) requires that the outcomes must obey
xH
2⊕x1⊕xH
0=1, (6.36)
and if Hadamards are applied to Qbits 1 and 0 then according to (6.33)
if all three are measured we will have
x2⊕xH
1⊕xH
0=1. (6.37)
Consider now the following question. If we are talking about a single
trio of Qbits, assigned the state |/Psi1/angbracketright, must the x0appearing in (6.34) be
the same as the x0appearing in (6.35)? A little reﬂection reveals that
this question makes no sense. After all, (6.34) describes the outcomes ofimmediately measuring the three Qbits, whereas (6.35) describes theoutcomes of measuring them after Hadamards have been applied toQbits 2 and 1. Since only one of these two possibilities can actually becarried out, there is no way to compare the results of measuring Qbit0 in the two cases. You can’t compare the x
0you found in the case you
actually carried out with the x0you might have found in the case you
didn’t carry out. It’s just a stupid question.
Or is it? Suppose that Qbits 2 and 1 are measured before Qbit 0 is
measured. If no Hadamards were applied before the measurements of2 and 1, then (6.34) assures us that when 0 is ﬁnally measured the resultwill be
x
0=x1⊕x2. (6.38)
So the outcome of measuring Qbit 0 is predetermined by the outcomes
of the earlier measurements of Qbits 2 and 1. Since all interactionsamong the Qbits ceased after the state |/Psi1/angbracketrighthad been prepared, subject-
ing Qbits 2 and 1 to measurement gates can have no effect on Qbit 0.Since the outcomes of the measurements of Qbits 2 and 1 determinein advance the outcome of the subsequent measurement of Qbit 0, itwould seem that Qbit 0 was already predisposed to give the result (6.38)upon being measured. Because the Qbits did not interact after theirinitial state was prepared, it would seem that Qbit 0 must have hadthat predisposition even before Qbits 2 and 1 were actually measuredto reveal what the result of measuring Qbit 0 would have to be.
This is a bit disconcerting, since prior to any measurements the
state of the Qbits was (6.26), in which none of them was individuallypredisposed to reveal any particular value. Indeed, it would seem thatthe 3-Qbit state (6.26) gives an incomplete description of the Qbits.
The omitted predisposition of Qbit 0 seems to be an additional element
of reality that a more complete description than that afforded by the
quantum theory would take into account.

<<<PAGE 174>>>

6.6 THE GHZ PUZZLE 1 5 7
But if Qbit 0 did indeed have a predetermined predisposition to give
x0when measured, even before Qbits 1 and 2 were measured to reveal
what x0actually was, then the value of x0surely would not be altered if
Hadamards were applied to Qbits 1 and 2 before they were measured,since the Qbits have ceased to interact, and the predisposition to give
x
0was present before the decision to apply Hadamards or not had been
made. This means that the value x0appearing in (6.34) must indeed be
identical to the value of x0appearing in (6.35). So our question is not
meaningless. The answer is Yes!
Such an argument for elements of reality – predetermined values –
was put forth in 1935 (in a different context) by Albert Einstein, BorisPodolsky, and Nathan Rosen (EPR). The controversy and discussionit has given rise to has steadily increased over the past seven decades.The terms “incomplete” and “element of reality” originated with EPR.Today it is Einstein’s most cited paper.
The wonderful thing about three Qbits in the state (6.26) is that
they not only provide a beautiful illustration of the EPR argument,but also, when examined further, reveal that the appealing argumentestablishing predetermined measurement outcomes cannot be correct.To see this, note that exactly the same reasoning establishes that thevalues of x
1appearing in (6.34) and (6.36) must be the same, as well as
the values of x2appearing in (6.34) and (6.37). And the same line of
thought establishes that the values of xH
0in (6.37) and (6.36) must be
the same, as well as the values of xH
1in (6.37) and (6.35) and the values
ofxH
2in (6.36) and (6.35).
If all this is true, then adding together the left sides of (6.34)–(6.37)
must give 0 modulo 2, since each of x2,x1,x0,xH
2,xH
1, and xH
0appears
in exactly two of the equations. But the modulo 2 sum of the right sidesis 0⊕1⊕1⊕1=1.
So the appealing EPR argument must be wrong. There are no el-
ements of reality – no predetermined measurement outcomes that amore complete theory would take into account. The answer to whatis mistaken in the simple and persuasive reasoning that led Einstein,Podolsky, and Rosen to the existence of elements of reality is still a mat-ter of debate more than 70 years later. How, after all, can Qbit 0 and itsmeasurement gate “know” that if they interact only after Qbits 1 and 2have gone through their own measurement gates (and no Hadamardswere applied) then the result of the measurement of Qbit 0 must be
given by (6.38)?
The best explanation anybody has come up with to this day is to
insist that no explanation is needed beyond what one can infer fromthe laws of quantum mechanics. Those laws are correct. Quantummechanics works. There is no controversy about that. What fail towork are attempts to provide underlying mechanisms, that go be-yond the quantum-mechanical rules, for how certain strong quantum

<<<PAGE 175>>>

1 5 8 PROTOCOLS THAT USE JUST A FEW QBITS
correlations can actually operate. One gets puzzled only if one tries to
understand how the rules can work not only for the actual situationin which they are applied, but also in alternative situations that mighthave been chosen but were not.
By concluding with this “paradoxical” state of affairs, I am not
suggesting that there is anything wrong with the quantum-theoretic
description of Qbits and the gates that act on them. On the contrary, thequantum theory has to be regarded as the must accurate and successfultheory in the history of physics, and there is no doubt whatever amongphysicists that if the formidable technological obstacles standing inthe way of building a quantum computer can be overcome, then thecomputer will behave exactly as described in the preceding chapters.
But I cannot, in good conscience, leave you without a warning that
the simple theory of Qbits developed here, though correct, is in somerespects exceedingly strange. The strangeness emerges only when oneseeks to go beyond the straightforward rules enunciated in Chapter 1.In particular one must not ask for an underlying mechanism that ac-counts not only for the behavior of the circuit actually applied to aparticular collection of Qbits, but also for the possible behavior ofother circuits that might have been applied to the very same collectionof Qbits, but were not.
A good motto for the quantum physicist and for future quantum
computer scientists might be “What didn’t happen didn’t happen .” On
that ﬁrm note I conclude (except for the 16 appendices that follow).

<<<PAGE 176>>>

Appendix A
Vector spaces: basic properties
and Dirac notation
In quantum computation the integers from 0 to Nare associated with
N+1 orthogonal unit vectors in a vector space of D=N+1 dimen-
sions over the complex numbers. The nature of this association is thesubject of Chapter 1. Here we review some of the basic properties ofsuch a vector space, while relating conventional vector-space notationto the Dirac notation used in quantum computer science. Usually thedimension Dis a power of 2, but this does not matter for our summary
of the basic facts and nomenclature.
In conventional notation such a set of D=N+1 orthonormal
vectors might be denoted by symbols such as φ
0,φ1,φ2,... ,φ N. The
orthogonality and normalization conditions are expressed in terms ofthe inner products ( φ
x,φ y):
(φx,φ y)=/braceleftbigg0,x/negationslash=y;
1,x=y.(A.1)
In quantum computation the indices xand ydescribing the integers
associated with the vectors play too important a role to be relegatedto tiny fonts in subscripts. Fortunately quantum mechanics employsa notation for vectors, invented by the physicist Paul Dirac, which iswell suited for representing such information more prominently. Onereplaces the symbols φ
xandφyby|x/angbracketrightand|y/angbracketright, and represents the inner
product ( φx,φ y) by the symbol /angbracketleftx|y/angbracketright. The orthonormality condition
(A.1) becomes
/angbracketleftx|y/angbracketright=/braceleftbigg0,x/negationslash=y;
1,x=y.(A.2)
Vectorial character is conveyed by the symbol |/angbracketright, with the speciﬁc
vector being identiﬁed by whatever it is that goes between the bentline/angbracketrightand the vertical line |. This notational strategy is reminiscent of
the notation for vectors in ordinary three-dimensional physical space(which we will use here for such vectors) in which vectorial characteris indicated by a horizontal arrow above a symbol denoting the speciﬁcvector being referred to:−→r.
Symbols like φandψremain useful in the notation of quantum com-
putation for representing generic vectors, but for consistency with thenotation for vectors associated with speciﬁc integers, and to emphasizetheir vectorial character, they too are enclosed between a bent line /angbracketright
159

<<<PAGE 177>>>

1 6 0 APPENDIX A
and a vertical line |, becoming |φ/angbracketrightand|ψ/angbracketright. Some mathematicians
disapprove of this practice. Why write |ψ/angbracketright, introducing the spurious
symbols /angbracketrightand|, when ψby itself does the job perfectly well? This gets
it backwards. The real point is that the important information – forexample the number 7798 – is easier to read in the form |7798/angbracketrightthan
when presented in small print in the form φ
7798. Why introduce in a
normal font the often uninformative symbol φ, at the price of demoting
the most important information to a mere subscript?
The vector space that describes the operation of a quantum com-
puter consists of all linear combinations |ψ/angbracketrightof the N+1 orthonormal
vectors |x/angbracketright,x=0,... , N, with coefﬁcients αxtaken from the complex
numbers:
|ψ/angbracketright=α0|0/angbracketright+α1|1/angbracketright+···+ αN|N/angbracketright=N/summationdisplay
x=0αx|x/angbracketright, (A.3)
where αx=ux+ivx,uxandvxare real numbers, and i=√
−1.
The mathematicians’ preference for writing ψinstead of |ψ/angbracketrightfor
generic vectors is explicitly acknowledged in the useful conventionthat|αψ+βφ/angbracketrightis nothing more than an alternative way of writing the
vector α|ψ/angbracketright+β|φ/angbracketright:
|αψ+βφ/angbracketright=α|ψ/angbracketright+β|φ/angbracketright. (A.4)
In a vector space over the complex numbers the inner product of
two general vectors is a complex number satisfying
/angbracketleftψ|φ/angbracketright=/angbracketleftφ|ψ/angbracketright
∗, (A.5)
where∗denotes complex conjugation:
(u+iv)∗=u−iv, u,vreal. (A.6)
The inner product is linear in the right-hand vector,
/angbracketleftφ|αψ 1+βψ 2/angbracketright=α/angbracketleftφ|ψ1/angbracketright+β/angbracketleftφ|ψ2/angbracketright, (A.7)
and therefore, from (A.5), “anti-linear” in the left-hand vector,
/angbracketleftαφ1+βφ2|ψ/angbracketright=α∗/angbracketleftφ1|ψ/angbracketright+β∗/angbracketleftφ2|ψ/angbracketright. (A.8)
The inner product of a vector with itself is a real number satisfying
/angbracketleftφ|φ/angbracketright>0,|φ/angbracketright/negationslash=0. (A.9)
It follows from the orthonormality condition (A.2) that the inner
product of the vector |ψ/angbracketrightin (A.3) with another vector
|φ/angbracketright=β0|0/angbracketright+β1|1/angbracketright+···+ βN|N/angbracketright=/summationdisplay
xβx|x/angbracketright (A.10)

<<<PAGE 178>>>

APPENDIX A 1 6 1
is given in terms of the expansion coefﬁcients αxandβx(called ampli-
tudes in quantum computation) by
/angbracketleftφ|ψ/angbracketright=/summationdisplay
xβ∗
xαx. (A.11)
The squared magnitude of a vector is its inner product with itself, so
(A.11) gives for the squared magnitude
/angbracketleftψ|ψ/angbracketright=/summationdisplay
x|αx|2, (A.12)
where
|u+iv|2=u2+v2, u,vreal. (A.13)
The form (A.12) gives an explicit conﬁrmation of the rule (A.9).
A linear transformation Aassociates with every vector |ψ/angbracketrightanother
vector, called A|ψ/angbracketright, subject to the rule (linearity)
A/parenleftbig
α|ψ/angbracketright+β|φ/angbracketright/parenrightbig
=αA|ψ/angbracketright+βA|φ/angbracketright. (A.14)
With a nod to the mathematicians, it is notationally useful to deﬁne
|Aψ/angbracketright= A|ψ/angbracketright. (A.15)
A linear transformation that preserves the magnitudes of all vectors
is called unitary , because it follows from linearity that all magnitudes
will be preserved if and only if unit vectors (vectors of magnitude1) are taken into unit vectors. It also follows from linearity that if alinear transformation
Uis unitary then it must preserve not only the
inner products of arbitrary vectors with themselves, but also the innerproducts of arbitrary pairs of vectors. This follows straightforwardlyfor two general vectors |φ/angbracketrightand|ψ/angbracketrightfrom the fact that
Upreserves the
magnitudes of both of them, as well as the magnitudes of the vectors|φ/angbracketright+|ψ/angbracketrightand|φ/angbracketright+ i|ψ/angbracketright.
One can associate with any given vector |φ/angbracketrightthe linear functional
that takes every vector |ψ/angbracketrightinto the number /angbracketleftφ|ψ/angbracketright.Linearity follows
from property (A.7) of the inner product. The set of all such linearfunctionals is itself a vector space, called the dual space of the original
space. The functional associated with the vector α|φ/angbracketright+β|ψ/angbracketrightis the
sum of α
∗times the functional associated with |φ/angbracketrightandβ∗times the
functional associated with |ψ/angbracketright. It is an easy exercise to show that any
linear functional on the original space is associated with some vector inthe dual space. Dirac called vectors in the original space ket vectors and
vectors in the dual space bra vectors . He denoted the bra associated with
the ket |φ/angbracketrightby the symbol /angbracketleftφ|, so that the symbol /angbracketleftφ|ψ/angbracketrightcan equally
well be viewed as the inner product of the two kets |φ/angbracketrightand|ψ/angbracketrightor as a
compact way of expressing the action /angbracketleftφ|(|ψ/angbracketright) of the associated linear

<<<PAGE 179>>>

1 6 2 APPENDIX A
functional /angbracketleftφ|on the vector |ψ/angbracketright. Note that one has
/angbracketleftαφ+βψ|=α∗/angbracketleftφ|+β∗/angbracketleftψ|. (A.16)
A linear transformation Aon the space of ket vectors induces a linear
transformation A†(called “ A-adjoint”) on the dual space of bra vectors,
according to the rule
/angbracketleftAψ|=/angbracketleftψ|A†. (A.17)
The operation adjoint to the trivial linear transformation that multiplies
by a given complex number is multiplication by the complex conjugateof that number.
It is convenient to extend the dagger notation to the vectors them-
selves, deﬁning
/parenleftbig
|ψ/angbracketright/parenrightbig
†=/angbracketleftψ|, (A.18)
so that the bra dual to a given ket is viewed as adjoint to that ket. The
deﬁnition (A.17) of A†then becomes
/parenleftbig
|Aψ/angbracketright/parenrightbig†=/angbracketleftψ|A†, (A.19)
or, with (A.15),
/parenleftbig
A|ψ/angbracketright/parenrightbig†=/angbracketleftψ|A†, (A.20)
which provides a simple example of a very general rule that the adjoint
of a product of quantities is the product of their adjoints taken in theopposite order. Another instance of the rule which follows from (A.20)is that
/angbracketleftφ|/parenleftbig
AB/parenrightbig†=/angbracketleftABφ|=/angbracketleft Bφ|A†=/angbracketleftφ|B†A†. (A.21)
Since this holds for arbitrary /angbracketleftφ|we have
/parenleftbig
AB/parenrightbig†=B†A†. (A.22)
Although the adjoint A†of a linear transformation Aon kets is a
linear transformation on bras, one can also deﬁne its action on kets.One does so by requiring that the action of /angbracketleftφ|on
A†|ψ/angbracketrightshould be
equal to the action of /angbracketleftφ|A†on|ψ/angbracketright. This amounts to stipulating that the
symbol /angbracketleftφ|A†|ψ/angbracketrightshould be unambiguous; it does not matter whether
it is read as ( /angbracketleftφ|A†)|ψ/angbracketrightor as/angbracketleftφ|(A†|ψ/angbracketright).Implicit in this deﬁnition is
the fact that a vector is completely deﬁned by giving its inner productwith all vectors. This in turn follows from the fact that a vector |ψ/angbracketright
can be deﬁned by giving all the amplitudes α
xin its expansion (A.3) in
the complete orthonormal set |x/angbracketright. Butαx=/angbracketleft x|ψ/angbracketright. Similarly, a linear
operator Ais completely deﬁned by giving its matrix elements /angbracketleftφ|A|ψ/angbracketright
for arbitrary pairs of vectors, since the subset /angbracketleftx|A|y/angbracketrightis already enough
to determine its action on a general vector (A.3).

<<<PAGE 180>>>

APPENDIX A 1 6 3
Note that any matrix element of A†is equal to the complex conjugate
of the transposed (withφandψexchanged) matrix element of A:
/angbracketleftφ|A†|ψ/angbracketright=/angbracketleft Aφ|ψ/angbracketright=/angbracketleftψ|Aφ/angbracketright∗=/angbracketleftψ|A|φ/angbracketright∗. (A.23)
It follows from this that
/parenleftbig
A†/parenrightbig†=A. (A.24)
Since a unitary transformation Upreserves inner products, we have
/angbracketleftφ|ψ/angbracketright=/angbracketleft Uφ|Uψ/angbracketright=/angbracketleftφ|U†U|ψ/angbracketright, (A.25)
and therefore
U†U=1, (A.26)
where 1is the unit (identity) operator that takes every vector into itself.
It follows from (A.26) that
UU†U=U. (A.27)
In a ﬁnite-dimensional vector space a unitary transformation Ualways
takes an orthonormal basis into another orthonormal basis, so any U
clearly has a right inverse – the linear transformation that takes thesecond basis back into the ﬁrst. Multiplying (A.27) on the right by thatinverse tells us that
UU†=1, (A.28)
soU†andUare inverses regardless of the order in which they act.
The vector |ψ/angbracketrightis an eigenvector of the linear operator Aif the action
ofAon|ψ/angbracketrightis simply to multiply it by a complex number a, called an
eigenvalue ofA:
A|ψ/angbracketright= a|ψ/angbracketright. (A.29)
Since the number acan be expressed as a=/angbracketleftψ|A|ψ/angbracketright//angbracketleftψ|ψ/angbracketright, it follows
from (A.23) that if A=A†(such operators are said to be self-adjoint or
Hermitian ) then ais a real number. Eigenvalues of Hermitian operators
are necessarily real.
Since Ais Hermitian and ais a real number, it follows from (A.29)
(by forming the adjoints of both sides) that
/angbracketleftψ|A=a/angbracketleftψ|, (A.30)
so the vector dual to an eigenket of a Hermitian operator is an eigenbra
with the same eigenvalue. It follows immediately that if |φ/angbracketrightis another
eigenvector of Awith eigenvalue a/prime, then
a/angbracketleftψ|φ/angbracketright=/angbracketleftψ|A|φ/angbracketright= a/prime/angbracketleftψ|φ/angbracketright, (A.31)

<<<PAGE 181>>>

1 6 4 APPENDIX A
so if a/prime/negationslash=athen/angbracketleftψ|φ/angbracketright=0: eigenvectors of a Hermitian operator with
different eigenvalues are orthogonal.
It can be shown that for any Hermitian operator A, one can choose an
orthonormal basis for the entire D-dimensional space whose members
are eigenvectors of A. The basis is unique if and only if all the D
eigenvalues of Aare distinct. In the contrary case (in which Ais said
to be degenerate) one can pick arbitrary orthonormal bases withineach of the subspaces spanned by eigenvectors of
Awith the same
eigenvalue. More generally, if A,B,C,... are mutually commuting
Hermitian operators then one can choose an orthonormal basis whosemembers are eigenstates of every one of them.
If
Bis any linear operator, then A1=B+B†andA2=i/parenleftbig
B†−B/parenrightbig
are both Hermitian, and commute if BandB†commute. Since a joint
eigenvector of A1and A2is also a joint eigenvector of B=A1+iA2
andB†=A1−iA2, it follows that if Bcommutes with B†then one can
choose an orthonormal basis of eigenvectors of B. In particular, since
a unitary transformation Usatisﬁes UU†=U†U=1, one can choose
an orthonormal basis consisting of eigenvectors of U. Since unitary
transformations preserve the magnitudes of vectors, the eigenvaluesof
Umust be complex numbers of modulus 1. In the quantum theory
such complex numbers are often called phase factors .
Given two vector spaces of dimensions D1and D2, and given any
two vectors |ψ1/angbracketrightand|ψ2/angbracketrightin the two spaces, one associates with each
such pair a tensor product |ψ1/angbracketright⊗|ψ2/angbracketright(often the tensor-product sign ⊗
is omitted) which is bilinear:
|ψ1/angbracketright⊗/parenleftbig
α|ψ2/angbracketright+β|φ2/angbracketright/parenrightbig
=α|ψ1/angbracketright⊗|ψ2/angbracketright+β|ψ1/angbracketright⊗|φ2/angbracketright,(A.32) /parenleftbig
α|ψ1/angbracketright+β|φ1/angbracketright/parenrightbig
⊗|ψ2/angbracketright=α|ψ1/angbracketright⊗|ψ2/angbracketright+β|φ1/angbracketright⊗|ψ2/angbracketright.
With the further rule that |ψ1/angbracketright⊗|ψ2/angbracketright=|φ1/angbracketright⊗|φ2/angbracketrightonly if |φ1/angbracketrightand
|φ2/angbracketrightare scalar multiples of |ψ1/angbracketrightand|ψ2/angbracketright, one easily sees that the set of
all tensor products of vectors from the two spaces forms a vector spaceof dimension D
1D2.
One deﬁnes the inner product of |ψ1/angbracketright⊗|ψ2/angbracketrightwith|φ1/angbracketright⊗|φ2/angbracketrightto be
the ordinary product /angbracketleftψ1|φ1/angbracketright/angbracketleftψ2|φ2/angbracketrightof the inner products in the two
original spaces. Given orthonormal bases for each of the two spaces,the set of tensor products of all pairs of vectors from the two basesforms an orthonormal basis for the tensor-product space. If
A1andA2
are linear operators on the two spaces, one deﬁnes the tensor-productoperator
A1⊗A2to satisfy
/parenleftbig
A1⊗A2/parenrightbig/parenleftbig
|ψ1/angbracketright⊗|ψ2/angbracketright/parenrightbig
=|A1ψ1/angbracketright⊗| A2ψ2/angbracketright=/parenleftbig
A1|ψ1/angbracketright/parenrightbig
⊗/parenleftbig
A2|ψ2/angbracketright/parenrightbig
,
(A.33)
and easily shows that it can be extended to a linear operator on the
entire tensor-product space.

<<<PAGE 182>>>

APPENDIX A 1 6 5
All of this generalizes in the obvious way to n-fold tensor products
ofnvector spaces.
IfAis a linear operator whose eigenvectors constitute an orthonor-
mal basis – i.e. if Ais Hermitian or, more generally, if Aand A†com-
mute – and if fis a function taking complex numbers to complex
numbers, then one can deﬁne f(A) by specifying that each eigenvector
|φ/angbracketrightofA, in the basis with eigenvalue a, is also an eigenvector of f(A)
with eigenvalue f(a). This deﬁnes f(A) on a basis, and it can therefore
be extended to arbitrary vectors by requiring it to be linear. It followsfrom this deﬁnition that if f(z) is a polynomial or convergent power
series in zthen f(
A) is the corresponding polynomial or convergent
power series in A.
In Dirac notation one deﬁnes the outer product of two vectors |φ/angbracketright
and|ψ/angbracketrightto be the linear operator, denoted by |φ/angbracketright/angbracketleftψ|, that takes any
vector |γ/angbracketrightinto|φ/angbracketrightmultiplied by the inner product /angbracketleftψ|γ/angbracketright:
/parenleftbig
|φ/angbracketright/angbracketleftψ|/parenrightbig
|γ/angbracketright=|φ/angbracketright/parenleftbig
/angbracketleftψ|γ/angbracketright/parenrightbig
. (A.34)
As is always the case with Dirac notation, the point is to deﬁne things
in such a way that the evaluation of an ambiguous expression such as|φ/angbracketright/angbracketleftψ|γ/angbracketrightdoes not depend on how you read it; the notation is designed
always to enforce the associative law.
Note that |ψ/angbracketright/angbracketleftψ|is the projection operator onto the one-
dimensional subspace spanned by the unit vector |ψ/angbracketright; i.e. any vector
|γ/angbracketrightcan be written as the sum of a vector |γ/angbracketright
/bardblin the one-dimensional
subspace and a vector |γ/angbracketright⊥perpendicular to the one-dimensional sub-
space, and
/parenleftbig
|ψ/angbracketright/angbracketleftψ|/parenrightbig
|γ/angbracketright=|γ/angbracketright/bardbl. (A.35)
Similarly, if one has a set of orthonormal vectors |ψi/angbracketrightthen/summationtext
i|ψi/angbracketright/angbracketleftψi|projects onto the subspace spanned by all the |ψi/angbracketright.I f
the orthonormal set is a complete orthonormal set – for example|x/angbracketright,x=0,... , N– then the set spans the entire vector space and
the projection operator is the unit operator
1:
N/summationdisplay
x=0|x/angbracketright/angbracketleftx|=1. (A.36)
This trivial identity can be surprisingly helpful. Any vector |ψ/angbracketright,f o r
example, satisﬁes
|ψ/angbracketright= 1|ψ/angbracketright=/summationdisplay
x|x/angbracketright/angbracketleftx|ψ/angbracketright, (A.37)
which tells us that the amplitudes αxappearing in the expansion (A.3)
of|ψ/angbracketrightare just the inner products /angbracketleftx|ψ/angbracketright. Similarly, any linear operator

<<<PAGE 183>>>

1 6 6 APPENDIX A
Asatisﬁes
|A/angbracketright= 1A1=/parenleftBigg/summationdisplay
x|x/angbracketright/angbracketleftx|/parenrightBigg
A/parenleftBigg/summationdisplay
y|y/angbracketright/angbracketlefty|/parenrightBigg
=/summationdisplay
xy|x/angbracketright/angbracketlefty|/parenleftbig
/angbracketleftx|A|y/angbracketright/parenrightbig
,
(A.38)
which reveals the matrix elements /angbracketleftx|A|y/angbracketrightto be the expansion co-
efﬁcients of the operator Ain the “operator basis” |x/angbracketright/angbracketlefty|. And note
that
/angbracketleftx|AB|y/angbracketright=/angbracketleft x|A1B|y/angbracketright=/summationdisplay
z/angbracketleftx|A|z/angbracketright/angbracketleftz|B|y/angbracketright, (A.39)
which gives the familiar matrix-multiplication rule for constructing
the matrix of a product out of the matrix elements of the individualoperators.
If you prefer to think of vectors in terms of their components in a
speciﬁc basis, then you might note that the (ket) vector |ψ/angbracketright, with the
expansion (A.3) with amplitudes α
xin the orthonormal basis |x/angbracketright, can
be represented by a column vector:
|ψ/angbracketright− →⎛
⎜⎜⎝α0
α1...
αN⎞
⎟⎟⎠. (A.40)
The associated bra vector is then the row vector:
/angbracketleftψ|− →/parenleftbig
α∗
0α∗
1... α∗
N/parenrightbig
. (A.41)
If
|φ/angbracketright− →⎛
⎜⎜⎝β0
β1...
βN⎞
⎟⎟⎠, (A.42)
then the inner product /angbracketleftφ|ψ/angbracketrightis given by the ordinary matrix product
of the row and column vectors:
/angbracketleftφ|ψ/angbracketright=/parenleftbig
β∗
0β∗
1... β∗
N/parenrightbig⎛
⎜⎜⎝α0
α1...
αN⎞
⎟⎟⎠. (A.43)
The outer product |ψ/angbracketright/angbracketleftφ|is also a matrix product:
|ψ/angbracketright/angbracketleftφ|=⎛
⎜⎜⎝α0
α1...
αN⎞
⎟⎟⎠/parenleftbig
β∗
0β∗
1... β∗
N/parenrightbig
. (A.44)

<<<PAGE 184>>>

APPENDIX A 1 6 7
Note that in Dirac notation (A.43) is nothing more than the state-
ment that
/angbracketleftφ|ψ/angbracketright=/angbracketleftφ|1|ψ/angbracketright=/summationdisplay
x/angbracketleftφ|x/angbracketright/angbracketleftx|ψ/angbracketright=/summationdisplay
x/angbracketleftx|φ/angbracketright∗/angbracketleftx|ψ/angbracketright,(A.45)
while (A.44) asserts that
/angbracketleftx|/parenleftBig
|ψ/angbracketright/angbracketleftφ|/parenrightBig
|y/angbracketright=/angbracketleft x|ψ/angbracketright/angbracketleftφ|y/angbracketright=/angbracketleft x|ψ/angbracketright/angbracketlefty|φ/angbracketright∗. (A.46)

<<<PAGE 185>>>

Appendix B
Structure of the general 1-Qbit
unitary transformation
I describe here some relations among Pauli matrices, 1-Qbit unitary
transformations, and rotations of real-space three-dimensional vectors.The relations are of fundamental importance in many applications ofquantum mechanics, and are an essential part of the intellectual equip-ment of anybody wanting to understand the mathematical structure ofthree-dimensional rotations. The reason for mentioning them here isthat they can also make certain circuit identities quite transparent. Thequantum-computation literature contains some unnecessarily cumber-some derivations of many such identities, suggesting that these usefulmathematical facts deserve to be more widely known in the ﬁeld.
The two-dimensional unit matrix
1and the three Pauli matrices
form a basis,
1=/parenleftbigg10
01/parenrightbigg
,σx=/parenleftbigg01
10/parenrightbigg
,
(B.1)
σy=/parenleftbigg0−i
i 0/parenrightbigg
,σz=/parenleftbigg10
0−1/parenrightbigg
,
for the four-dimensional algebra of two-dimensional matrices: any two-
dimensional matrix uhas a unique expansion of the form
u=u01+−→u·−→σ (B.2)
for some complex number u0and 3-vector−→uwith complex compo-
nents ux,uy,and uz. Here−→σrepresents the “3-vector” whose com-
ponents are the Pauli matrices σx,σy, andσz, so in expanded form
(B.2) reads
u=u01+uxσx+uyσy+uzσz=/parenleftbiggu0+uz ux−iu y
ux+iu y u0−uz/parenrightbigg
.
(B.3)
As what follows demonstrates, however, it is invariably simpler to usethe form (B.2) together with the multiplication rule (see Section 1.4)
(−→a·−→σ)(−→b·−→σ)=(−→a·−→b)
1+i(−→a×−→b)·−→σ, (B.4)
rather than dealing explicitly with two-dimensional matrices.
Impose on (B.2) the condition
uu†=u†u=1 (B.5)
168

<<<PAGE 186>>>

APPENDIX B 1 6 9
that ube unitary. Since any unitary matrix remains unitary if it is
multiplied by an overall multiplicative phase factor eiθwithθreal, we
can require u0to be real and arrive at a form which is general except for
such an overall phase factor. Since the Pauli matrices are Hermitian,we then have
u†=u01+−→u∗·−→σ. (B.6)
The rule (B.4) now tells us that for uto be unitary we must have
0=1−u†u=/parenleftbig
1−u2
0−−→u∗·−→u/parenrightbig
1−/parenleftbig
u0(−→u+−→u∗)+i−→u∗×−→u/parenrightbig
·−→σ.
(B.7)
Since 1,σx,σy, and σzare linearly independent in the four-
dimensional algebra of 1-Qbit operators, the coefﬁcients of all fourof them in (B.7) must vanish and we have
1=u
2
0+−→u∗·−→u, 0=u0(−→u+−→u∗)+i−→u∗×−→u.(B.8)
The second of these requires the real and imaginary parts of the
vector−→uto satisfy
u0Re−→u=Re−→u×Im−→u. (B.9)
Ifu0/negationslash=0, it follows from (B.9) that Re−→u·Re−→u=0, so Re−→u=0,
and the vector−→umust be itimes a real vector−→v. On the other hand
ifu0=0 then (B.9) requires the real and imaginary parts of−→uto
be parallel vectors, so that−→uitself is just a complex multiple of a
real vector. But if u0=0 we retain the freedom to pick the overall
phase of the operator u, which we can choose to make the vector−→u
purely imaginary. So irrespective of whether or not u0=0, the general
form for a two-dimensional unitary uis, to within an overall phase
factor,
u=u01+i−→v·−→σ, (B.10)
where u0is a real number,−→vis a real vector, and, from the ﬁrst of
(B.8),
u2
0+−→v·−→v=1. (B.11)
The identity (B.11) allows us to parametrize u0and−→vin terms of
a real unit vector−→nparallel to−→vand a real angle γso that
u=cosγ1+isinγ(−→n·−→σ). (B.12)
An alternative way of writing (B.12) is
u=exp( iγ−→n·−→σ). (B.13)
This follows from the forms of the power-series expansions of the
exponential, sine, and cosine, together with the fact that (−→n·−→σ)2=1

<<<PAGE 187>>>

1 7 0 APPENDIX B
for any unit vector−→nas a special case of (B.4). (The argument is the
same as the argument that eiϕ=cosϕ+isinϕfor any real number
ϕ.)
A remarkable connection between these two-dimensional unitary
matrices and ordinary three-dimensional rotations emerges from thefact that each of the three Pauli matrices in (B.1) has zero trace, andthat the operator unitary transformation
A→uAu†(B.14)
preserves the trace of A.1
Note ﬁrst that if−→ais a real vector then u(−→a·−→σ)u†is Hermitian
and can therefore be expressed as a linear combination of 1and the
three Pauli matrices with real coefﬁcients. Since σx,σy, andσzall
have zero trace, so does−→a·−→σand therefore so does u(−→a·−→σ)u†.
Its expansion as a linear combination of 1and the three Pauli matrices
must therefore be of the form−→a/prime·−→σfor some real vector−→a/prime(since
1alone among the four matrices has nonzero trace):
u(−→a·−→σ)u†=−→a/prime·−→σ. (B.15)
It follows that
u(−→a·σ)(−→b·−→σ)u†=/parenleftBig
u(−→a·−→σ)u†/parenrightBig/parenleftBig
u(−→b·−→σ)u†/parenrightBig
=/parenleftBig−→a/prime·−→σ/parenrightBig/parenleftBig−→b/prime·−→σ/parenrightBig
.
(B.16)
Since unitary transformations preserve the trace,
Tr(−→a·−→σ)(−→b·−→σ)=Tr(−→a/prime·−→σ/parenrightbig/parenleftbig−→b/prime·−→σ/parenrightbig
. (B.17)
Hence, from (B.4),
−→a/prime·−→b/prime=−→a·−→b. (B.18)
It follows directly from the form (B.15) of the transformation from
unprimed to primed vectors that (−→a+−→b)/prime=−→a/prime+−→b/primeand (λ−→a)/prime=
λ−→a/prime– i.e. the transformation−→a→−→a/primeis linear. But the most general
real, linear, inner-product-preserving transformation on real 3-vectorsis a rotation. Consequently the transformation from real 3-vectors−→a
to real 3-vectors−→a
/primeinduced by any two-dimensional unitary uthrough
(B.15) is a rotation:
−→a/prime=Ru−→a. (B.19)
Furthermore, by applying the (unitary) product uvof two unitary
1 The trace of a matrix is the sum of its diagonal elements. Recall also the
(easily veriﬁed) fact that the trace of a product of two matrices isindependent of the order in which the matrices are multiplied, even whenthe matrices do not commute.

<<<PAGE 188>>>

APPENDIX B 1 7 1
transformations in two steps,
(uv)(−→a·−→σ)(uv)†=u/parenleftbig
v(−→a·−→σ)v†/parenrightbig
u†=u/parenleftbig
[Rv−→a]·−→σ/parenrightbig
u†
=[RuRv−→a]·−→σ, (B.20)
we deduce that
Ruv=RuRv. (B.21)
Thus the association of three-dimensional rotations with two-
dimensional unitary matrices preserves the multiplicative structureof the rotation group: the rotation associated with the product of twounitary transformations is the product of the two associated rotations.
Which rotation is associated with which unitary transformation? To
answer this, note ﬁrst that when the vector−→ain (B.15) is taken to be
the vector−→nappearing in
u(in (B.12) or (B.13)) then−→n/prime=−→n, since
uthen commutes with−→n·−→σ. Therefore−→nis along the axis of the
rotation associated with u=exp( iγ−→n·−→σ). To determine the angle
θof that rotation, let−→mbe any unit vector perpendicular to the axis
−→n, so that
cosθ=−→m·−→m/prime. (B.22)
We then have
cosθ=1
2Tr/parenleftbig
(−→m·−→σ)(−→m/prime·−→σ)/parenrightbig
=1
2Tr/parenleftbig
(−→m·−→σ)(cosγ1+isinγ−→n·−→σ)(−→m·σ)
×(cosγ1−isinγ−→n·−→σ)/parenrightbig
=1
2Tr/parenleftbig
(cosγ−→m−sinγ−→m×−→n)·−→σ)
×(cosγ−→m+sinγ−→m×−→n)·−→σ)/parenrightbig
=cos2γ−sin2γ=cos(2γ), (B.23)
where we have made repeated use of (B.4) and the fact that−→m·−→n=0.
So the unitary matrix (B.13) is associated with a rotation about the
axis−→nthrough the angle 2 γ. Since the identity rotation is associ-
ated both with u=1and with u=− 1, the correspondence between
these unitary matrices and three-dimensional proper rotations is 2-to-1. It is useful to introduce the notation
u(−→n,θ) for the 1-Qbit unitary
transformation associated with the rotation R(−→n,θ) about the axis−→n
through the angle θ:
u(−→n,θ)=exp/parenleftbig
i1
2θ−→n·−→σ/parenrightbig
=cos/parenleftbig1
2θ/parenrightbig
+i(−→n·−→σ)sin/parenleftbig1
2θ/parenrightbig
.(B.24)
The three-dimensional rotations arrived at in this way are all proper
(i.e. they preserve rather than invert handedness) because they can allbe continuously connected to the identity. Any proper rotation can be
associated with a
u, and in just two different ways ( uand−uclearly
being associated with the same rotation). The choice of phase leading

<<<PAGE 189>>>

1 7 2 APPENDIX B
to the general form (B.10) with real u0can be imposed by requiring
that the determinant of umust be 1, so in mathematical language we
have a 2-to-1 homomorphism from the group SU(2) of unimodularunitary two-dimensional matrices to the group SO(3) of proper three-dimensional rotations.
Although this may all seem tediously abstract, it is surprisingly
useful at a very practical level. It can reduce some highly nontriv-ial three-dimensional geometry to elementary algebra, just as Euler’srelation e
iφ=cosφ+isinφreduces some slightly nontrivial two-
dimensional trigonometry to simple algebra. Suppose, for example,that you combine a rotation through an angle αabout an axis given
by the unit vector−→awith a rotation through βabout−→b. The re-
sult, of course, is a single rotation. What are its angle γand axis−→c?
Answering this question can be a nasty exercise in three-dimensionalgeometry. But to answer it using the Pauli matrices you need only notethat
u(−→c,γ)=u(−→a,α)u(−→b,β), i.e.
cos/parenleftbig1
2γ/parenrightbig
1+isin/parenleftbig1
2γ/parenrightbig
(−→c·−→σ)=/parenleftbig
cos/parenleftbig1
2α/parenrightbig
1+isin/parenleftbig1
2α/parenrightbig
(−→a·−→σ)/parenrightbig
×/parenleftbig
cos/parenleftbig1
2β/parenrightbig
1+isin/parenleftbig1
2β/parenrightbig
(−→b·−→σ)/parenrightbig
.
(B.25)
Now multiply out the right side of (B.25), using (B.4). To get the angle
γtake the trace of both sides (or identify the coefﬁcients of 1)t oﬁ n d
cos/parenleftbig1
2γ/parenrightbig
=cos/parenleftbig1
2α/parenrightbig
cos/parenleftbig1
2β/parenrightbig
−(−→a·−→b)sin/parenleftbig1
2α/parenrightbig
sin/parenleftbig1
2β/parenrightbig
.(B.26)
To get the axis−→c, identify the vectors of coefﬁcients of the Pauli
matrices:
sin/parenleftbig1
2γ/parenrightbig−→c=sin/parenleftbig1
2β/parenrightbig
cos/parenleftbig1
2α/parenrightbig−→b+sin/parenleftbig1
2α/parenrightbig
cos/parenleftbig1
2β/parenrightbig−→a
−sin/parenleftbig1
2α/parenrightbig
sin/parenleftbig1
2β/parenrightbig
(−→a×−→b). (B.27)
Note that (B.26) and (B.27) are trivially correct when−→aand−→bare
parallel. A little geometrical thought reveals that they are also correctwhenαandβare both 180
◦. To try to see geometrically why they
are correct more generally is to acquire a deep appreciation for theremarkable power of the representation of three-dimensional rotationsin terms of two-dimensional unitary transformations. Other examplesof the power of the representation are illustrated in the derivations ofcircuit identities in Section 2.6, in the characterization of the general1-Qbit state in Appendix C, and in the construction of the Hardy statein Appendix D.

<<<PAGE 190>>>

Appendix C
Structure of the general 1-Qbit state
The 1-Qbit computational-basis states |0/angbracketrightand|1/angbracketrightcan be characterized
to within an overall phase by the fact that they are eigenstates of thenumber operator
nwith eigenvalues 0 and 1 or, equivalently, that they
are eigenstates of 1 −2n=Z=−→z·−→σwith eigenvalues 1 and −1.
Let|φ/angbracketrightbe any 1-Qbit state, and let |ψ/angbracketrightbe the orthogonal state
(unique to within an overall phase), satisfying /angbracketleftψ|φ/angbracketright=0. Since |0/angbracketright
and|1/angbracketrightare linearly independent there is a unique linear transformation
taking them into |φ/angbracketrightand|ψ/angbracketright. But since |φ/angbracketrightand|ψ/angbracketrightare an orthonormal
pair (as are |0/angbracketrightand|1/angbracketright) this linear transformation preserves the inner
product of arbitrary pairs of states, so it is a unitary transformation u.
Since
|φ/angbracketright= u|0/angbracketright, |ψ/angbracketright= u|1/angbracketright, (C.1)
the operator n/prime=unu†acts as a Qbit number operator on |φ/angbracketrightand|ψ/angbracketright:
n/prime|φ/angbracketright=0, n/prime|ψ/angbracketright=|ψ/angbracketright. (C.2)
Since, as shown in Appendix B, any 1-Qbit unitary transformation u
is associated with a rotation R(−→m,θ), we have
n/prime=unu†=1
2/parenleftbig
1−u(−→z·−→σ)u†/parenrightbig
=1
2(1−−→z/prime·−→σ), (C.3)
where−→z/prime=R(−→m,θ)−→z.
Thus n/prime, which functions as a number operator for the states |φ/angbracketright=
u(−→m,θ)|0/angbracketrightand|ψ/angbracketright= u(−→m,θ)|1/angbracketright, is constructed out of the compo-
nent of the vector of operators σalong the direction−→z/prime=R(−→m,θ)−→z
in exactly the same way that n, the number operator for the compu-
tational basis states |0/angbracketrightand|1/angbracketright, is constructed out of the component
along−→z. This suggests that there might be nothing special about the
choice of |0/angbracketrightand|1/angbracketrightto form the computational-basis states for each
Qbit – that any pair of orthogonal states, |0/prime/angbracketright= u|0/angbracketrightand|1/prime/angbracketright= u|1/angbracketright,
could serve equally well. Furthermore, it is at least a consistent pos-sibility that to make an apparatus to measure the Qbits in this newbasis we need do nothing more than apply the rotation
Rassociated
with uto the apparatus that served to measure them in the original
basis.
This physical possibility is realized by some, but by no means all, of
the physical systems that have been proposed as possible embodiments
173

<<<PAGE 191>>>

1 7 4 APPENDIX C
of Qbits. It is realized for certain atomic magnets – also called spins –
which have the property that when the magnetization of such a spin ismeasured along any given direction, after the measurement the magnetis either maximally aligned along that direction or maximally alignedopposite to that direction. These two possible outcomes for a particulardirection – conventionally taken to be−→z– are associated with the
values 0 and 1 for the Qbit. After such a measurement the spin is left inthe state |0/angbracketrightor|1/angbracketright. Any other state |φ/angbracketrightand its orthogonal partner |ψ/angbracketright
specify an alternative direction, along which the magnetization mighthave been measured, associated with an alternative scheme for readingout values for the Qbits.
For this example the continuum of possible states available to a Qbit,
compared with the pair of states available to a Cbit, reﬂects the contin-uum of ways in which one can read a Qbit (measuring its magnetizationalong any direction) as opposed to the single option available for read-ing a Cbit (ﬁnding out what value it actually has). For Qbits that are notspins, the richness lies in the possibility of applying an arbitrary unitarytransformation to each Qbit, before measuring it in the computationalbasis. What makes spins special is that applying the unitary transfor-mation to the Qbits (which is not always that easy to arrange) can bereplaced by straightforwardly applying the corresponding rotation toevery 1-Qbit measurement gate.

<<<PAGE 192>>>

Appendix D
Spooky action at a distance
As a further exercise in applying the quantum-computational formal-
ism to Qbits, and as a subject of interest in itself, though not directlyrelated to quantum computation, I describe here a thought-provokingstate of affairs illustrated with an example discovered by Lucien Hardy.(Similar thoughts are provoked by an example discovered by DanielGreenberger, Michael Horne, and Anton Zeilinger, described in Sec-tion 6.6.)
Suppose that Alice and Bob each has one member of a pair of Qbits,
which have been prepared in the 2-Qbit state
|/Phi1/angbracketright=
1√
12/parenleftbig
3|00/angbracketright+| 01/angbracketright+| 10/angbracketright−| 11/angbracketright/parenrightbig
. (D.1)
A speciﬁcation of how to prepare two Qbits in such a Hardy state,
somewhat more transparent than the general procedure described inSection 1.11, is given after the extraordinary properties of the Hardystate are described. One easily veriﬁes that the state |/Phi1/angbracketrightcan also be
written as
|/Phi1/angbracketright=
1√
3/parenleftbig
2|00/angbracketright−HaHb|11/angbracketright/parenrightbig
, (D.2)
where we take Hato act on the left (Alice’s) Qbit and Hbto act on the
right (Bob’s) Qbit. Note the following four elementary properties of apair of Qbits in the state |/Phi1/angbracketright.
(i) If Alice and Bob each measures their own Qbit, then (D.1) shows
that there is a nonzero probability (
1
12) that both get the result 1.
(ii) If Alice and Bob each applies a Hadamard to their own Qbit then,
since H2=1, the state (D.2) of the Qbits becomes
HaHb|/Phi1/angbracketright=1√
3/parenleftbig
2HaHb|00/angbracketright−| 11/angbracketright/parenrightbig
=1√
3/parenleftbig
|00/angbracketright+| 01/angbracketright+| 10/angbracketright/parenrightbig
,
(D.3)
so if they measure their Qbits after each has applied a Hadamard, thenthe probability that both get the value 1 is zero.
(iii) If only Alice applies a Hadamard to her Qbit, then the state
(D.2) of the two Qbits becomes
Ha|/Phi1/angbracketright=1√
3/parenleftbig
2Ha|00/angbracketright−Hb|11/angbracketright/parenrightbig
. (D.4)
Since Ha|00/angbracketrightis a linear combination of |00/angbracketrightand|10/angbracketright, and since Hb|11/angbracketright
is a linear combination of |10/angbracketrightand|11/angbracketright, the state |01/angbracketrightdoes not appear
175

<<<PAGE 193>>>

1 7 6 APPENDIX D
Table D.1. Four ways to measure two Qbits in
the Hardy state (D.1)
Gates Result Possible?
Alice Bob Alice Bob
11 11 Y e s
1H 10 N o
H1 01 N o
HH 11 N o
in the expansion of Ha|/Phi1/angbracketrightin computational-basis states. So when the
Qbits are subsequently measured the probability is zero that Alice willget the value 0 and Bob the value 1.
(iv) If only Bob applies a Hadamard to his Qbit, then by the same
reasoning (except for the interchange of Alice and Bob) when the Qbitsare subsequently measured the probability is zero that Alice will getthe value 1 and Bob the value 0.
Taken together, these four cases seem to have some very strange
implications. The cases are summarized in the four rows of Table D.1above. On the left is indicated whether (
H) or not ( 1) Alice or Bob
sends their Qbit through a Hadamard gate before sending it through a
measurement gate. In the center is listed the measurement outcome ofinterest for each case. The column on the right speciﬁes whether thatoutcome can or cannot occur for that particular case.
To see what is strange, suppose that Alice and Bob each indepen-
dently decides, by tossing coins, whether or not to apply a Hadamard
to their Qbit before sending it through a measurement gate. There isa nonzero probability (
1
4×1
12=1
48) that neither applies a Hadamard
and both measurement gates show 1 (see the ﬁrst row of Table D.1).In the one time in 48 that this happens, it is tempting to conclude thateach Qbit was, even before the coins were tossed, capable of producing
a 1 when directly subjected to a measurement gate because, after all,each Qbit didproduc e a 1 when directly subjected to a measurement
gate.
But if Alice’s Qbit did indeed have such a capability, then, in the
absence of spooky interactions between Bob’s Hadamard and Alice’sQbit, her Qbit surely would have retained that capability, even if Bob’scoin had come up the other way and he had applied a Hadamard tohis own Qbit before measuring it. But if Alice’s Qbit was indeed ca-pable of registerin g a 1 when measured directly, then Bob’s Qbit must
have been incapable of registering a 0 if measured after a Hadamard,since (see the second row of Table D.1) when Bob applies a Hadamardbefore his measurement and Alice does not, it is impossible for Bob’smeasurement to give 0 while Alice’s gives 1.

<<<PAGE 194>>>

APPENDIX D 1 7 7
By the same reasoning (interchanging Alice and Bob and referring
to the third row of Table D.1) we conclude that Alice’s Qbit must alsohave been incapable of registering a 0 when measured after a Hadamard.
So in each of the slightly more than 2% of the cases in which neither
Alice nor Bob applies Hadamards and both their measurement gatesregister 1, we conclude that if the tosses of both coins had come outthe other way and both had applied Hadamards before measuring, thenneither Qbit could have registered 0 when measured: both would havehad to register 1. But according to the fourth row of Table D.1 this cannever happen.
Although this particular argument was discovered by Lucien Hardy
only in the early 1990s, similar situations (where the paradox is notas directly evident) have been known since a famous paper by JohnBell appeared in 1964. Over the years passions have run high on thesigniﬁcance of this. Some claim that it shows that the value Alice orBob ﬁnds upon measuring her or his Qbit does depend on whether or
not the other, who, with his or her Qbit, could be far away, does ordoes not apply a Hadamard to his or her own Qbit before measuring it.They call this “quantum nonlocality” or “spooky action at a distance”–a translation of Einstein’s disparaging spukhafte Fernwirkungen.
My own take on it is rather different. With any given pair of Qbits,
Alice and Bob each either does or does not apply a Hadamard priorto their measurement. Only one of the four possible cases is actuallyrealized. The other three cases do not happen. In a deterministic world
it can make sense to talk about what would have happened if things
had been other than the way they actually were, since the hypotheticalsituation can entail unique subsequent behavior. But in the intrinsicallynondeterminstic case of measuring Qbits, one cannot infer, from whatAlice’s Qbit actually did, that it has a “capability” to do what it actuallydid, which it retains even in a hypothetical situation that did not, infact, take place. To characterize the possible behavior of Alice’s Qbitin a ﬁctitious world requires more than just the irrelevance of Bob’sdecision whether or not to apply a Hadamard. It also requires thatwhatever it is that actually isrelevant to Alice’s outcome remains the
same in both worlds and plays the same role in bringing about thatoutcome. But the reading of a measurement gate has an irreduciblerandomness to it: nothing need play a role in bringing it about.
1
The real lesson here is that if one has a single pair of Qbits and
various choices of gates to apply to them before sending them througha measurement gate, then it makes no sense to infer, from the actual
1 Conscience requires me to report here the existence of a small deviant
subculture of physicists, known as Bohmians, who maintain that there is adeterministic substructure, unfortunately inaccessible to us, that underliesquantum phenomena. Needless to say, all Bohmians believe in realinstantaneous action at a distance.

<<<PAGE 195>>>

1 7 8 APPENDIX D
outcome of the measurement for the actual choice of gates, additional
constraints, going beyond those implied by the initial state of the Qbits,on the hypothetical outcomes of measurements in the ﬁctional case inwhich one made a different choice of gates. It is nonsense to insist thatAlice’s Qbit has to retain the “capability” to do what it actually did, ifwe imagine turning back the clock and doing it over again. Assigninga “capability” to Alice’s Qbit prior to the measurement is rather likeassigning it a state. But the pre-measurement state (D.1) is an entangledstate, so Alice’s Qbit has no state of its own.
One can, however, let Alice and Bob repeatedly play this game with
many different pairs of Qbits, always preparing the Qbits in the sameinitial 2-Qbit state (D.1). It is then entirely sensible to ask whether thestatistics of the values Bob ﬁnds upon measuring his Qbit depend on
whether Alice applied a Hadamard transform to her Qbit. For Alice andBob can accumulate a mass of data, and directly compare the statisticsBob got when Alice applied the Hadamard with those he got whenshe did not. If Bob got a different statistical distribution of readingsdepending on whether Alice did or did not apply a Hadamard to herfaraway Qbit before she measured it, this would permit nonspooky
action at a distance which could actually be used to send messages. Soit is important to note that Bob’s statistics do not, in fact, depend on
whether or not Alice applies a Hadamard.
We can show this under quite general conditions. Suppose that n
Qbits are divided into two subsets, each of which may be indepen-dently manipulated (i.e. subjected to unitary transformations) prior toa measurement. Let the n
aQbits on the left constitute one such group
and the nb=n−naon the right, the other. Think of the ﬁrst group
as under the control of Alice and the second as belonging to Bob. Ifthe nQbits are always prepared in the state |/Psi1/angbracketright, then if Alice and Bob
separately measure their Qbits, the Born rule tells us that the jointprobability p(x,y) of Alice getting xand Bob yis
p
/Psi1(x,y)=/angbracketleft/Psi1|Pa
xPb
y|/Psi1/angbracketright, (D.5)
where the projection operator Paacts only on Alice’s Qbits (i.e. it acts
as the identity on Bob’s) and Pbonly on Bob’s.
Suppose, now, that Alice acts on her Qbits with the unitary transfor-
mation Uabefore making her measurement and Bob acts on his with
Ub. Then the state |/Psi1/angbracketrightis changed into
|/Phi1/angbracketright= UaUb|/Psi1/angbracketright. (D.6)
Now the probability of their measurements giving xand y, conditioned
on their choices of unitary transformation, is
p/Psi1(x,y|Ua,Ub)=/angbracketleftbig
/Phi1|Pa
xPb
y|/Phi1/angbracketrightbig
=/angbracketleftbig
/Psi1|U†
bU†
a/parenleftbig
Pa
xPb
y/parenrightbig
UaUb|/Psi1/angbracketrightbig
=/angbracketleftbig
/Psi1|/parenleftbig
U†
aPa
xUa/parenrightbig/parenleftbig
U†
bPb
yUb/parenrightbig
|/Psi1/angbracketrightbig
(D.7)

<<<PAGE 196>>>

APPENDIX D 1 7 9
(where we have used the fact that all operators that act only on Alice’s
Qbits commute with all operators that act only on Bob’s).
It follows from the fact that
/summationdisplay
xU†
aPa
xUa=U†
a/parenleftBig/summationdisplay
xPa
x/parenrightBig
Ua=U†
a1U a=1 (D.8)
that Bob’s marginal statistics do not depend on what Alice chose to do
to her own Qbits:
p/Psi1(y|UaUb)=/summationdisplay
xp/Psi1(x,y|Ua,Ub)=/angbracketleft/Psi1|/parenleftbig
U†
bPb
yUb/parenrightbig
|/Psi1/angbracketright= p/Psi1(y|Ub),
(D.9)
which does not depend on the particular unitary transformation Ua
chosen by Alice. Therefore the statistics of the measurement outcomesfor any group of Qbits are not altered by anything done to other Qbits(provided, of course, that the other Qbits do not subsequently interactwith those in the original group, for example by the application ofappropriate 2-Qbit gates).
Like any 2-Qbit state, the state (D.1) leading to this remarkable set
of data can be constructed with a single cNOT gate and three 1-Qbitunitary gates. Here is a construction that is somewhat more direct thanthe general construction given in Section 1.11. It exploits the connec-tion between 1-Qbit unitary transformations and three-dimensionalrotations developed in Appendix B.
It follows from (D.3) that
|/Phi1/angbracketright=
HaHb1√
3/parenleftbig
|00/angbracketright+| 01/angbracketright+| 10/angbracketright/parenrightbig
=HaHb/parenleftbigg/radicalBig
2
3Hb|00/angbracketright+/radicalBig
1
3|10/angbracketright/parenrightbigg
=Ha/parenleftbigg/radicalBig
2
3|00/angbracketright+/radicalBig
1
3Hb|10/angbracketright/parenrightbigg
=HaCH
ab/bracketleftbigg/parenleftbigg/radicalBig
2
3|0/angbracketright+/radicalBig
1
3|1/angbracketright/parenrightbigg
|0/angbracketright/bracketrightbigg
=HaCH
abwa|00/angbracketright,(D.10)
where wis any 1-Qbit unitary transformation that takes |0/angbracketrightinto/radicalBig
2
3|0/angbracketright+/radicalBig
1
3|1/angbracketright, and CHis a 2-Qbit controlled-Hadamard gate:
CH
10|xy/angbracketright= Hx
0|xy/angbracketright. (D.11)
To construct a controlled-Hadamard CHfrom a controlled-NOT C,
note that the NOT operation Xisx·σwhile the Hadamard transfor-
mation is H=(1/√
2)/parenleftbig
X+Z/parenrightbig
=(1/√
2)/parenleftbig
x+z/parenrightbig
·σ.It follows from
the discussion of 1-Qbit unitaries in Appendix B that
H=uXu†, (D.12)
where uis the 1-Qbit unitary associated with any rotation that takes x

<<<PAGE 197>>>

1 8 0 APPENDIX D
into (1 /√
2)(x+z). Since we also have 1=uu†, it follows that
CH
10=u0Cu†
0. (D.13)
So (D.10) reduces to the compact form
|/Phi1/angbracketright= HaubCabwau†
b|00/angbracketright.
If you want an explicit form for w, its matrix in the computational
basis could be
⎛
⎝/radicalBig
2
3−/radicalBig
1
3/radicalBig
1
3/radicalBig
2
3⎞
⎠. (D.14)
To get an explicit form for u, note that a rotation through π/4 about
the y-axis takes xinto (1 /√
2)(x+z). The associated unitary transfor-
mation is
u=exp/parenleftbig
i(π/8)σy/parenrightbig
=cos(π/8)1+isin(π/8)σy. (D.15)
Since the matrix for σyin the computational basis is
/parenleftbigg0−i
i 0/parenrightbigg
,
the matrix for uis
/parenleftbiggcos(π/8) sin( π/8)
−sin(π/8) cos( π/8)/parenrightbigg
. (D.16)
Since the matrices for XandHare/parenleftbigg01
10/parenrightbigg
and1√
2/parenleftbigg11
1−1/parenrightbigg
you can easily conﬁrm that these three matrices do indeed satisfy (D.12).
Verifying this should give you an appreciation for the power of themethod described in Appendix B.

<<<PAGE 198>>>

Appendix E
Consistency of the generalized
Born rule
A general state of m+nQbits can be written as
|/Psi1/angbracketrightm+n=/summationdisplay
x,yαxy|x/angbracketrightm|y/angbracketrightn. (E.1)
The most general form of the Born rule asserts that if just the m
Qbits associated with the states |x/angbracketrightmin (E.1) are measured, then with
probability
p(x)=/summationdisplay
y|αxy|2(E.2)
the result will be x, and after the measurement the state of all m+n
Qbits will be the product state
|x/angbracketrightm|/Phi1x/angbracketrightn, (E.3)
where the (correctly normalized) state of the nunmeasured Qbits is
given by
|/Phi1x/angbracketrightn=1√p(x)/summationdisplay
yαxy|y/angbracketrightn. (E.4)
This strongest form of the Born rule satisﬁes the reasonable con-
sistency requirement that measuring rQbits and then immediately
measuring smore, before any other gates have had a chance to act,
is equivalent to measuring all the r+sQbits together. An important
consequence is that an n-Qbit measurement gate can be constructed
by applying n1-Qbit measurement gates to the nindividual Qbits, as
illustrated in Figure 1.8.
To establish this consistency condition, write the state of r+s+u
Qbits as
|/Psi1/angbracketrightn=/summationdisplay
x,y,zαxyz|x/angbracketrightr|y/angbracketrights|z/angbracketrightu. (E.5)
If the r+sQbits are all measured together then a direct application
of the rule tells us that the result will be xywith probability
p(xy)=/summationdisplay
z|αxyz|2, (E.6)
181

<<<PAGE 199>>>

1 8 2 APPENDIX E
and that the post-measurement state of the Qbits will be
|x/angbracketrightr|y/angbracketrights|/Phi1xy/angbracketrightu=| x/angbracketrightr|y/angbracketrights1√p(xy)/summationdisplay
zαxyz|z/angbracketrightu. (E.7)
On the other hand if just the ﬁrst rQbits are measured then the rule
tells us that the result will be xwith probability
p(x)=/summationdisplay
y,z|αxyz|2, (E.8)
and that the post-measurement state will be
|x/angbracketrightr|/Phi1x/angbracketrights+u=| x/angbracketrightr1√p(x)/summationdisplay
y,zαxyz|y/angbracketrights|z/angbracketrightu. (E.9)
Given that the result of the ﬁrst measurement is x, so that the post-
measurement state is (E.9), a further application of the rule tells us thatif the next sQbits are measured, the result will be ywith probability
p(y|x)=/summationdisplay
z/vextendsingle/vextendsingle/vextendsingleα
xyz//radicalbig
p(x)/vextendsingle/vextendsingle/vextendsingle2
, (E.10)
and that the post-measurement state after the second measurement
will be
|x/angbracketrightr|y/angbracketrights|/Phi1xy/angbracketrightu, (E.11)
where
|/Phi1xy/angbracketrightu=1√p(y|x)1√p(x)/summationdisplay
zαxyz|z/angbracketrightu. (E.12)
Since the joint probability of getting xand then getting yis related
to the conditional probability p(y|x)b y
p(xy)=p(x)p(y|x), (E.13)
this ﬁnal state and probability are exactly the same as the probability
(E.6) and ﬁnal state (E.7) associated with a direct measurement of all
r+sQbits.

<<<PAGE 200>>>

Appendix F
Other aspects of Deutsch’s problem
Suppose that one attempted to solve Deutsch’s problem, not by the
trick that does the job in Chapter 2, but by doing the standard thing:starting with input and output registers in the state |0/angbracketright|0/angbracketright, applying a
Hadamard to the input register, and then using the one application of
Ufto associate with the two Qbits the state
|ψ/angbracketright=1√
2|0/angbracketright|f(0)/angbracketright+1√
2|1/angbracketright|f(1)/angbracketright. (F .1)
A direct measurement of both Qbits reveals the value of fat either 0
or 1 (randomly), but gives no information whatever about the questionunder investigation, whether or not f(0)=f(1).
Is there anything further one can do to two Qbits in the state (F .1) to
learn whether or not f(0)=f(1) (without any further application of
Uf)? The answer is yes, there is. But it works only half the time. Here
is one such procedure.
For each of the four possibilities for the unknown function f, the
corresponding forms for the state (F .1) are
f(0)=0, f(1)=0: |ψ/angbracketright00=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
|0/angbracketright, (F .2)
f(0)=1, f(1)=1: |ψ/angbracketright11=1√
2/parenleftbig
|0/angbracketright+| 1/angbracketright/parenrightbig
|1/angbracketright, (F .3)
f(0)=0, f(1)=1: |ψ/angbracketright01=1√
2/parenleftbig
|0/angbracketright|0/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
,(F .4)
f(0)=1, f(1)=0: |ψ/angbracketright10=1√
2/parenleftbig
|0/angbracketright|1/angbracketright+| 1/angbracketright|0/angbracketright/parenrightbig
.(F .5)
We know that |ψ/angbracketrighthas one of these four forms, and wish to distinguish
between two cases:
Case 1: |ψ/angbracketright=|ψ/angbracketright00or|ψ/angbracketright11; Case 2: |ψ/angbracketright=|ψ/angbracketright01or|ψ/angbracketright10.
By applying Hadamards to both Qbits we change the four possible
states to
/parenleftbig
H⊗H/parenrightbig
|ψ/angbracketright00=1√
2/parenleftbig
|0/angbracketright|0/angbracketright+| 0/angbracketright|1/angbracketright/parenrightbig
, (F .6)
/parenleftbig
H⊗H/parenrightbig
|ψ/angbracketright11=1√
2/parenleftbig
|0/angbracketright|0/angbracketright−| 0/angbracketright|1/angbracketright/parenrightbig
, (F .7)
/parenleftbig
H⊗H/parenrightbig
|ψ/angbracketright01=1√
2/parenleftbig
|0/angbracketright|0/angbracketright+| 1/angbracketright|1/angbracketright/parenrightbig
, (F .8)
/parenleftbig
H⊗H/parenrightbig
|ψ/angbracketright10=1√
2/parenleftbig
|0/angbracketright|0/angbracketright−| 1/angbracketright|1/angbracketright/parenrightbig
. (F .9)
183

<<<PAGE 201>>>

1 8 4 APPENDIX F
Now measure both Qbits. If we have one of the Case-1 states, (F .6)
or (F .7), we get 00 half the time and 01 half the time; and if we haveone of the Case-2 states, (F .8) or (F .9), we get 00 half the time and 11half the time. So regardless of what the state is, half the time we get 00and learn nothing whatever, and half the time we get 01 or 11 and learnwhich case we are dealing with.
This way of dealing with Deutsch’s problem – with a 50% chance
of success – was noticed before the discovery of the 100%-effectivemethod described in Chapter 2. One might wonder whether some moreclever choice of operations on the state (F .1) could enable one alwaysto make the discrimination. It is easy to show that this is impossible.
We wish to apply some general 2-Qbit unitary transformation
Uto
|ψ/angbracketrightwith the result that every possible outcome of a subsequent mea-
surement must rule out one or the other of the two cases. For this tobe so it must be that those computational-basis states that appear inthe expansions of the states
U|ψ/angbracketright00and U|ψ/angbracketright11cannot appear in the
computational-basis expansions of the states U|ψ/angbracketright01and U|ψ/angbracketright10, and
vice versa, for otherwise there would be a nonzero probability of a mea-surement outcome that did not enable us to discriminate between thetwo cases. Consequently
U|ψ/angbracketright00andU|ψ/angbracketright11must each be orthogonal
to each of U|ψ/angbracketright01and U|ψ/angbracketright10. But this is impossible, because uni-
tary transformations preserve inner products, while (F .2)–(F .5) showthat the inner product of any Case-1 state |ψ/angbracketright
ijwith any Case-2
state is1
2.
One can, in fact, show under very general circumstances that, start-
ing with two Qbits in the state (F .1), one cannot do better than ap-plying Hadamards to both before measuring: there must be at least a
50% chance that the measurement outcomes will not enable one todiscriminate between Case 1 and Case 2. The proof that 50% is thebest one can do provides an instructive illustration of many features ofthe quantum-mechanical formalism.
Suppose that we bring in nadditional ( ancillary ) Qbits to help us out.
These might be used to process the input and output registers furtherthrough some elaborate quantum subroutine, producing an arbitraryunitary transformation
Wthat acts on all n+2 Qbits before a ﬁnal
measurement of the n+2 Qbits is made. (This, of course, reduces to
the simpler case of no ancillary Qbits, if Wacts as the identity except
on the original two Qbits, hereafter called the pair.)
Let the ancillary Qbits start off in some state |χ/angbracketrightn, which we can
take to be |0/angbracketrightn. (Any other n-Qbit state is related to |0/angbracketrightnby a unitary
transformation in the ancillary subspace, which can be absorbed into
W.) Let the pair be in one of the four states |ψ/angbracketrightgiven in (F .2)–(F .5).
After Wacts the probability of a measurement giving x(0≤x≤3)
for the pair and y(0≤y<2n) for the ancillary Qbits is
p|ψ/angbracketright(x,y)=| /angbracketleft x,y|W|ψ,0/angbracketright|2, (F .10)

<<<PAGE 202>>>

APPENDIX F 1 8 5
where it is convenient to write a (2 +n)-Qbit state of the form |ψ/angbracketright2⊗
|χ/angbracketrightnas|ψ,χ/angbracketright.
Note next that for arbitrary pair states |φ/angbracketright
p|φ/angbracketright(x,y)=0 if and only if /angbracketleftx,y|W|φ,0/angbracketright=0, (F .11)
so if p|φ/angbracketright(x,y) vanishes for several different states |φ/angbracketright, linearity re-
quires it also to vanish for any state in the subspace they span. There-fore any measurement outcome that enables us to discriminate betweenCase 1 and Case 2 must have zero probability either for both of the states(F .2) and (F .3) and therefore for any state in the subspace they span, orfor any state in the subspace spanned by the states (F .4) and (F .5). Now(F .2)–(F .5) reveal that the state
|α/angbracketright=
1
2/parenleftbig
|00/angbracketright+| 01/angbracketright+| 10/angbracketright+| 11/angbracketright/parenrightbig
(F .12)
belongs to both of these subspaces. So if there are any measurement
outcomes x,ywith
p|α/angbracketright(x,y)/negationslash=0, (F .13)
then such outcomes are uninformative. Therefore the probability of a
measurement outcome that fails to discriminate between Case 1 andCase 2 is at least
p
min=/summationdisplay
x,y/prime
p|ψ/angbracketright(x,y), (F .14)
where the prime indicates that the sum is restricted to those measure-
ment outcomes x,ythat satisfy (F .13).
Now it is easy to verify that every one of the four possible forms
(F .2)–(F .5) for |ψ/angbracketrightis of the form
|ψ/angbracketright=1√
2/parenleftbig
|α/angbracketright+|β/angbracketright/parenrightbig
, (F .15)
where |α/angbracketrightis given in (F .12) and |β/angbracketrightis orthogonal to |α/angbracketright. Since |ψ/angbracketrighthas
the form (F .15), we have from (F .14) and (F .10) that
pmin=1
2/summationdisplay
x,y/prime/parenleftbig
p|α/angbracketright(x,y)+2R e [/angbracketleftβ,0|W†|x,y/angbracketright/angbracketleftx,y|W|α,0/angbracketright]
+p|β/angbracketright(x,y)/parenrightbig
. (F .16)
Although the sum in (F .16) is restricted to those x,ysatisfying (F .13),
we can extend it in each of the ﬁrst two terms to all x,ysince this
adds either zero probabilities (ﬁrst term) or (because of (F .11)) zeroamplitudes (second term). The ﬁrst term then gives
/summationdisplay
allx,yp|α/angbracketright(x,y)=1, (F .17)

<<<PAGE 203>>>

1 8 6 APPENDIX F
while the second gives
2R e/summationdisplay
allx,y/angbracketleftβ,0|W†|x,y/angbracketright/angbracketleftx,y|W|α,0/angbracketright=2R e/angbracketleftβ,0|W†W|α,0/angbracketright
=2R e/angbracketleftβ,0|1|α,0/angbracketright=0,
(F .18)
since|α/angbracketrightand|β/angbracketrightare orthogonal. Hence
pmin=1
2/parenleftBigg
1+/summationdisplay
x,y/prime
p|β/angbracketright(x,y)/parenrightBigg
≥1
2. (F .19)
One must fail at least half the time.

<<<PAGE 204>>>

Appendix G
The probability of success in
Simon’s problem
Section 2.5 gives a rough argument that the number of runs necessary
to determine the n-bit number ain Simon’s problem is of order n.
Further analysis is needed to get a more accurate estimate of how manyruns give a high probability of learning a.
If we invoke
Ufmtimes, we learn mindependently selected random
numbers y, whose bits yisatisfy
a·y=n−1/summationdisplay
i=0yiai=0 (mod 2) . (G.1)
If we have n−1 relations (G.1) for n−1 linearly independent sets of
yi, then this gives us enough equations to determine a unique nonzero
a. “Linearly independent” in this context means linear independence
over the integers modulo 2; i.e. no subsets of the ys should satisfy y⊕
y/prime⊕y/prime/prime⊕···= 0 (mod 2). We have to invoke the subroutine enough
times to give us a high probability of coming up with n−1 linearly
independent values of y.
Regardless of the size of n, for not terribly large xthe probability
becomes extremely close to 1 that a set of n+xrandom vectors from an
(n−1)-dimensional subspace of the space of n-dimensional vectors,
with components restricted to the modulo 2 integers 0 and 1, containsa linearly independent subset. This is obvious for ordinary vectors withcontinuous components, since the probability that a randomly selectedvector in an ( n−1)-dimensional space lies in a speciﬁed subspace of
lower dimensionality is zero – it is certain to have a nonzero componentoutside of the lower-dimensional subspace. The argument is trickierhere because components are restricted to only two values: 1 or 0.
Introduce a basis in the full ( n−1)-dimensional subspace of all vec-
tors ywith a·y=0, so that a random vector in the subspace can be
expressed as a linear combination of the basis vectors with coefﬁcientsthat are randomly and independently 1 or 0. Arrange the resulting(n+x) random vectors of ones and zeros into a matrix of n+xrows
and n−1 columns. Since the row rank (the number of linearly inde-
pendent rows) of a matrix is the same as the column rank, even whenarithmetic is conﬁned to the integers modulo 2, the probability thatsome subset of n−1 of the n+x(n−1)-dimensional row vectors is
linearly independent is the same as the probability that all n−1o ft h e
187

<<<PAGE 205>>>

1 8 8 APPENDIX G
(n+x)-dimensional column vectors are linearly independent. But it
is easy to ﬁnd a lower bound for this last probability.
Pick a column vector at random. The probability that it is nonzero
is 1−(1/2n+x). If so, take it as the ﬁrst member of a basis in which we
expand the remaining column vectors. The probability that a second,randomly selected column vector is independent of the ﬁrst is 1 −
(1/2
n+x−1), since it will be independent unless every one of its (random)
components along the remaining n+x−1 vectors is zero. Continuing
in this way, we conclude that the probability qof all n−1 column
vectors being linearly independent is
q=/parenleftbigg
1−1
2n+x/parenrightbigg/parenleftbigg
1−1
2n+x−1/parenrightbigg
···/parenleftbigg
1−1
2x+2/parenrightbigg
. (G.2)
(If you’re suspicious of this argument, reassure yourself by checking
that it gives the right qwhen n=3,a=111, and x=0, by explicitly
enumerating which of the 64 different sets of three ys, all satisfying
a·y=0, contain two linearly independent vectors.)
Finally, to get a convenient lower bound on the size of q, note that
if we have a set of non-negative numbers a,b,c,... whose sum is less
than 1, then the product (1 −a)(1−b)(1−c)...exceeds 1 −(a+
b+c+··· ). (This is easily proved by induction on the number of
numbers in the set.) The probability qis therefore greater than
1−1
2x+2−1
2x+3−···−1
2x+n, (G.3)
and this, in turn, is greater than
1−1
2x+1. (G.4)
So if we want to determine awith less than one chance in a million of
failure, it is enough to run the subroutine n+20 times.

<<<PAGE 206>>>

Appendix H
One way to make a cNOT gate
This more technical appendix is addressed to physicists curious about
how one might, at least in principle, construct a cNOT gate, exploit-ing physically plausible interactions between two Qbits. Readers withno background in quantum physics will ﬁnd some parts rather ob-scure. It is relevant only to readers curious about the possibilities forquantum-computational hardware, and plays no role in subsequentdevelopments.
The controlled-NOT gate
C10with control Qbit 1 and target Qbit
0 can be written as
C10=H0CZH0, (H.1)
where the controlled- Zoperation is given by
CZ=1
2/parenleftbig
1+Z1+Z0−Z1Z0/parenrightbig
. (H.2)
Because of its symmetry under interchange of the two Qbits, we may
write CZwithout the subscripts distinguishing control and target. To
within 1-Qbit Hadamard transformations, the problem of constructinga controlled-NOT gate is the same as that of constructing a controlled-
Zgate.
Since (
CZ)2=1,CZsatisﬁes the identity
exp( iCZθ)=cosθ+iCZsinθ. (H.3)
We can therefore rewrite (H.2) as
CZ=− iexp/parenleftbig
iπ
2CZ/parenrightbig
=− iexp/bracketleftbig
i/parenleftbigπ
4/parenrightbig
(1+Z1+Z0−Z1Z0)/bracketrightbig
=e−i(π/4)exp/bracketleftbig
i/parenleftbigπ
4/parenrightbig
(Z1+Z0−Z1Z0)/bracketrightbig
. (H.4)
The point of writing CZin this clumsy way is that the unitary
transformations one can construct physically are those of the form
U=exp( iHt), (H.5)
where ¯ hHis the Hamiltonian that describes the external ﬁelds acting
on the Qbits and the interactions between Qbits. So to within an over-all constant phase factor we can realize a
CZgate by letting the two
Qbits interact through a Hamiltonian proportional to Z1+Z0−Z1Z0
for a precisely speciﬁed interval of time. If each Qbit is a spin-1
2, then
189

<<<PAGE 207>>>

1 9 0 APPENDIX H
(since Z=σz) this Hamiltonian describes two such spins with a highly
anisotropic interaction that couples only their z-components ( Ising
interaction ) subject to a uniform magnetic ﬁeld with a magnitude appro-
priately proportional to the strength of their coupling. This is perhapsthe simplest example of how to make a cNOT gate.
Ising interactions, however, are rather hard to arrange. A much more
natural interaction between two spins is the exchange interaction
→σ
(1)·→σ(0)=σ(1)
xσ(0)
x+σ(1)
yσ(0)
y+σ(1)
zσ(0)
z, (H.6)
which is invariant under spatial rotations, as described in Appendix B.
One can also build a CZgate out of two spins interacting through
(H.6), if one applies to each spin magnetic ﬁelds that are along the samedirection but have different magnitudes and signs.
1
What we must show is that to within an overall constant phase factor
it is possible to express CZin the form
CZ=exp( iHt), (H.7)
with a Hamiltonian Hof the form
H= J→σ(1)·→σ(0)+B1σ(1)
z+B0σ(0)
z, (H.8)
for appropriate choices of J(known as the exchange coupling), of B1
and B0(proportional to the magnetic ﬁelds acting on the two spins –
hereafter we ignore the proportionality constant and refer to themsimply as the “magnetic ﬁelds”), and of the time tduring which the
spins interact with each other and with the magnetic ﬁelds.
To see that the parameters in (H.8) can indeed be chosen so that
Hgives rise to
CZthrough (H.7), recall ﬁrst2that the operator1
2(1+→σ(1)·→σ(0)) acts as the swap operator on any 2-Qbit computational-
basis state:
1
2/parenleftbig
1+→σ(1)·→σ(0)/parenrightbig
|xy/angbracketright=| yx/angbracketright. (H.9)
It follows from (H.9) that the three states (called triplet states )
|11/angbracketright,|00/angbracketright,1√
2/parenleftbig
|01/angbracketright+| 10/angbracketright/parenrightbig
(H.10)
are eigenstates of→σ(1)·→σ(0)with eigenvalue 1, while the state
1√
2/parenleftbig
|01/angbracketright−| 10/angbracketright/parenrightbig
(H.11)
1 What follows was inspired by Guido Burkard, Daniel Loss, David P .
DiVincenzo, and John A. Smolin, “Physical optimization of quantum errorcorrection circuits,” Physical Review B60, 11 404–11 416 (1999),
http://arxiv.org/abs/cond-mat/9905230 .
2 This was established in Equation (1.53). It is why the interaction is called the
exchange interaction.

<<<PAGE 208>>>

APPENDIX H 1 9 1
(called the singlet state ) is an eigenstate of→σ(1)·→σ(0)with eigen-
value−3.3
The four states (H.10) and (H.11) are also eigenstates of1
2(σ(1)
z+
σ(0)
z), the three triplet states (in the order in which they appear in
(H.10)) having eigenvalues −1, 1, and 0, and the singlet state having
eigenvalue 0.
Note also that the ﬁrst two triplet states in (H.10) are eigenstates of
1
2(σ(1)
z−σ(0)
z) with eigenvalue 0, while1
2(σ(1)
z−σ(0)
z) takes the third of
the triplet states into the singlet state, and vice versa.
So the eigenstates of the Hamiltonian
H=J→σ(1)·→σ(0)+B1σ(1)
z+B0σ(0)
z
=J→σ(1)·→σ(0)+B+1
2(σ(1)
z+σ(0)
z)+B−1
2(σ(1)
z−σ(0)
z),(H.12)
where
B±=B1±B0, (H.13)
can be taken to be the ﬁrst two of the triplet states (H.10) and two
appropriately chosen orthogonal linear combinations of the third triplet
state and the singlet state (H.11). The eigenvalues of Hassociated
with the ﬁrst and second triplet states are J−B+and J+B+; those
associated with the last two states are the eigenvalues of the matrix
/parenleftbiggJB −
B−−3J/parenrightbigg
ofHin the space spanned by the last two; i.e. −J±/radicalBig
4J2+B2
−.
Now the four states (H.10) and (H.11) are also eigenstates of CZ,
the ﬁrst of the three triplet states having eigenvalue −1 and the other
three having eigenvalue 1. Consequently these eigenstates of Hare
also eigenstates of CZwith respective eigenvalues −1, 1, 1, and 1. We
will therefore produce CZ(to within a constant phase factor) if we can
choose the exchange coupling J, the magnetic ﬁelds B1and B0, and
the time tduring which Hacts to satisfy
−eit(J−B+)=eit(J+B+)=eit(−J+√
4J2+B2
−)=eit(−J−√
4J2+B2
−).
(H.14)
The last equality is equivalent to
e2it√
4J2+B2
−=1,or eit√
4J2+B2
−=± 1; (H.15)
the ﬁrst is equivalent to
e2itB+=− 1,or eitB+=± i; (H.16)
3I f|0/angbracketrightis the state |↑/angbracketrightof spin-up along z, and|1/angbracketrightis|↓/angbracketright, then the singlet state
is the state of zero total angular momentum and the three triplet states arethe states of angular momentum 1 with z-components −¯h, 0, and ¯ h.

<<<PAGE 209>>>

1 9 2 APPENDIX H
and the second is equivalent to
e−2itJ=eitB+e−it√
4J2+B2
−. (H.17)
The identities (H.15) and (H.16) require the right side of (H.17) to
be±i. For the (positive) time tfor which the gate acts to be as small
as possible we should choose −i, which gives
Jt=π/4. (H.18)
With this value of twe can satisfy (H.15) (with the minus sign) and
(H.16) (with the plus sign) by taking/radicalBig
4J2+B2
−=4Jand B+=2J.
So we can produce the gate CZ(to within an overall constant phase
factor) by taking the magnetic ﬁelds in the Hamiltonian (H.12) and thetime for which it acts to be related to the exchange coupling by
B
+=2J, B−=2√
3J, t=1
4π/J, (H.19)
or, in terms of the ﬁelds on each spin,
B1=(1+√
3)J, B0=(1−√
3)J, t=1
4π/J.(H.20)
Note the curious fact that although, as (H.2) makes explicit, the
gate CZacts symmetrically on the two spins, the realization of CZby
the unitary transformation eiHtrequires the ﬁelds acting on the spins
to break that symmetry. Of course the symmetry survives in the factthat the alternative choice of ﬁelds B
1=(1−√
3)J,B0=(1+√
3)J
works just as well.

<<<PAGE 210>>>

Appendix I
A little elementary group theory
A set of positive integers less than Nconstitutes a group under multi-
plication modulo Nif the set (a) contains 1, (b) contains the modulo- N
inverse of any of its members, and (c) contains the the modulo- Nprod-
ucts of all pairs of its members. A subset of a group meeting conditions(a)–(c) is called a subgroup. The number of members of a group is called
the order of the group. An important result of the elementary theory of
ﬁnite groups (Lagrange’s theorem) is that the order of any of its sub-groups is a divisor of the order of the group itself. This is establishedin the next three paragraphs.
IfSis any subset of a group G(not necessarily a subgroup) and ais
any member of G(which might or might not be in S), deﬁne aS(called
acoset ofS) to be the set of all members of Gof the form g=as,
where sis any member of S. (Throughout this appendix equality will
be taken to mean equality modulo N.) Distinct members of Sgive rise
to distinct members of aS, for if sand s
/primeare in Sand as=as/prime, then
multiplying both sides by the inverse of agives s=s/prime. So any coset aS
has the same number of members as Sitself.
If the subset Sis a subgroup ofGand sis a member of S, then every
member of the coset sSmust be in S. Since sShas as many distinct
members as Shas, sS=S. If two cosets aSand bSof a subgroup Shave
a common member then there are members sand s/primeofSthat satisfy
as=bs/prime,s o( as)S=(bs/prime)S. But ( as)S=a(sS)= aS, and similarly
(bs/prime)S=bS. Therefore aS=bS: two cosets of a subgroup are either
identical or have no members in common.
IfSis a subgroup and ais a member of G, then since 1 is in S,
ais in the coset aS. Since every member of Gis thus in some coset,
and since the cosets of a subgroup are either identical or disjoint, itfollows that the distinct cosets of a subgroup Spartition the whole
group Ginto disjoint subsets, each of which has the same number of
members as Sdoes. Consequently the total number of members of G
must be an integral multiple of the number of members of any of itssubgroups S:the order of any subgroup Sis a divisor of the order of the whole
group G.
Of particular interest is the subgroup given by all the distinct powers
of any particular member aofG. Since Gis a ﬁnite set, the set of distinct
powers of ais also ﬁnite, and therefore for some nand mwith n>m
we must have a
n=am,o r a(n−m)=1.The order ofais deﬁned to be
193

<<<PAGE 211>>>

1 9 4 APPENDIX I
the smallest nonzero kwith ak=1. The subset a,a2,... , akofGis a
subgroup of G, since it contains 1 =akand the inverses and products
of all its members. It is called the subgroup generated bya, and its order
is the order kofa. Since the order of any subgroup of Gdivides the
order of G, we conclude that the order of any member of Gdivides the
order of G.

<<<PAGE 212>>>

Appendix J
Some simple number theory
J.1 The Euclidean algorithm
We wish to ﬁnd the greatest common divisor of two numbers fand c,
with f>c. The Euclidean algorithm is the iterative procedure that
replaces fand cby f/prime=cand c/prime=f−[f/c]c, where [ x]i st h e
largest integer less than or equal to x. Evidently any factors common
tofand care also common to f/primeand c/primeand vice versa. Furthermore,
f/primeand c/primedecrease with each iteration and each iteration keeps f/prime>c/prime,
until the procedure reaches c/prime=0. Let f0and c0be the values of f
and cat the last stage before c/prime=0. They have the same common
factors as the original fand c, and f0is divisible by c0, since the next
stage is c/prime
0=0. Therefore c0is the greatest common divisor of f
and c.
J.2 Finding inverses modulo an integer
We can use the Euclidean algorithm to ﬁnd the inverse of an integer c
modulo an integer f>c, when fand chave no common factors. In this
case iterating the Euclidean algorithm eventually leads to c0=1. This
stage must have arisen from a pair f1and c1satisfying 1 =f1−mc1
for some integer m. But f1and c1are given by explicit integral linear
combinations of the pair at the preceding stage, f2and c2, which in
turn are explicit integral linear combinations of f3and c3, etc. So one
can work backwards through the iterations to construct integers jand
kwith 1 =jf+kc. Since kcannot be a multiple of f, we can express
kaslf+dwith 1 ≤d<fand with lan integer (negative, if kis
negative); dis then the inverse of cmodulo f.
J.3 The probability of common factors
The probability of two random numbers having no common factors is
greater than1
2, for the probability is3
4that they are not both divisible
by 2,8
9that they are not both divisible by 3,24
25that they are not both
divisible by 5, etc. The probability that they share no prime factors
195

<<<PAGE 213>>>

1 9 6 APPENDIX J
at all is
/productdisplay
primes(1−1/p2)=1/slashBig/productdisplay
primes/parenleftbig
1+1/p2+1/p4+.../parenrightbig
=1//parenleftbig
1+1/22+1/32+1/42+1/52+1/62+···/parenrightbig
=6/π2=0.6079... (J.1)
If the numbers are conﬁned to a ﬁnite range this argument gives only
an estimate of the probability, but it is quite a good estimate if the rangeis large.

<<<PAGE 214>>>

Appendix K
Period finding and continued
fractions
We illustrate here the mathematics of the ﬁnal (post-quantum-
computational) stage of Shor’s period-ﬁnding procedure. The ﬁnalmeasurement produces (with high probability) an integer ythat is
within
1
2of an integral multiple of 2n/r, where nis the number of
Qbits in the input register, satisfying 2n>N2>r2. Deducing the
period rof the function ffrom such an integer ymakes use of the
theorem that if xis an estimate for the fraction j/rthat differs from it
by less than 1 /2r2, then j/rwill appear as one of the partial sums in
the continued-fraction expansion of x.1In the case of Shor’s period-
ﬁnding algorithm x=y/2n.I f jand rhappen to have no factors in
common, ris given by the denominator of the partial sum with the
largest denominator less than N. Otherwise the continued-fraction ex-
pansion of xgives r0:rdivided by whatever factor it has in common
with the random integer j. If several small multiples of r0fail to be a
period of f, one repeats the whole procedure, getting a different sub-
multiple r1ofr. There is a good chance that rwill be the least common
multiple of r0and r1, or a not terribly large multiple of it. If not, one
repeats the whole procedure a few more times until one succeeds in
ﬁnding a period of f. We illustrate this with two examples.
Example 1. (Successful the ﬁrst time.) Suppose we know that the
period ris less than 27=128 and that y=11 490 is within1
2of an
integral multiple of 214/r. What is r?
Example 2. (Two attempts required.) Suppose we know that the in-
teger ris less than 27and that 11 343 and 13 653 are both within1
2of
integral multiples of 214/r. What is r?
In either example the fraction j/rfor some (random) integer jwill
necessarily be one of the partial sums (deﬁned below) of the continued-fraction expansion of y/2
14, where yis one of the cited ﬁve-digit inte-
gers. The partial sum with the largest denominator less than 128 is theone we are looking for. Once we have found the answer we can easilycheck that it is correct.
1 Theorem 184, page 153, G. H. Hardy and E. M. Wright, An Introduction to
the Theory of Numbers , 4th edition, Oxford University Press (1965).
197

<<<PAGE 215>>>

1 9 8 APPENDIX K
The continued-fraction expansion of a real number xbetween 0 and
1i s
x=1
a0+1
a1+1
a2+···(K.1)
with positive integers a0,a1,a2,...Evidently a0is the integral part of
1/x. Let x1be the fractional part of 1 /x. Then it follows from (K.1)
that
x1=1
a1+1
a2+1
a3+···(K.2)
soa1is the integral part of 1 /x1. Letting x2be the fractional part of
1/x1, one can continue this iterative procedure to extract a2as the
integral part of 1 /x2, and so on.
By the partial sums of the continued fraction (K.1), one means
1
a0,1
a0+1
a1,1
a0+1
a1+1
a2,etc. (K.3)
One can deal with both examples using an (unprogrammed) pocket
calculator. One starts with 1 /x=214/yin the display and subtracts
the integral part a0, noting it down. One then inverts what remains,
to get 1 /x1, and repeats the process until one has accumulated a long
enough list of aj.
Analysis of example 1. We know that r<128 and that x=
11 490 /214is within1
22−14ofj/rfor integers jand r. Playing with a
calculator tells us that
11 490 /214=0.701 293 945 3 ...=1
1+1
2+1
2+1
1+1
7+1
35+···
(K.4)
If we drop what comes after the 35 and start forming partial sums
we quickly get to a denominator bigger than 128. If we also drop1
35,

<<<PAGE 216>>>

APPENDIX K 1 9 9
we ﬁnd that
11 490 /214≈1
1+1
2+1
2+1
1+1
7(K.5)
which works out2to54
77. Since 77 is the only multiple of 77 less than
128, r=77. And indeed,
214×54
77=11 490 .079... ,
which is within1
2of 11 490.
Analysis of example 2. We know that the integer ris less than 128
and that x=11 343 /214and x/prime=13 653 /214are both within1
22−14of
integral multiples of 1 /r. The calculator tells us that
11 343 /214=1
1+1
2+1
3+1
1+1
419+···(K.6)
Since 419 is bigger than 128 we can drop the1
419to get
1
1+1
21
4(K.7)
which gives9
13, and indeed
214×9
13=11 342 .769... , (K.8)
which is within1
2of 11 343. The number ris thus a multiple of 13
less than 128, of which there are nine. Had we the function fat hand
(which we do in the case of interest) we could try all nine to determinethe period, but to illustrate what one can do when there are too manypossibilities to try them all, we take advantage of the second piece
2 A more systematic way to get this is to use the famous but not transparently
obvious recursion relation for the numerators pand denominators qof the
partial sums: pn=anpn−1+pn−2, and qn=anqn−1+qn−2, with
q0=a0,q1=1+a0a1and p0=1,p1=a1. One easily applies these to the
sequence a0,a1,a2,...=1,2,2,1,1,7,35,..., stopping when one gets to a
denominator larger than 100.

<<<PAGE 217>>>

2 0 0 APPENDIX K
of information, which could have been produced by running Shor’s
algorithm a second time.
We also have
13 653 /214=1
1+1
4+1
1+1
1364+···(K.9)
Since 1364 is bigger than 128 we can drop the1
1364to get
1
1+1
5(K.10)
which gives5
6, and indeed
214×5
6=13 653 .333... , (K.11)
which is within1
2of 13 653. So ris also a multiple of 6 less than 100.
Since 6 and 13 have no common factors the least multiple of both is6×13=78. Since there is no multiple of 78 less than 100 other than
78 itself, r=78.

<<<PAGE 218>>>

Appendix L
Better estimates of success in
period finding
In Section 3.7 it is shown that with a probability of at least 0.4, a single
application of Shor’s period-ﬁnding procedure produces an integer y
that is within1
2of an integral multiple of 2n/r, where ris the period
sought. Since 2n>N2>r2,y/2nis within 1 /(2r2)o f j/rfor some
integer j, and therefore, by the theorem cited in Appendix K, j/rand
hence a divisor of r(rdivided by any factors it may have in common
with j) can be found from the continued-fraction expansion of y/2n.
What is crucial for learning a divisor of ris that the estimate for
j/remerging from Shor’s procedure be within 1 /2r2of a multiple of
1/r. Now when Nis the product of two odd primes pand q,a si ti si n
the case of RSA encryption, then the required period ris not only less
than N, but also less than1
2N. This is because1
2(q−1) is an integer,
so it follows from Fermat’s little theorem,
bp−1≡1 (mod p), (L.1)
that
b(p−1)(q−1)/2≡1 (mod p). (L.2)
For the same reason it follows from
bq−1≡1 (mod q) (L.3)
that
b(p−1)(q−1)/2≡1 (mod q). (L.4)
But since pand qare prime, the fact that b(p−1)(q−1)/2−1 is divisible
by both pand qmeans that it must be divisible by the product pq, and
therefore
b(p−1)(q−1)/2≡1 (mod pq). (L.5)
So if
br≡1 (mod pq) (L.6)
and rexceeded1
2N, then we would also have
br−(p−1)(q−1)/2=0 (mod pq), (L.7)
201

<<<PAGE 219>>>

2 0 2 APPENDIX L
and since r−1
2(p−1)(q−1)>r−1
2N>0,(L.5) would give a pos-
itive power of bsmaller than rthat was congruent to 1 modulo pq,s o
rcould not be the period (which is the least such power).
It follows that even if yis not the closest integer to an integral
multiple of 2n/r, if it is within 2 of such an integral multiple, then
|y/2n−j/r|<2/N2<1/2r2. (L.8)
So for each j/rthe algorithm will succeed in providing a divisor of r
not only if the measured yis the closest integer to 2nj/r, but also if it
is the second, third, or fourth closest. Gerjuoy has estimated that thisincreases the probability of a successful run to about 0.9.
1
Bourdon and Williams have reﬁned this to 0.95 for large Nand r.2
They also show that if one modiﬁes the hardware, adding a few more
Qbits to the input register so that n>2n0+q, then for rather small
qthe probability of ﬁnding a divisor of rfrom the output of a single
run of the quantum computation can be made quite close to 1.
1 Edward Gerjuoy, “Shor’s factoring algorithm and modern cryptography. An
illustration of the capabilities inherent in quantum computers,” American
Journal of Physics 73, 521–540 (2005),
http://arxiv.org/abs/quant-ph/0411184.
2 P . S. Bourdon and H. T . Williams, “Sharp probability estimates for Shor’s
order-ﬁnding algorithm,”http://arxiv.org/abs/quant-ph/0607148 .

<<<PAGE 220>>>

Appendix M
Factoring and period finding
We establish here the only hard part of the connection between factoring
and period ﬁnding: that the probability is at least1
2that if ais a random
member of Gpqfor prime pand q, then the order rofainGpqsatisﬁes
both
reven (M.1)
and
ar/2/negationslash≡− 1 (mod pq). (M.2)
(In Section 3.10 it is shown that given such an aand its order r, the
problem of factoring N=pqis easily solved.)
Note ﬁrst that the order rofainGpqis the least common multiple
of the orders rpand rqofainGpand in Gq. That rmust be some
multiple of both rpand rqis immediate, since ar≡1 (mod pq) implies
that ar≡1 (mod p) and ar≡1 (mod q). Furthermore, anycommon
multiple r/primeofrpand rqsatisﬁes ar/prime≡1 (mod pq), because if ar/prime=
1+mpand ar/prime=1+nq, then mp=nq. But since the primes p
and qhave no common factors this requires m=kqand n=kp,
and hence ar/prime=1+kpq≡1 (mod pq). Since ris the least integer
with ar≡1 (mod pq),rmust be the least common multiple of rp
and rq.
Consequently condition (M.1) can fail only if rpand rqare both
odd. Condition (M.2) can fail only if rpand rqare both odd multiples
of the same p o w e ro f2 .F o ri f rpcontains a higher power of 2 than
rq, then since ris a common multiple of rpand rq, it will remain a
multiple of rqif a single factor of 2 is removed from it, and therefore
ar/2≡1 (mod q). But this is inconsistent with a failure of condition
(M.2), which would imply that ar/2≡− 1 (mod q).
So a necessary condition for failure to factor N=pqis that rpand
rqare either both odd, or both odd multiples of the same power of 2.
The ﬁrst condition is absorbed into the second if we agree that thepowers of 2 include 2
0=1. Our effort to factor Ncan fail only if we
have picked a random afor which rpand rqare both odd multiples of
the same power of 2 .
To calculate an upper bound for the probability of failure pf, note
ﬁrst that the modulo- pand modulo- qorders, rpand rq,o f aare the
203

<<<PAGE 221>>>

2 0 4 APPENDIX M
same as the mod- pand mod- qorders of the numbers apand aqinGp
and Gq, where
a≡ap(mod p), a≡aq(mod q). (M.3)
Furthermore, every number ainGpqis associated through (M.3) with
a unique pair from Gpand Gq. For if ap=bpand aq=bqthen a−b
is a multiple of both pand q, and therefore, since pand qare distinct
primes, a−bis a multiple of pqitself, so a≡b(mod pq).
Since the ( p−1)(q−1) different members of Gpqare thus in one-
to-one correspondence with the number of distinct pairs, one from the
p−1 members of Gpand one from the q−1 members of Gq, the
modulo- pand modulo- qorders rpand rqof a random integer ain
Gpqwill have exactly the same statistical distribution as the orders rp
and rqof randomly and independently selected integers in Gpand Gq.
So to show that the probability of failure is at most1
2, we must show
that the probability is at most1
2that the orders rpand rqof such a
randomly and independently selected pair are both odd multiples ofthe same power of 2.
We do this by showing that for any prime p, no more than half
of the numbers in G
pcan have orders rpthat are odd multiples of
anygiven power of 2. (Given this, if Pp(j) and Pq(j) are the prob-
abilities that random elements of Gpand Gqhave orders that are
odd multiples of 2j, then the probability of failure pfis less than/summationtext
j≥0Pp(j)Pq(j)≤1
2/summationtext
j≥0Pq(j)=1
2.) This follows from the fact
that if the order p−1o f Gpis an odd multiple of 2kfor some k≥0,
then exactly half the elements of Gphave orders that are odd multi-
ples of 2k. This in turn follows from the theorem that if pis a prime,
then Gphas at least one primitive element bof order p−1, whose
successive powers therefore generate the entire group. Given this the-orem – which is proved at the end of this appendix – we complete theargument by showing that the orders of the odd powers of any suchprimitive bare odd multiples of 2
k, but the orders of the even powers are
not.
Ifr0is the order of bjwith jodd, then
1≡(bj)r0≡bjr0(mod p), (M.4)
sojr0must be a multiple of p−1, the order of b. Since jis odd r0
must contain at least as many powers of 2 as does p−1. But since
the order r0of any element must divide the order p−1 of the group,
r0cannot contain more powers of 2 than p−1 does. So r0is an odd
multiple of 2k. On the other hand if jis even, then bjsatisﬁes
(bj)(p−1)/2=/parenleftbig
bp−1/parenrightbigj/2≡1 (mod p), (M.5)

<<<PAGE 222>>>

APPENDIX M 2 0 5
so the order r0ofbjdivides ( p−1)/2. Therefore p−1 contains at
least one more power of 2 than does r0.
This concludes the proof that the probability is at least1
2that a
random choice of ainGpqwill satisfy both of the conditions (M.1)
and (M.2) that lead, with the aid of an efﬁcient period-ﬁnding routine,to an easy factorization of N=pq, as described in Section 3.10.
What remains is to prove that when pis prime, G
pcontains at
least one number of order p−1. The relevant property of the mul-
tiplicative group of integers {1,2,3, ... , p−1}modulo a prime is
that together with 0 these integers also constitute a group under ad-
dition . This provides all the structure necessary to ensure that a poly-
nomial of degree dhas at most droots.1We can exploit this fact as
follows.
Write the order s=p−1o f Gpin terms of its prime factors qi:
s=p−1=qn1
1···qnm
m. (M.6)
For each qi, the equation xs/qi−1=0 has at most s/qisolutions, and
since s/qi<s, the number of elements in Gp, there must be elements
aiinGpsatisfying
as/qi
i/negationslash≡1 (mod p). (M.7)
Given such an ai, deﬁne
bi=as/(qni
i)
i. (M.8)
We next show that the order of biisqni
i. This is because
b(qni
i)
i≡as
i≡1 (mod p), (M.9)
so the order of bimust divide qni
iand therefore be a power of qi, since
qiis prime. But if that order were any power of qiless than ni, then we
would have as/qk
i
i≡1 (mod p) with k≥1, which contradicts (M.7).
Because each bihas order qni
i, the product b1b2···bmhas order
qn1
1qn2
2···qnmm=p−1.This follows from the fact that if two numbers
inGphave orders that are coprime, then the order of their product is
1 This is easily proved by induction on the degree of the equation, using the
fact that every nonzero integer modulo phas a multiplicative inverse modulo
p. It is obviously true for degree 1. Suppose that it is true for degree m−1
and a polynomial P(x)o fd e g r e e msatisﬁes P(a)=0. Then P(x)=0
implies P(x)−P(a)=0. Since P(x)−P(a) has the form/summationtext
jcj(xj−aj),
the factor x−acan be extracted from each term, leading to the form
(x−a)Q(x), where Q(x) is a polynomial of degree m−1. So if x/negationslash=athen
P(x)=0 requires Q(x)=0, and this has at most m−1 distinct solutions
by virtue of the inductive assumption.

<<<PAGE 223>>>

2 0 6 APPENDIX M
the product of their orders.2Therefore since qn1
1and qn2
2are coprime,
b1b2has order qn1
1qn2
2. But since qn1
1qn2
2and qn3
3are coprime, it follows
that b1b2b3has order qn1
1qn2
2qn3
3. Continuing in this way, we conclude
that b1b2···bmhas order qn1
1qn2
2···qnmm=s=p−1.
2 Let u,v, andwbe the orders of c,d, and cd. Since cu≡1 (mod p) and
(cd)w≡1 (mod p), it follows that dwu≡1 (mod p). So the order vofd
divides wu, and since vand uhave no common factors, vdivides w.I nt h e
same way one concludes that udivides w. Therefore, since vand uare
coprime, wmust be a multiple of uv. Furthermore,
(cd)uv≡cuvdvu≡1 (mod p), so uvmust be a multiple of w. Therefore
w=uv.

<<<PAGE 224>>>

Appendix N
Shor’s 9-Qbit error-correcting code
Shor demonstrated that quantum error correction was possible using
the two orthogonal 9-Qbit codeword states
|0/angbracketright=2−3/2/parenleftbig
|000/angbracketright+| 111/angbracketright/parenrightbig/parenleftbig
|000/angbracketright+| 111/angbracketright/parenrightbig/parenleftbig
|000/angbracketright+| 111/angbracketright/parenrightbig
,(N.1)|1/angbracketright=2−3/2/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig/parenleftbig
|000/angbracketright−| 111/angbracketright/parenrightbig
.
These can be viewed as an extension of the simple 3-Qbit codewords we
examined in Section 5.2, making it possible to deal with 1-Qbit phaseerrors, as well as bit-ﬂip errors. An encoding circuit for the 9-Qbitcode – with an obvious resemblance to Figure 5.1 for the 3-Qbit code –is shown in Figure N.1.
The form (5.18) of a general 1-Qbit corruption simpliﬁes slightly
when the state |/Psi1/angbracketrightis a superposition of the codeword states (N.1), for
it follows from (N.1) that
Z0|/Psi1/angbracketright= Z1|/Psi1/angbracketright= Z2|/Psi1/angbracketright,
Z3|/Psi1/angbracketright= Z4|/Psi1/angbracketright= Z5|/Psi1/angbracketright, (N.2)
Z6|/Psi1/angbracketright= Z7|/Psi1/angbracketright= Z8|/Psi1/angbracketright.
As a result, the general form of a 1-Qbit corruption of |/Psi1/angbracketrightcontains
only 22 independent terms (rather than 28 =(3×9)+1):
|e/angbracketright|/Psi1/angbracketright→/parenleftBigg
|d/angbracketright+| c/angbracketrightZ0+|c/prime/angbracketrightZ3+|c/prime/prime/angbracketrightZ6+9/summationdisplay
i=1/parenleftbig
|ai/angbracketrightXi+|bi/angbracketrightYi/parenrightbig/parenrightBigg
|/Psi1/angbracketright.
(N.3)
We diagnose the error syndrome with eight commuting Hermitian
operators that square to unity:
Z0Z1,Z1Z2,Z3Z4,Z4Z5,Z6Z7,Z7Z8,(N.4)X0X1X2X3X4X5,X3X4X5X6X7X8.
All six Z-operators trivially commute with each other as do the two
X-operators, and any of the six Z-operators commutes with any of the
two X-operators because in every case the number of anticommutations
between a Ziand an Xjis either zero or two.
One easily conﬁrms from (N.1) that |0/angbracketright,|1/angbracketright, and hence any super-
position |/Psi1/angbracketrightof the two, are invariant under all eight operators in (N.4).
Each one of the 22 corrupted terms in (N.3) is also an eigenstate of
207

<<<PAGE 225>>>

2 0 8 APPENDIX N
00000000yΨ
HHH Fig N.1 A circuit that
transforms the 1-Qbit state|ψ/angbracketright=α|0/angbracketright+β|1/angbracketrightinto its
9-Qbit encoded form|/Psi1/angbracketright=α|
0/angbracketright+β|1/angbracketright, where
|0/angbracketrightand|1/angbracketrightare given in
(N.1.) Note the relation tothe simpler 3-Qbitencoding circuit in Figure5.1.
H
H
H
H
H
H
H
HH
H
H
H
H
H
H
H
XXXX
X
XZ
Z
XXXX
X
XZ
Z
Z
ZZ
ZZ
ZZ
ZFig N.2 A circuit to
measure the “errorsyndrome” for Shor’s9-Qbit code. The nineQbits are the nine lowerwires. The circuit is of thetype illustrated in Figure5.7, but with eight ancillaryQbits (the eight upperwires) associated with themeasurement of the eightcommuting operators in(N.4),
Z0Z1,Z1Z2,
Z3Z4,Z4Z5,Z6Z7,Z7Z8,
X0X1X2X3X4X5,and
X3X4X5X6X7X8.
Measurement of the eightancillas projects the state ofthe nine lower Qbits intothe appropriatesimultaneous eigenstate ofthose eight operators.
the eight operators in (N.4) with eigenvalues 1 or −1, because each of
the eight operators either commutes (resulting in the eigenvalue 1) oranticommutes (resulting in the eigenvalue −1) with each of the
Xi,Yi,
andZi. And each of the 22 terms in (N.3) gives rise to a distinct pattern
of negative eigenvalues for the eight operators.

<<<PAGE 226>>>

APPENDIX N 2 0 9
(a) The three errors Z0,Z3, and Z6are distinguished from the Xiand
Yiby the fact that they commute with every one of the six Z-operators
in (N.4). These three Zican be distinguished from each other because
Z0anticommutes with one of the two X-operators, Z6anticommutes
with the other, and Z3anticommutes with both.
(b) All nine errors Xiare distinguished both from the Ziand from
theYiby the fact that they commute with both X-operators. They can
be distinguished from each other because X0,X2,X3,X5,X6, and X8
each anticommutes with a single one of the six Z-operators in (N.4)
(respectively Z0Z1,Z1Z2,Z3Z4,Z4Z5,Z6Z7, and Z7Z8) while X1,X4,
andX7each anticommutes with two distinct Z-operators (respectively
Z0Z1andZ1Z2,Z3Z4andZ4Z5, and Z6Z7andZ7Z8).
(c) Finally, the nine errors Yihave the same pattern of commuta-
tions with the Z-operators in (N.4) as the corresponding Xioperators,
permitting them to be distinguished from each other in the same way.They can be distinguished from the
Xioperators by their failure to
commute with at least one of the two X-operators in (N.4).
So, as with the other codes we have examined, the simultaneous
measurement of the eight commuting operators in (N.4) projects thecorrupted state onto a single one of the terms in (N.3), and the set ofeigenvalues reveals which term it is. One then applies the appropri-ate inverse unitary transformation to restore the uncorrupted state.A circuit that diagnoses the 9-Qbit error syndrome is shown inFigure N.2.

<<<PAGE 227>>>

Appendix O
Circuit-diagrammatic treatment of
the 7-Qbit code
As a further exercise in the use of circuit diagrams, we rederive the
properties of the 7-Qbit error-correcting code, using the method de-veloped in Chapter 5 to establish that the circuit in Figure 5.11 givesthe 5-Qbit codewords.
We start with the observation that the seven mutually commuting
operators
Mi,Ni(i=0,1,2) in (5.42), and Zin (5.49), each with
eigenvalues ±1, have a set of 27nondegenerate eigenvectors that form
an orthonormal basis for the entire seven-dimensional codeword space.In particular the two codeword states |
0/angbracketrightand|1/angbracketrightare the unique eigen-
states of all the MiandNiwith eigenvalues 1, and of Zwith eigenvalues
1 and−1, respectively.
It follows from this that if a circuit produces a state |/Psi1/angbracketrightthat is
invariant under all the MiandNithen|/Psi1/angbracketrightmust be a superposition of
the codeword states |0/angbracketrightand|1/angbracketright, and if |/Psi1/angbracketrightis additionally an eigenstate
ofZthen, to within factors eiϕof modulus 1, |/Psi1/angbracketrightmust be |0/angbracketrightor|1/angbracketright
depending on whether the eigenvalue is 1 or −1.
Figure O.1 shows that the state |/Psi1/angbracketrightproduced by the circuit in
Figure 5.10 is indeed invariant under M0=X0X4X5X6. This ﬁgure
demonstrates that when M0is brought to the left through all the gates
in the circuit it acts directly as Z0on the input state on the left, which
is invariant under Z0. The caption explains why essentially the same
argument applies to the other Mi: when brought all the way to the
left, M1reduces to Z1acting on the input state, and M2reduces to Z2.
Figure O.2 similarly establishes the invariance of |/Psi1/angbracketrightunder the three
Ni.
Figure O.3 establishes that the effect of Z=Z0Z1Z2Z3Z4Z5Z6act-
ing on the right is the same as that of Z3Z4Z5Z6acting on the left.
But since Z6,Z5, and Z4all act on the 1-Qbit states |0/angbracketrightthis leaves
only Z3which converts |ψ/angbracketrighttoZ|ψ/angbracketright, which multiplies by ( −1)xwhen
|ψ/angbracketright=| x/angbracketright. This shows that, as required, Z|/Psi1/angbracketright=(−1)x|/Psi1/angbracketrightwhen
|ψ/angbracketright=| x/angbracketright.
Figure O.4 establishes that the effect of X=X0X1X2X3X4X5X6act-
ing on the right is the same as that of Z0Z1Z2X3acting on the left. But
since Z0,Z1, and Z2all act on the 1-Qbit states |0/angbracketrightthis leaves only
X3which interchanges |1/angbracketrightand|0/angbracketrightwhen|ψ/angbracketright=| x/angbracketright. This shows that
210

<<<PAGE 228>>>

APPENDIX O 2 1 1
0
0
00
0
0
y
0123456
(a) (b)H
HHX
X
X
X
X Z
Fig O.1 Demonstration that the state |/Psi1/angbracketrightconstructed by the circuit
in Figure 5.10 is invariant under M0=X0X4X5X6. We exploit the fact
that bringing an X, acting on the control Qbit of a cNOT , from one
side of the cNOT to the other introduces an additional Xacting on the
target Qbit (and the fact that an Xacting on the target Qbit commutes
with the cNOT). Bringing the Xacting on Qbit 0 to the left of the
three cNOT gates, represented by the controlled triple-NOT on theright, introduces
Xoperators on all three target Qbits, which combine
with the three Xalready acting on those Qbits to produce unit
operators. So all four Xgates on the right reduce to X0, as indicated in
inset (a). That X0can be moved further to the left through H0,i fi ti s
changed into Z0, as shown in inset (b). So M0acting on the extreme
right is equivalent to Z0acting on the extreme left. Since Z0leaves the
1-Qbit state |0/angbracketrightinvariant, |/Psi1/angbracketrightis invariant under M0. A similar
argument applies to M1=X1X3X5X6: the Xiall commute with the
ﬁrst controlled triple-NOT on the right, and then produce a single X1
when moved through the middle controlled triple-NOT , resulting in
Z1when moved the rest of the way to the left. Similarly,
M2=X2X3X4X6produces Z2when moved all the way to the left.

<<<PAGE 229>>>

2 1 2 APPENDIX O
0
0
00
0
0
y
0123456
(a) (b)HHHZ
ZZ
ZZZZZZZ
Fig O.2 Demonstration that the state |/Psi1/angbracketrightconstructed by the circuit
in Figure 5.10 is invariant under N0=Z0Z4Z5Z6. We exploit the fact
that bringing a Z, acting on the target Qbit of a cNOT , from one side
of the cNOT to the other introduces an additional Zacting on the
control Qbit (and the fact that a Zacting on the control Qbit
commutes with the cNOT). So bringing Z4,Z5, and Z6to the left of
all three cNOT gates represented by the controlled triple-NOT on theright introduces three
Zoperators on the control Qbit 0, which
combine with the Z0already acting to produce the unit operator,
reducing the collection of four Zgates on the left to the three Zacting
on Qbits 4, 5, and 6, as indicated in (a). Those Zcan be moved all the
way to the left, always producing a pair of Zgates on the control Qbits
of the multiple cNOT gates they move through, until they act directlyon the input state as
Z4Z5Z6, which leaves it invariant. A similar
argument shows that N1=Z1Z3Z5Z6acting on the extreme right is
the same as Z5Z6acting on the extreme left, and that N2=Z2Z3Z4Z6
on the right is the same as Z4Z6on the left.

<<<PAGE 230>>>

APPENDIX O 2 1 3
0
0
00
0
0
y
0123456
(a) (b) (c) (d) (e)HHHZ
ZZ
Z
ZZ
Z
Z
Z
Z
ZZ
Z
ZZ
ZZZ
Z
ZZZ
Z
ZZZ
Z
ZZZ
Fig O.3 Demonstration that Z=Z0Z1Z2Z3Z4Z5Z6acting on the
right of the circuit in Figure 5.10 is the same as Z3Z4Z5Z6acting on
the left. Since Z4,Z5, and Z6all act as the identity on the 1-Qbit states
|0/angbracketrightthis leaves only Z3which converts |ψ/angbracketrighttoZ|ψ/angbracketright. This results in a
factor of ( −1)xwhen|ψ/angbracketright=| x/angbracketright, showing that Z|/Psi1/angbracketright=(−1)x|/Psi1/angbracketrightwhen
|ψ/angbracketright=| x/angbracketright.

<<<PAGE 231>>>

2 1 4 APPENDIX O
0
0
00
0
0
y
0123456
(a) (b) (c) (d) (e)HHHX
X
X
XX
X
X
X X
XX
X
XX
X
XX
X
X X X XX X X XX
ZZZ
Fig O.4 Demonstration that X=X0X1X2X3X4X5X6acting to the
right of the circuit in Figure 5.10 is the same as X3Z2Z1Z0acting to
the left. Since Z2,Z1, and Z0all act as the identity on the 1-Qbit states
|0/angbracketrightthis leaves only X3which converts |ψ/angbracketrighttoX|ψ/angbracketright. When |ψ/angbracketright=| x/angbracketright
this interchanges |0/angbracketrightand|1/angbracketright, and therefore Xinterchanges the
corresponding states produced by the circuit.

<<<PAGE 232>>>

APPENDIX O 2 1 5
0
0
00
0
0
0
0
0
00
0
0
0
0
0
00
0
0
0
0
0
00
0
0
0=
HHH
HHHFig O.5 Demonstration
that the state produced bythe circuit in Figure 5.10when|ψ/angbracketright=| 0/angbracketrighthas an
inner product with thestate|0/angbracketright
7t h a ti s1 /23/2,
thereby establishing that
the state is precisely |1/angbracketright
without any additionalphase factor. We sandwichthe circuit of Figure 5.10between |0/angbracketright
7and 7/angbracketleft0|,
following the procedure
developed in Figure 5.19.
Since all the cNOT gateshave|0/angbracketrightfor their control
bits, they all act as theidentity. The diagramsimpliﬁes to the form onthe right, consisting of four
inner products /angbracketleft0|0/angbracketright=1
and three matrix elements/angbracketleft0|
H|0/angbracketright=1/√
2. So the
inner product is indeed1/2
3/2.Xinterchanges the corresponding states produced by the circuit. It
also establishes that if |/Psi1/angbracketrightdiffers by a phase factor eiϕfrom|0/angbracketrightwhen
|ψ/angbracketright=| 0/angbracketright, then it will differ by the same phase factor from |1/angbracketrightwhen
|ψ/angbracketright=| 1/angbracketright.
It remains to show that when |ψ/angbracketright=| 0/angbracketrightin Figure 5.10, the resulting
state is given by |0/angbracketrightwithout any nontrivial phase factor eiϕ. Since |0/angbracketright7
appears in the expansion of |0/angbracketrightwith the amplitude 1 /23/2, we must show
that when the input to the circuit in Figure 5.10 is |0/angbracketright7the inner product
of the output with |0/angbracketright7is 1/23/2, without any accompanying nontrivial
eiϕ. This is established in a circuit-theoretic manner in Figure O.5, as
explained in the caption.

<<<PAGE 233>>>

Appendix P
On bit commitment
Alice prepares nQbits in a computational basis state |x/angbracketright, applies a
certain n-Qbit unitary transformation Uto the Qbits, and then gives
them to Bob. If Bob knows that all 2nvalues of xare equally likely,
what can he learn from the Qbits about Alice’s choice of U?
The answer is that he can learn nothing whatever about U. The most
general thing he can do to acquire information is to adjoin mancillary
Qbits to the nAlice gave him ( mcould be zero), subject them all to
a quantum computation that brings about an ( n+m)-Qbit unitary
transformation W, and then measure all n+mQbits. The state prior
to the measurement will be
|/Psi1x/angbracketright= W/parenleftBig/parenleftbig
U|x/angbracketright/parenrightbig
⊗|/Phi1/angbracketright/parenrightBig
, (P .1)
where |/Phi1/angbracketrightis the initial state of the mancillas and all 2nvalues of xfrom
0t o2n−1 are equally likely. The probability of Bob getting zwhen he
measures all n+mQbits is
p(z)=(1/2n)/summationdisplay
x/angbracketleftz|/Psi1x/angbracketright/angbracketleft/Psi1x|z/angbracketright=(1/2n)/angbracketleftz|/summationdisplay
x/parenleftBig
|/Psi1x/angbracketright/angbracketleft/Psi1x|/parenrightBig
|z/angbracketright.
(P .2)
We have
|/Psi1x/angbracketright/angbracketleft/Psi1x|=W/parenleftBig/parenleftbig
U|x/angbracketright/angbracketleftx|U†/parenrightbig
⊗/parenleftbig
|/Phi1/angbracketright/angbracketleft/Phi1|/parenrightbig/parenrightBig
W†, (P .3)
and since
/summationdisplay
x|x/angbracketright/angbracketleftx|=1, (P .4)
we then have
/summationdisplay
x|/Psi1x/angbracketright/angbracketleft/Psi1x|=W/parenleftBig/parenleftbig
UU†/parenrightbig
⊗/parenleftbig
|/Phi1/angbracketright/angbracketleft/Phi1|/parenrightbig/parenrightBig
W†=W/parenleftBig
1⊗/parenleftbig
|/Phi1/angbracketright/angbracketleft/Phi1|/parenrightbig/parenrightBig
W†.
(P .5)
We see from (P .2) and (P .5) that Uhas dropped out of the prob-
ability p(z), so the outcome of Bob’s ﬁnal measurement provides no
information whatever about Alice’s unitary transformation.
In the application to bit commitment in Section 6.3, Alice’s unitary
transformation Uis either the n-Qbit identity or the tensor product
216

<<<PAGE 234>>>

APPENDIX P 2 1 7
ofn1-Qbit Hadamards, H⊗n, and the random n-Qbit state |x/angbracketrightarises
from the tensor product of n1-Qbit states, each of which is randomly
|0/angbracketrightor|1/angbracketright.
One might wonder whether Bob could do better by measuring some
subset of all the Qbits at an intermediate stage of the computation,and then applying further unitary transformations to the unmeasuredQbits conditional upon the outcome of that measurement. But this,by an inversion of the Grifﬁths–Niu argument in Section 3.6, wouldbe equivalent to ﬁrst applying an appropriate multi-Qbit controlledunitary gate, and only then measuring the control Qbits. That gate canbe absorbed in
Wand the subsequent measurement of its control Qbits
deferred to the end of the computation. So this possibility is coveredby the case already considered.

<<<PAGE 235>>>

Index
abstract bit, 3
action at a distance, 154–158, 175–180additional subroutine Qbits, 36, 46–50; in
Deutch’s problem, 49
adjoint transformation, 162; of product,
75, 162; self adjoint, 163
amplitude, 18analog computation, 84–86angular momentum, 15, 16, 191ancilla (ancillary Qbit); in bit commitment,
216; in Deutsch’s problem, 184; in errorcorrection, 102–109, 114–116, 120–121,
208; in Grover algorithm, 94–96; in
teleportation, 151
anticommutation, of error-syndrome
operators, 107, 117, 119–126, 207–209;of Pauli matrices, 16; of
XandZ,
13
associative law and Dirac notation, 111,
165
atoms, 1–2, 31–32, 99–100, 174automation of error correction, 106
bar, 21, 48–50,153
basis, 6–7; of algebra, 16; Bell, 136–137,
147, 150; classical, 18; computational,18, 36; operator, 166, 168
BB84, 139Bell basis, seebasis
Bell’s theorem, 136, 154Bernstein-Vazirani problem, 50–54bit commitment, 143–146,
216–217
bit-ﬂip error, 100–107, 112
Bohmian, 177nBorn rule, 23–28; generalized, 28–30, 56,
70, 78, 115, 181–182
bra vector, 22, 161–162, 166
C,seecontrolled-NOT
Cbit 3–17; compared with Qbit, 34–35Cheshire cat, 39chorus, rhapsodic, 38circuit diagram, 21–23; for
Bernstein-Vazirani problem, 53; forcontrolled- Ugate, 60; for dense coding,
148; for ﬁve-Qbit code, 129; formeasurement gates, 25–26; for multiply
controlled operations, 94–97; for
nine-Qbit code, 208; for quantumFourier transform, 76–80; forseven-Qbit code, 127; for teleportation,152; for Toffoli gate, 61
classical basis, 18, see also basis
classical computer, 1; reversible 28, 36–37,
58
cloning, seeno-cloning theorem
cNOT , seecontrolled Not
c-number, 3codepad, one-time, 138–140coding, dense, 146–149collapse of state, 26
complexity, computational, 2
computational basis, 18, see also basis
computational process
U f, 36–37,
46–50
computer, classical, 1computer, quantum, 1–3confusion, possibilities for, 3, 11,
22, 25
constructing codewords, ﬁve-Qbit,
119–120, 128–135; nine-Qbit, 208;seven-Qbit, 123–124, 127–128
constructing states, 32–34continued fractions, 82, 197–198control Cbit, 9–10, 14controlled NOT , 9–10; diagrams for, 50,
120; making a gate, 189–192; multiply
controlled, 58–61, 94–97
controlled phase gates, 76–80controlled- U, 59–62
controlled- Z, 14, 46, 189–192; multiply
controlled, 94–97
control Qbit, 42, 50, 60, 77–78, 96, 108, 130cooling Qbits, 32correlations, 105, 158cryptography, quantum, 138–143; RSA,
63–64, 66–69
cum grano salis, 82
dagger ( †), 162
decoherence, 1, 111degenerate, 164dense coding, 146–149density matrix, 18
Deutsch’s problem, 41–46, 49,
183–186
diagram, circuit, seecircuit diagram
digital computation, 31, 85Dirac notation, 3, 5–6, 111, 159–167;
disapproved of by mathematicians, 160
dot product of integers, 50
dual space, 161–163
eavesdropper, 67–68, 138–142
eigenstate, seeeigenvector
eigenvalue, 163eigenvector, 163element of reality, 156–157encryption, seecryptography
entanglement, 18–19; of Bell basis,
136–137; and bit commitment, 145–146;and dense coding, 146–149; withenvironment, 111; of input and outputregisters, 55; manufacturing, 33; andquantum cryptography, 142–143; andspooky action at a distance, 175–180;with subroutine Qbits, 43, 46–49; and
teleportation, 149–154
EPR (Einstein-Podolsky-Rosen)
argument, 157
ERASE, 8error correction, 2, 99–135, 207–215; and
teleportation, 151, see also error
generation, error syndrome, ﬁve-Qbitcode, nine-Qbit code, seven-Qbit code
error generation (physics of), 109–113error syndrome, 102, 117, 119–120, 121,
123, 128, 207–209

<<<PAGE 236>>>

INDEX 2 1 9
Euclidean algorithm, 67–68, 83, 87,
195
exchange interaction, 190exchange operator, 9, 15exclusive OR, 10; bitwise, 37
factoring, 63–64; atypicality of ﬁfteen, 82;
and period ﬁnding, 86–87, 203–206; andRSA encryption, 64–68, see also period
ﬁnding
factors, probability of common, 195–196fault tolerance, 127Fermat’s little theorem, 65–66, 201ﬁve-Qbit error correcting code, 109,
117–120, 128–135
ﬂip, 9, see also bit-ﬂip error
Fourier transform, quantum, 71–86; use in
searching, 98; phase errors, 84–86
fractions, continued, seecontinued
fractions
functional, linear, 161–162, see also bra
vector
gates, 1-Qbit, 20–21; 2-Qbit, 20;
measurement, 23–32; n-Qbit, 21
generalized Born rule, seeBorn rule
GHZ (Greenberger Horne Zeilinger)
puzzle, 154–158
Grifﬁths Niu trick, 76–80, 217group theory, 64–68, 193–194, 203–206Grover iteration, 89–94
Grover search algorithm, 88–98
H,seeHadamard transformation
Hadamard transformation, 13–14; effect
on cNOT , 14, 54; in error correction,114–116; n-fold, 51, 72; in quantum
Fourier transform, 72–80; in seven-Qbitcode, 125–126; and superposition of allinputs, 37–38
happen, what didn’t, 158
Hardy state, 175–180
Hermitian matrix, 15nHermitian operator, 163–164
inner product, 159–161, 166; bitwise
modulo-two, 50; in circuit diagrams,134; of tensor product, 40
input register, 36interactions, 1, 58, 99–100, 109, 111, 138,
189–190
interchanging target and control Qbits, 14inverses in modular arithmetic, 65–69, 195irreversible operations, 8, 24, 36ket vector, 22, 161–162, 166
Lagrange’s theorem, 193
linear operator, 161; adjoint, 162; functions
of, 165; norm-preserving,19; outerproduct of two vectors, 165; reversal oforder in circuit diagrams, 22; tensorproduct of, 164; unitary, 19–20.
linear transformation, seelinear operator
macroscopic, 1
magic, 8, 36, 38many worlds, seerhapsodic chorus
mathematicians, disapproval of Dirac
notation, 160
matrix, density, 18, 110, 138–140
matrix element, 162; of adjoint operator,
163; transposed, 163
matrix, Pauli, 15–16, 168–172measurement, 8, 23–26, 28–30, 181–182;
in Bell basis, 147; of control Qbit,77–78; of operators that square to unity,
115; and state preparation, 30–32
measurement gate, 23–32mixed state, 18modulo-two addition ( ⊕), 10; bitwise, 31;
bitwise inner product, 50
modulo Narithmetic, 64, 193–194
multiply controlled operations, 58–61,
94–97
n,seenumber operator
nine-Qbit error-correcting code, 207–209
no-cloning theorem, 39–40, 70, 103, 150
nonlocality, quantum, seequantum
nonlocality
normalization, 17, 24, 159NOT (
X), 8–9; square root of, 59–60
notation, Dirac, seeDirac notation
number operator ( n), 11–12, 173
number theory, 64–68, 82–83, 86–87,
88–89, 195–196, 197–198, 201–202,203–206
one-time codepad, 138–140
operator, seelinear operator
operator basis, 166order, of a group, 65, 193; of a member of a
group, 65, 193–194; of a subgroup, 193
outer product, 165output register, 36
parallelism, quantum, 37–39, 69, 84
Pauli matrices 15–16, 168–172period ﬁnding, 55, 63–64; and continued
fractions, 197–198; estimates of success,
201–202; and factoring, 86–87, 203–206;
and phase errors, 84–86; with quantumcomputer, 68–71, 83–84; and quantumFourier transform, 71–83; and RSAencryption, 64–69; in searching, 98
permutations, as reversible operations on
Cbits, 9, 19; extended from Cbits toQbits, 19–20; in quantum Fouriertransform, 75, 77, 80
phase errors, in error correction, 100, 112,
207; in quantum Fourier transform,84–86
phase factor, 164philosophy, 40, 145
photon, 100, 110, 137–140, 143–144,
149
physicists, irritating practice of, 9; remarks
addressed primarily to, 13n, 15n, 23n,71n, 80n, 189–192
polar decomposition theorem, 34polarization, 110, 138–140
POVM, 24n
preparation of state, 30–32product, inner, seeinner product
product, outer, 165product, tensor, seetensor product
product, vector, 16programming styles, 84probability, of measurement outcomes,
24–30, see also Born rule; in number
theory, 67n, 87, 195–196, 203–206; inquantum computation, 54–55, 57,80–83, 88; of success in Simon’sproblem, 187–188
projection operators, 165; and Born rule,
28
pure state, 18n
Qbit, 3–4; compared with Cbit, 34–35;
extracting information from, 23–27;operations on, 19–21; spelling of, 4;states of, 17–19
q-number, 3quantum computer, 1–3quantum cryptography, seecryptography
quantum Fourier transform, seeFourier
transform
quantum mechanics, why easily learned by
computer scientists, xii–xiii
quantum nonlocality, 177, see also spooky
action at a distance
quantum parallelism, 37–39, 69, 84

<<<PAGE 237>>>

2 2 0 INDEX
quantum weirdness, xiii, 39, 154–158,
175–180
quaternions, 16qubit, 4, see also Qbit
qunumber, ungainliness of, 4Qutip, absurdity of, 4
reality, element of, 156
reduction of state, 26
register, input, 36
register, output, 36relational information, 40–41, 56–57; in
error correction, 103–109
reversed convention in circuit diagrams,
21–22
reversible, classical computation, 28,
36–37, 58; operations on Cbits, 8–11;
operations on Qbits, 19–20; whyquantum computer must be, 46–50
rhapsodic chorus, 38rotations, in Grover algorithm, 92–94; and
Pauli matrices, 16, 168–174, 179–180
RSA encryption, 63–64, 66–69
salis, cum grano, 82
Schmidt decomposition theorem, 34searching, 88–98; for one of four items, 98;
for several marked items, 96–98
self-adjoint, 163, see also Hermitian.
seven-Qbit error correcting code, 121–128,
210–215
Shor algorithm, seeperiod ﬁnding
Simon’s problem, 54–58, 63, 187–188singlet state, 190–191SO(3), 172
spin, 16, 110, 174, 189–192spooky action at a distance, 154–158,
175–180
state, of Cbits, 3–8; general 1-Qbit,
173–174; of Qbits, 17–19; of Qbits and
Cbits, compared, 35
state construction, 32–33state preparation, 30–32SU(2), 172subgroup, 193subroutines, 36, 46–50superposition, 17–18; action of quantum
Fourier transform on, 71; of all possible
inputs, 37–38; naive misunderstandingof, 26–28
swap, 9–10, 12–13; constructed with Pauli
matrices, 15–17
syndrome, error, seeerror syndrome
target Cbit, 9–10
target Qbit, 14; of controlled- Ugate, 59; of
Toffoli gate, 58
teleportation, 149–154; of entanglement,
153–154
tensor product of states, 6–8, 18, 164; of
operators, 10–11, 164
theorem, Bell’s, 136, 154; continued
fractions, 82, 197–199; Fermat’s little,
65, 201; Lagrange’s, 193; no-cloning,39–40; on primitive generators, 204;Schmidt (polar) decomposition, 34n
three-Qbit error-correcting code,
100–109Toffoli gate, 58–62; in error correction, 95;
in Grover algorithm, 94–96
trace, 170
transformation, linear, 161transpose, 163triplet state, 190–191
U f, 36–37; in the presence of subroutine
Qbits, 46–50
UFT, 71–76
uncertainty principle, 40unitary transformation, 19–21, 161–164;
general 1-Qbit, 168–172
vector, bra, 22, 161–162, 166
vector, ket, 22, 161–162, 166vector product, 16vector space, 159–167von Neumann measurement, 23n
Walsh-Hadamard transformation, see
Hadamard transformation
weirdness, quantum, xiii, 39, 154–158,
175–180
wire, 21worlds, many, seerhapsodic chorus
X,seeNOT
XOR, 10, 50, 138–139
Y, 15, 112
Z,1 3
Z,7 2